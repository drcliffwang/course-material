<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>數據分析與機器學習輔助</title>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Plotly.js for interactive charts -->
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

    <!-- SheetJS (xlsx.full.min.js) for reading Excel files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- simple-statistics for basic stats -->
    <script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>

    <!-- jStat for advanced statistical functions -->
    <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>

    <!-- regression-js (not used by runLogistic anymore) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/regression/2.0.1/regression.min.js"></script>

    <!-- ml.js for Decision Tree -->
    <script src="https://www.lactame.com/lib/ml/6.0.0/ml.min.js"></script>

    <!-- html2canvas for Wordcloud PNG download -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>


    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            background-color: #f8fafc;
        }

        .tab-button {
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
            color: #64748b;
            /* slate-500 */
            margin-bottom: -1px;
            /* Overlap border */
        }

        .tab-button:hover {
            color: #1e293b;
            /* slate-800 */
            background-color: #f1f5f9;
            /* slate-100 */
        }

        .tab-button.active {
            font-weight: 600;
            background-color: #fff;
            border-top: 2px solid;
            /* Top highlight */
            border-left: 1px solid #e2e8f0;
            border-right: 1px solid #e2e8f0;
            border-bottom-color: transparent;
            /* Hide bottom border to merge with content */
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.02);
        }

        /* Specific active colors for top border and text */
        .tab-button[data-tab="eda"].active {
            color: #2563eb;
            border-top-color: #2563eb;
        }

        .tab-button[data-tab="basic"].active {
            color: #059669;
            border-top-color: #059669;
        }

        .tab-button[data-tab="forecast"].active {
            color: #d97706;
            border-top-color: #d97706;
        }

        .tab-button[data-tab="ml"].active {
            color: #7c3aed;
            border-top-color: #7c3aed;
        }

        /* When a top-level tab is active, give its child/sub-menu buttons the same color
           by toggling a class on #analysisContent (handled in switchTab). */
        #analysisContent.active-tab-eda .ml-tab-button,
        #analysisContent.active-tab-eda .basic-tab-button,
        #analysisContent.active-tab-eda .forecast-tab-button {
            color: #2563eb;
        }

        #analysisContent.active-tab-basic .basic-tab-button,
        #analysisContent.active-tab-basic .basic-tab-button:not(.active) {
            color: #059669;
        }

        #analysisContent.active-tab-forecast .forecast-tab-button,
        #analysisContent.active-tab-forecast .forecast-tab-button:not(.active) {
            color: #d97706;
        }

        #analysisContent.active-tab-ml .ml-tab-button,
        #analysisContent.active-tab-ml .ml-tab-button:not(.active) {
            color: #7c3aed;
        }

        /* Group-specific button backgrounds and active/hover states */

        /* Shared base style for sub-tabs */
        .basic-tab-button,
        .forecast-tab-button,
        .ml-tab-button {
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            /* Pill shape */
            font-weight: 500;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            margin-bottom: 0.5rem;
            /* For wrapping */
        }

        /* Basic analysis (green) */
        #analysisContent.active-tab-basic .basic-tab-button {
            color: #4b5563;
            /* gray-600 */
        }

        #analysisContent.active-tab-basic .basic-tab-button:hover {
            color: #059669;
            background-color: #ecfdf5;
            /* emerald-50 */
        }

        #analysisContent.active-tab-basic .basic-tab-button.active {
            color: #047857;
            /* emerald-700 */
            background-color: #d1fae5;
            /* emerald-100 */
            border-color: #a7f3d0;
            /* emerald-200 */
            box-shadow: none;
        }

        /* Forecast (orange) */
        #analysisContent.active-tab-forecast .forecast-tab-button {
            color: #4b5563;
            /* gray-600 */
        }

        #analysisContent.active-tab-forecast .forecast-tab-button:hover {
            color: #d97706;
            background-color: #fff7ed;
            /* orange-50 */
        }

        #analysisContent.active-tab-forecast .forecast-tab-button.active {
            color: #c2410c;
            /* orange-700 */
            background-color: #ffedd5;
            /* orange-100 */
            border-color: #fed7aa;
            /* orange-200 */
            box-shadow: none;
        }

        /* ML (purple) */
        #analysisContent.active-tab-ml .ml-tab-button {
            color: #4b5563;
            /* gray-600 */
        }

        #analysisContent.active-tab-ml .ml-tab-button:hover {
            color: #7c3aed;
            background-color: #f5f3ff;
            /* violet-50 */
        }

        #analysisContent.active-tab-ml .ml-tab-button.active {
            color: #6d28d9;
            /* violet-700 */
            background-color: #ede9fe;
            /* violet-100 */
            border-color: #ddd6fe;
            /* violet-200 */
            box-shadow: none;
        }

        /* ===== Override action button colors per analysis group ===== */
        /* Apply to <button> and input buttons inside each group's content area */
        /* Basic -> Green */
        #analysisContent.active-tab-basic #basicContent button,
        #analysisContent.active-tab-basic #basicContent input[type="button"],
        #analysisContent.active-tab-basic #basicContent input[type="submit"] {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%) !important;
            color: #ffffff !important;
            border-color: transparent !important;
            box-shadow: 0 8px 24px rgba(5, 150, 105, 0.12) !important;
        }

        #analysisContent.active-tab-basic #basicContent button:hover,
        #analysisContent.active-tab-basic #basicContent input[type="button"]:hover,
        #analysisContent.active-tab-basic #basicContent input[type="submit"]:hover {
            filter: brightness(0.95) !important;
            transform: translateY(-1px);
        }

        /* Forecast -> Orange */
        #analysisContent.active-tab-forecast #forecastContent button,
        #analysisContent.active-tab-forecast #forecastContent input[type="button"],
        #analysisContent.active-tab-forecast #forecastContent input[type="submit"] {
            background: linear-gradient(135deg, #fb923c 0%, #d97706 100%) !important;
            color: #ffffff !important;
            border-color: transparent !important;
            box-shadow: 0 8px 24px rgba(217, 119, 6, 0.12) !important;
        }

        #analysisContent.active-tab-forecast #forecastContent button:hover,
        #analysisContent.active-tab-forecast #forecastContent input[type="button"]:hover,
        #analysisContent.active-tab-forecast #forecastContent input[type="submit"]:hover {
            filter: brightness(0.95) !important;
            transform: translateY(-1px);
        }

        /* ML -> Purple */
        #analysisContent.active-tab-ml #mlContent button,
        #analysisContent.active-tab-ml #mlContent input[type="button"],
        #analysisContent.active-tab-ml #mlContent input[type="submit"] {
            background: linear-gradient(135deg, #a78bfa 0%, #7c3aed 100%) !important;
            color: #ffffff !important;
            border-color: transparent !important;
            box-shadow: 0 8px 24px rgba(124, 58, 237, 0.12) !important;
        }

        #analysisContent.active-tab-ml #mlContent button:hover,
        #analysisContent.active-tab-ml #mlContent input[type="button"]:hover,
        #analysisContent.active-tab-ml #mlContent input[type="submit"]:hover {
            filter: brightness(0.95) !important;
            transform: translateY(-1px);
        }

        .card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        input[type="file"]::file-selector-button {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        input[type="file"]::file-selector-button:hover {
            background-color: #1d4ed8;
        }

        /* Custom styled '選擇檔案' button (accessible + highlighted state) */
        .file-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .file-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: #fff;
            padding: 0.55rem 1rem;
            border-radius: 0.625rem;
            font-weight: 700;
            font-size: 0.95rem;
            box-shadow: 0 8px 24px rgba(37, 99, 235, 0.16);
            border: none;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: transform 0.18s ease, box-shadow 0.18s ease;
        }

        .file-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 30px rgba(37, 99, 235, 0.2);
        }

        .file-btn:focus {
            outline: 3px solid rgba(59, 130, 246, 0.22);
            outline-offset: 3px;
        }

        .file-btn.highlight {
            animation: pulse-highlight 2.2s infinite;
        }

        @keyframes pulse-highlight {
            0% {
                box-shadow: 0 8px 22px rgba(59, 130, 246, 0.18);
            }

            50% {
                box-shadow: 0 18px 40px rgba(59, 130, 246, 0.22);
            }

            100% {
                box-shadow: 0 8px 22px rgba(59, 130, 246, 0.18);
            }
        }

        .chosen-filename {
            font-size: 0.92rem;
            color: #374151;
            max-width: 30rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .sr-only {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            white-space: nowrap !important;
            border: 0 !important;
        }

        .ml-tab-button {
            padding-bottom: 0.5rem;
            border-bottom: 3px solid transparent;
        }

        .ml-tab-button.active {
            color: #db2777;
            border-bottom-color: #db2777;
        }

        .basic-tab-button {
            padding-bottom: 0.5rem;
            border-bottom: 3px solid transparent;
        }

        .basic-tab-button.active {
            color: #059669;
            border-bottom-color: #059669;
        }

        .forecast-tab-button {
            padding-bottom: 0.5rem;
            border-bottom: 3px solid transparent;
        }

        .forecast-tab-button.active {
            color: #d97706;
            border-bottom-color: #d97706;
        }


        /* ===== v2.5 革命性修復: Modal 彈窗樣式 ===== */
        .prediction-modal {
            display: none;
            position: fixed;
            z-index: 999999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.3s ease;
        }

        .prediction-modal.show {
            display: flex !important;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: #ffffff;
            padding: 2.5rem;
            border-radius: 1rem;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            animation: slideDown 0.4s ease;
            position: relative;
        }

        .modal-header {
            font-size: 1.75rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid #3b82f6;
        }

        .modal-result {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin: 1.5rem 0;
            border-left: 5px solid #3b82f6;
        }

        .modal-result-item {
            margin: 1rem 0;
            font-size: 1.125rem;
        }

        .modal-prob-value {
            font-size: 2rem;
            font-weight: bold;
            color: #059669;
        }

        .modal-close-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            padding: 0.75rem 2rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1.125rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 1rem;
        }

        .modal-close-btn:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(37, 99, 235, 0.3);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .wordcloud-word {
            display: inline-block;
            margin: 0.2rem 0.4rem;
            line-height: 1;
            white-space: nowrap;
        }

        /* 強化欄位選擇 UI */
        select {
            border-width: 2px;
            border-color: #4B5563;
            font-weight: 600;
        }

        select:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.4);
            border-color: #10B981;
        }

        label {
            font-weight: 600;
            color: #111827;
        }

        /* 文字雲圓形容器與文字樣式 */
        #wordcloudContainer {
            position: relative;
        }

        .wordcloud-word {
            position: absolute;
            transform: translate(-50%, -50%);
            white-space: nowrap;
            line-height: 1;
            pointer-events: none;
        }


        /* === Aesthetic Upgrade: Data Driven Decision Making UI v1 === */
        :root {
            --bg-page: #F8F9FA;
            --bg-card: #FFFFFF;
            --text-main: #212529;
            --text-muted: #6C757D;
            --primary: #007BFF;
            --primary-soft: #E7F1FF;
            --accent: #FFC107;
            --border-soft: #DEE2E6;
            --shadow-soft: 0 10px 30px rgba(15, 23, 42, 0.08);
        }

        body {
            background-color: var(--bg-page);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Noto Sans TC", "Microsoft JhengHei",
                "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "PingFang TC", "Heiti TC";
            line-height: 1.65;
        }

        /* 頂部 Hero 區域微調 */
        .bg-slate-50 {
            background: radial-gradient(circle at top left, #E7F1FF 0, #F8F9FA 40%, #FFFFFF 100%);
        }

        h1,
        h2,
        h3,
        h4 {
            letter-spacing: 0.02em;
        }

        h1 {
            font-weight: 800;
        }

        h2 {
            font-weight: 700;
        }

        h3,
        h4 {
            font-weight: 600;
        }

        /* 主內容寬度控制：避免超寬行長 */
        #mainContent,
        .container {
            max-width: 1100px;
        }

        #mainContent {
            margin-left: auto;
            margin-right: auto;
            padding: 1rem;
        }

        @media (min-width: 768px) {
            #mainContent {
                padding: 2rem;
            }
        }

        /* 卡片樣式強化 */
        .card {
            background-color: var(--bg-card);
            box-shadow: var(--shadow-soft);
            border-radius: 1rem;
            border: 1px solid rgba(148, 163, 184, 0.18);
        }

        .card h2 {
            position: relative;
        }

        .card h2::after {
            content: "";
            position: absolute;
            left: 0;
            bottom: -0.4rem;
            width: 3rem;
            height: 3px;
            border-radius: 999px;
            background: linear-gradient(to right, var(--primary), var(--accent));
        }

        /* Tab 樣式微調：更清楚的分層與互動感 */
        .tab-button {
            font-size: 0.98rem;
            padding-left: 0.25rem;
            padding-right: 0.25rem;
            color: #64748B;
        }

        .tab-button.active {
            color: var(--primary);
        }

        .basic-tab-button,
        .forecast-tab-button,
        .ml-tab-button {
            font-size: 0.9rem;
            color: #6B7280;
        }

        .basic-tab-button.active,
        .forecast-tab-button.active,
        .ml-tab-button.active {
            color: var(--primary);
        }

        /* 上傳區按鈕與檔案選擇美化 */
        input[type="file"] {
            font-size: 0.875rem;
        }

        input[type="file"]::file-selector-button {
            background-color: var(--primary-soft);
            color: var(--primary);
            font-weight: 600;
        }

        input[type="file"]::file-selector-button:hover {
            background-color: #d7e6ff;
        }

        button {
            letter-spacing: 0.02em;
        }

        /* 表格：統一專業風格 + 斑馬紋 */
        table {
            border-collapse: collapse;
            width: 100%;
            font-size: 0.85rem;
        }

        th,
        td {
            padding: 0.45rem 0.75rem;
            border-bottom: 1px solid var(--border-soft);
        }

        th {
            background-color: #F1F3F5;
            font-weight: 600;
            color: #495057;
        }

        tbody tr:nth-child(odd) {
            background-color: #F8F9FA;
        }

        tbody tr:hover {
            background-color: #E9F5FF;
        }

        /* 重要資訊區塊 (決策提示 / 統計結論) */
        .callout {
            border-radius: 0.75rem;
            border: 1px solid rgba(13, 110, 253, 0.18);
            padding: 0.9rem 1rem;
            background: linear-gradient(135deg, #F8FBFF 0%, #FDFEFF 100%);
        }

        .callout-title {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .callout-title::before {
            content: "◎";
            font-size: 0.8rem;
        }

        .callout-body {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        /* 標籤與提示文字 */
        label {
            font-size: 0.88rem;
            font-weight: 600;
            color: #111827;
        }

        .helper-text,
        p.text-xs,
        p.text-gray-600 {
            color: var(--text-muted);
        }

        /* 選擇框：統一邊框與 Focus 效果 */
        select,
        input[type="number"],
        input[type="text"] {
            border-radius: 0.55rem;
        }

        select:focus,
        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 1px rgba(0, 123, 255, 0.18);
        }

        /* Modal 調整：與主視覺更一致 */
        .modal-content {
            border-radius: 1.25rem;
            border: 1px solid rgba(37, 99, 235, 0.16);
        }

        .modal-header {
            color: #1F2937;
        }

        .modal-result {
            background: linear-gradient(135deg, #E7F1FF 0%, #F9FBFF 100%);
            border-left-color: var(--primary);
        }

        .modal-prob-value {
            color: #16A34A;
        }

        /* 自適應：小螢幕行高 & 間距 */
        @media (max-width: 768px) {
            body {
                font-size: 0.95rem;
                line-height: 1.7;
            }

            h1 {
                font-size: 1.6rem;
            }

            .card {
                padding: 1.25rem;
            }
        }


        /* 分析模組 Group Header */
        .analysis-group-header {
            background: linear-gradient(90deg, #E7F1FF 0%, #F8F9FA 55%, #FFFFFF 100%);
            border-radius: 0.9rem;
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.85rem;
        }

        .analysis-group-header-title {
            font-size: 0.78rem;
            font-weight: 700;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: #64748B;
        }

        .analysis-group-header-subtitle {
            font-size: 0.8rem;
            color: #6B7280;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
</head>

<body class="text-gray-800">

    <div class="bg-gradient-to-b from-slate-50 to-white border-b border-slate-200 mb-6">
        <div class="max-w-7xl mx-auto px-4 py-6 md:py-8">
            <div class="flex flex-col md:flex-row items-center md:items-start justify-between gap-6">

                <!-- Left: Title & Description -->
                <div class="text-center md:text-left flex-1">
                    <div class="flex items-center justify-center md:justify-start gap-3 mb-2">
                        <div class="bg-blue-600 text-white p-2 rounded-lg shadow-md hidden md:block">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z">
                                </path>
                            </svg>
                        </div>
                        <h1 class="text-2xl md:text-4xl font-extrabold text-slate-800 tracking-tight">
                            數據分析<span class="text-blue-600">與</span>機器學習輔助
                        </h1>
                    </div>
                    <p class="text-sm md:text-base text-slate-600 max-w-2xl mx-auto md:mx-0 leading-relaxed">
                        上傳檔案或貼上資料，探索數據、驗證假設並建立預測模型
                    </p>
                </div>

                <!-- Right: Profile Card (Horizontal Layout) -->
                <div
                    class="flex items-center gap-4 bg-white p-3 pr-6 rounded-full shadow-sm border border-slate-100 flex-shrink-0">
                    <img src="Cliff Baby Pic by GPT.jpg" alt="Cliff Wang"
                        class="w-14 h-14 md:w-16 md:h-16 rounded-full shadow-md object-cover ring-2 ring-white" />
                    <div class="text-left">
                        <p class="text-sm md:text-base font-bold text-slate-800 leading-tight">Cliff Wang, Ph.D.</p>
                        <p class="text-xs text-slate-500 font-medium mb-0.5">王啟岳博士</p>
                        <p class="text-[11px] text-blue-600 font-mono">dr.cliffwang@a2psdm.com</p>
                    </div>
                </div>

            </div>
        </div>
    </div>


    <div class="container mx-auto p-4 md:p-8">


        <div class="card">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-semibold flex items-center gap-2">
                    <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                        </path>
                    </svg>
                    上傳資料
                </h2>
                <button id="loadExampleBtn" type="button"
                    class="bg-blue-50 hover:bg-blue-100 text-blue-600 px-4 py-2 rounded-lg font-medium shadow-sm transition-all flex items-center gap-2 text-sm border border-blue-200">
                    <svg class="w-4 h-4 text-yellow-500" fill="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                    </svg>
                    載入範例資料
                </button>
            </div>

            <!-- Input Mode Toggle -->
            <div class="mb-6">
                <div class="inline-flex bg-gray-100 p-1 rounded-lg">
                    <button id="inputModeFileBtn" type="button"
                        class="px-4 py-2 rounded-md text-sm font-medium transition-all shadow-sm bg-white text-blue-600">
                        Excel 檔案上傳
                    </button>
                    <button id="inputModePasteBtn" type="button"
                        class="px-4 py-2 rounded-md text-sm font-medium text-gray-500 hover:text-gray-700 transition-all">
                        Copy & Paste (貼上表格)
                    </button>
                </div>
                <p class="mt-2 text-sm text-gray-500">
                    支援 .xlsx, .xls, .csv 格式，或直接從 Excel 複製貼上。
                </p>
            </div>

            <!-- Excel File Upload Area -->
            <div id="excelInputArea" class="transition-all duration-300">
                <div
                    class="border-2 border-dashed border-blue-200 rounded-xl p-8 text-center hover:border-blue-400 transition-colors bg-blue-50/30 relative">
                    <input type="file" id="fileInput" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                        aria-label="選擇檔案" />
                    <div class="pointer-events-none">
                        <div
                            class="w-12 h-12 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center mx-auto mb-3">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 4v16m8-8H4"></path>
                            </svg>
                        </div>
                        <p class="text-lg font-medium text-gray-700 mb-1">點擊或拖放檔案至此</p>
                        <p id="chosenFileName" class="text-sm text-gray-500">尚未選擇檔案</p>
                    </div>
                </div>

                <div class="mt-4 flex justify-end">
                    <button id="loadDataBtn"
                        class="bg-blue-600 text-white px-6 py-2.5 rounded-lg font-medium shadow-md hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-all flex items-center gap-2"
                        disabled>
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>
                        </svg>
                        載入資料
                    </button>
                </div>
            </div>

            <script>
                (function () {
                    const fileInput = document.getElementById('fileInput');
                    const chosen = document.getElementById('chosenFileName');
                    const loadBtn = document.getElementById('loadDataBtn');
                    const inputModeFileBtn = document.getElementById('inputModeFileBtn');
                    const inputModePasteBtn = document.getElementById('inputModePasteBtn');

                    function updateUI() {
                        if (!fileInput || !chosen || !loadBtn) return;
                        const files = fileInput.files;
                        if (files && files.length > 0) {
                            chosen.textContent = files.length === 1 ? files[0].name : `${files.length} 個檔案`;
                            chosen.classList.add('text-blue-600', 'font-medium');
                            loadBtn.disabled = false;
                        } else {
                            chosen.textContent = '尚未選擇檔案';
                            chosen.classList.remove('text-blue-600', 'font-medium');
                            loadBtn.disabled = true;
                        }
                    }

                    fileInput.addEventListener('change', updateUI);

                    // Toggle Button Logic (Visual only, functional logic handled by main script)
                    inputModeFileBtn.addEventListener('click', () => {
                        inputModeFileBtn.classList.add('bg-white', 'text-blue-600', 'shadow-sm');
                        inputModeFileBtn.classList.remove('text-gray-500');
                        inputModePasteBtn.classList.remove('bg-white', 'text-blue-600', 'shadow-sm');
                        inputModePasteBtn.classList.add('text-gray-500');
                    });

                    inputModePasteBtn.addEventListener('click', () => {
                        inputModePasteBtn.classList.add('bg-white', 'text-blue-600', 'shadow-sm');
                        inputModePasteBtn.classList.remove('text-gray-500');
                        inputModeFileBtn.classList.remove('bg-white', 'text-blue-600', 'shadow-sm');
                        inputModeFileBtn.classList.add('text-gray-500');
                    });
                })();
            </script>

            <!-- Copy & Paste Input Area -->
            <div id="pasteInputArea" class="mt-4 hidden">
                <div class="bg-gray-50 p-4 rounded-xl border border-gray-200">
                    <label for="pasteTextarea" class="block text-sm font-medium text-gray-700 mb-2">
                        從 Excel 貼上資料（第一列需為欄位名稱）
                    </label>
                    <textarea id="pasteTextarea" rows="8"
                        class="w-full rounded-lg border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm font-mono"
                        placeholder="範例：&#10;日期	銷售量&#10;2024-01-01	120&#10;2024-01-02	98"></textarea>

                    <div class="mt-4 flex flex-col sm:flex-row justify-between items-center gap-4">
                        <div
                            class="flex items-center gap-4 text-sm text-gray-600 bg-white px-3 py-2 rounded-lg border border-gray-200">
                            <span class="font-medium">分隔符號：</span>
                            <label class="inline-flex items-center gap-1 cursor-pointer">
                                <input type="radio" name="pasteDelimiter" value="auto"
                                    class="text-blue-600 focus:ring-blue-500" checked>
                                <span>自動</span>
                            </label>
                            <label class="inline-flex items-center gap-1 cursor-pointer">
                                <input type="radio" name="pasteDelimiter" value="tab"
                                    class="text-blue-600 focus:ring-blue-500">
                                <span>Tab</span>
                            </label>
                            <label class="inline-flex items-center gap-1 cursor-pointer">
                                <input type="radio" name="pasteDelimiter" value="comma"
                                    class="text-blue-600 focus:ring-blue-500">
                                <span>逗號</span>
                            </label>
                        </div>
                        <button id="pasteLoadBtn" type="button"
                            class="bg-emerald-600 text-white px-6 py-2.5 rounded-lg font-medium shadow-md hover:bg-emerald-700 transition-all flex items-center gap-2 w-full sm:w-auto justify-center">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01">
                                </path>
                            </svg>
                            匯入貼上資料
                        </button>
                    </div>
                </div>
            </div>

            <!-- Worksheet Selector -->
            <div id="sheetSelectorContainer" class="mt-6 hidden animate-fade-in">
                <div
                    class="bg-blue-50 border border-blue-100 rounded-xl p-4 flex flex-col md:flex-row items-center gap-4">
                    <div class="flex-1 w-full">
                        <label for="sheetSelector" class="block text-sm font-medium text-blue-800 mb-1">
                            選擇工作表 (Worksheet)
                        </label>
                        <select id="sheetSelector"
                            class="w-full border-blue-200 rounded-lg shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-white py-2"></select>
                    </div>
                    <button id="confirmSheetBtn"
                        class="bg-blue-600 text-white px-6 py-2.5 rounded-lg font-medium shadow hover:bg-blue-700 transition-all whitespace-nowrap mt-auto w-full md:w-auto">
                        確認匯入
                    </button>
                </div>
            </div>

            <div id="loadingIndicator" class="hidden loader"></div>
        </div>



        <main id="mainContent" class="hidden">
            <div class="card">
                <h2 class="text-xl font-semibold mb-4 flex items-center gap-2">
                    <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                        </path>
                    </svg>
                    資料預覽
                </h2>
                <div id="dataPreview" class="overflow-x-auto max-h-80"></div>
            </div>

            <div class="card">
                <h2 class="text-xl font-semibold mb-4 flex items-center gap-2">
                    <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4">
                        </path>
                    </svg>
                    選擇分析方法
                </h2>
                <div class="border-b border-gray-200">
                    <nav class="-mb-px flex flex-wrap gap-4" aria-label="Tabs">
                        <button
                            class="tab-button active font-medium text-lg flex items-center gap-2 px-4 py-3 rounded-t-lg"
                            data-tab="eda">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                            </svg>
                            資料探索
                        </button>
                        <button class="tab-button font-medium text-lg flex items-center gap-2 px-4 py-3 rounded-t-lg"
                            data-tab="basic">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z">
                                </path>
                            </svg>
                            基本分析
                        </button>
                        <button class="tab-button font-medium text-lg flex items-center gap-2 px-4 py-3 rounded-t-lg"
                            data-tab="forecast">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            時間序列
                        </button>
                        <button class="tab-button font-medium text-lg flex items-center gap-2 px-4 py-3 rounded-t-lg"
                            data-tab="ml">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M19.428 15.428a2 2 0 00-1.022-.547l-2.384-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z">
                                </path>
                            </svg>
                            機器學習
                        </button>
                    </nav>
                </div>

                <div id="analysisContent" class="mt-6">
                    <!-- EDA -->
                    <div id="edaContent" class="tab-content">
                        <div id="edaResults"></div>
                    </div>
                    <!-- Basic Analysis (Grouped) -->
                    <div id="basicContent" class="tab-content hidden">
                        <div class="border-b border-gray-200 mb-4">
                            <nav class="flex flex-wrap gap-2" aria-label="BasicTabs">
                                <button class="basic-tab-button active font-medium"
                                    data-basic-tab="outlier">異常偵測</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="pareto">柏拉圖分析</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="testing">假設檢定</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="chiSquare">卡方檢定 χ²</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="regression">迴歸分析</button>
                                <button class="basic-tab-button font-medium"
                                    data-basic-tab="correlationMatrix">相關係數矩陣</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="wordcloud">文字雲</button>
                            </nav>
                        </div>

                        <div id="outlierContent" class="basic-tab-content mt-4">
                            <p class="text-gray-600 mb-4">異常偵測 (Outlier Detection)：用來找出資料中的離群值，常用於品質監控、異常交易偵測與資料清洗。</p>
                            <div class="space-y-4">
                                <div>
                                    <label for="outlierVariable"
                                        class="block text-sm font-medium text-gray-700">選擇要檢測的數值變數</label>
                                    <select id="outlierVariable"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div class="bg-gray-50 p-4 rounded-lg">
                                    <h4 class="font-semibold mb-3">選擇偵測方法</h4>
                                    <div class="space-y-2">
                                        <label class="flex items-center">
                                            <input type="checkbox" id="outlierIQR" checked
                                                class="rounded border-gray-300 text-red-600 mr-2">
                                            <span class="text-sm">
                                                <strong>IQR 法 (四分位數法)</strong> - 適用於任何分布，最常用
                                                <span class="text-xs text-gray-500 block ml-6">偵測範圍: Q1 - 1.5×IQR ~ Q3 +
                                                    1.5×IQR</span>
                                            </span>
                                        </label>
                                        <label class="flex items-center">
                                            <input type="checkbox" id="outlierZScore" checked
                                                class="rounded border-gray-300 text-blue-600 mr-2">
                                            <span class="text-sm">
                                                <strong>Z-Score 法 (標準分數法)</strong> - 適用於常態分布
                                                <span class="text-xs text-gray-500 block ml-6">偵測範圍: |Z-Score| > 3 (或
                                                    2.5)</span>
                                            </span>
                                        </label>
                                        <label class="flex items-center">
                                            <input type="checkbox" id="outlierModifiedZ" checked
                                                class="rounded border-gray-300 text-green-600 mr-2">
                                            <span class="text-sm">
                                                <strong>Modified Z-Score 法</strong> - 使用中位數，更穩健
                                                <span class="text-xs text-gray-500 block ml-6">偵測範圍: |Modified Z| >
                                                    3.5</span>
                                            </span>
                                        </label>
                                    </div>
                                </div>

                                <div class="grid md:grid-cols-2 gap-4">
                                    <div>
                                        <label for="outlierZThreshold"
                                            class="block text-sm font-medium text-gray-700">Z-Score 閾值</label>
                                        <input type="number" id="outlierZThreshold" value="3" step="0.5" min="1" max="5"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">預設 3 (嚴格), 2.5 (寬鬆)</p>
                                    </div>
                                    <div>
                                        <label for="outlierIQRMultiplier"
                                            class="block text-sm font-medium text-gray-700">IQR 倍數</label>
                                        <input type="number" id="outlierIQRMultiplier" value="1.5" step="0.5" min="1"
                                            max="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">預設 1.5 (標準), 3 (極端)</p>
                                    </div>
                                </div>
                                <button id="runOutlierBtn"
                                    class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700">執行異常偵測</button>
                            </div>
                            <div id="outlierResults" class="mt-6"></div>
                        </div>
                        <div id="paretoContent" class="basic-tab-content hidden">
                            <p class="text-gray-600 mb-4">找出造成問題的關鍵原因 (80/20法則)。</p>
                            <div class="grid md:grid-cols-3 gap-4 items-end">
                                <div><label for="paretoCategoryVar"
                                        class="block text-sm font-medium text-gray-700">選擇類別欄位 (X)</label><select
                                        id="paretoCategoryVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select></div>
                                <div><label for="paretoValueVar" class="block text-sm font-medium text-gray-700">選擇數值欄位
                                        (Y)</label><select id="paretoValueVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select></div>
                                <button id="runParetoBtn"
                                    class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700">產生柏拉圖</button>
                            </div>
                            <div id="paretoResults" class="mt-6"></div>
                        </div>
                        <div id="testingContent" class="basic-tab-content hidden">
                            <p class="text-gray-600 mb-4">比較不同組別之間，數值資料的平均值是否存在顯著差異。</p>
                            <div class="grid md:grid-cols-3 gap-4 items-end">
                                <div><label for="tTestCategoricalVar"
                                        class="block text-sm font-medium text-gray-700">選擇分組變數 (X)</label><select
                                        id="tTestCategoricalVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select></div>
                                <div><label for="tTestNumericalVar"
                                        class="block text-sm font-medium text-gray-700">選擇數值變數 (Y)</label><select
                                        id="tTestNumericalVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select></div>
                                <button id="runTTestBtn"
                                    class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700">執行
                                    T 檢定</button>
                            </div>
                            <div id="tTestResults" class="mt-6"></div>
                        </div>
                        <div id="chiSquareContent" class="basic-tab-content hidden mt-4">
                            <p class="text-gray-600 mb-4">卡方檢定(Chi-Square Test)：檢定兩個類別變數之間是否存在顯著關聯性。適用於問卷調查、市場研究等情境。</p>
                            <div class="bg-blue-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-blue-900 mb-2">📊 使用情境</h4>
                                <ul class="text-sm text-blue-800 space-y-1">
                                    <li>• 性別與產品偏好是否相關？</li>
                                    <li>• 教育程度與職業類型是否獨立？</li>
                                    <li>• 地區與購買行為是否有關聯？</li>
                                </ul>
                            </div>
                            <div class="grid md:grid-cols-2 gap-x-8 gap-y-4">
                                <div>
                                    <label for="chiSquareVar1"
                                        class="block text-sm font-medium text-gray-700">選擇第一個類別變數</label>
                                    <select id="chiSquareVar1"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="chiSquareVar2"
                                        class="block text-sm font-medium text-gray-700">選擇第二個類別變數</label>
                                    <select id="chiSquareVar2"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                            </div>
                            <div class="mt-4">
                                <button id="runChiSquareBtn"
                                    class="bg-orange-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-700">執行卡方檢定</button>
                            </div>
                            <div id="chiSquareResults" class="mt-6"></div>
                        </div>
                        <div id="regressionContent" class="basic-tab-content hidden">
                            <!-- Regression Type Tabs -->
                            <div class="flex space-x-2 mb-4 border-b border-gray-300">
                                <button id="simpleRegTab" onclick="switchRegressionType('simple')"
                                    class="px-4 py-2 font-semibold border-b-2 border-purple-500 text-purple-600">簡單迴歸
                                    Simple</button>
                                <button id="multipleRegTab" onclick="switchRegressionType('multiple')"
                                    class="px-4 py-2 font-semibold text-gray-500 hover:text-purple-600">多元迴歸
                                    Multiple</button>
                            </div>

                            <!-- Simple Regression -->
                            <div id="simpleRegressionPanel">
                                <p class="text-gray-600 mb-4">探討兩個數值變數之間的關聯性，包含完整統計推論。</p>
                                <div class="grid md:grid-cols-3 gap-4 items-end">
                                    <div><label for="regressionX" class="block text-sm font-medium text-gray-700">選擇自變數
                                            (X)</label><select id="regressionX"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    </div>
                                    <div><label for="regressionY" class="block text-sm font-medium text-gray-700">選擇應變數
                                            (Y)</label><select id="regressionY"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    </div>
                                    <button id="runRegressionBtn"
                                        class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700">執行簡單迴歸</button>
                                </div>
                            </div>

                            <!-- Multiple Regression -->
                            <div id="multipleRegressionPanel" style="display:none;">
                                <p class="text-gray-600 mb-4">探討多個自變數對應變數的影響，適合實務應用。</p>
                                <div class="grid md:grid-cols-3 gap-4 items-end">
                                    <div><label for="multipleRegressionX"
                                            class="block text-sm font-medium text-gray-700">選擇自變數 (X) -
                                            可多選</label><select id="multipleRegressionX" multiple
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                            style="height:120px;"></select>
                                        <p class="text-xs text-gray-500 mt-1">💡 按住 Ctrl (Win) 或 Cmd (Mac) 選擇多個</p>
                                    </div>
                                    <div><label for="multipleRegressionY"
                                            class="block text-sm font-medium text-gray-700">選擇應變數 (Y)</label><select
                                            id="multipleRegressionY"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    </div>
                                    <button id="runMultipleRegressionBtn"
                                        class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700">執行多元迴歸</button>
                                </div>

                            </div>

                            <div id="regressionResults" class="mt-6"></div>
                        </div>
                        <div id="correlationMatrixContent" class="basic-tab-content hidden mt-4">
                            <p class="text-gray-600 mb-4">視覺化所有數值變數之間的相關性，快速找出高度正相關或負相關的變數配對。</p>
                            <div class="mt-4">
                                <button id="runCorrelationMatrixBtn"
                                    class="bg-teal-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-700">產生相關係數熱圖</button>
                            </div>
                            <div id="correlationMatrixResults" class="mt-6"></div>
                        </div>

                        <div id="wordcloudContent" class="basic-tab-content hidden mt-4">
                            <p class="text-gray-600 mb-4">
                                文字雲 (Wordcloud)：用於快速觀察文字欄位中常出現的關鍵字與主題。
                            </p>
                            <div class="space-y-4">
                                <div>
                                    <label for="wordcloudTextColumn" class="block text-sm font-medium text-gray-700">
                                        選擇文字欄位
                                    </label>
                                    <select id="wordcloudTextColumn"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    <p class="text-xs text-gray-500 mt-1">
                                        建議選擇備註、客服紀錄、意見欄位等文字型欄位。
                                    </p>
                                </div>

                                <div class="flex flex-wrap items-center gap-4">
                                    <div>
                                        <label for="wordcloudMinFreq" class="block text-sm font-medium text-gray-700">
                                            最小出現次數
                                        </label>
                                        <input type="number" id="wordcloudMinFreq"
                                            class="mt-1 w-28 rounded-md border-gray-300 shadow-sm" value="3" min="1">
                                    </div>
                                    <div>
                                        <label for="wordcloudMaxWords" class="block text-sm font-medium text-gray-700">
                                            最多顯示字詞數
                                        </label>
                                        <input type="number" id="wordcloudMaxWords"
                                            class="mt-1 w-28 rounded-md border-gray-300 shadow-sm" value="60" min="10">
                                    </div>
                                </div>

                                <div>
                                    <button id="runWordcloudBtn"
                                        class="bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-700">
                                        產生文字雲
                                    </button>
                                </div>

                                <div class="flex justify-between items-center mb-4">
                                    <h3 class="text-lg font-semibold">文字雲結果</h3>
                                    <button id="downloadWordcloudBtn"
                                        class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 disabled:opacity-50"
                                        disabled>
                                        下載文字雲 (PNG)
                                    </button>
                                </div>
                                <div id="wordcloudContainer"
                                    class="border rounded-full mx-auto bg-white overflow-hidden min-h-[260px] max-w-xl aspect-square">
                                </div>
                            </div>
                        </div>

                    </div>



                    <div id="forecastContent" class="tab-content hidden">
                        <div class="border-b border-gray-200 mb-4">
                            <nav class="flex flex-wrap gap-2" aria-label="ForecastTabs">
                                <button class="forecast-tab-button active font-medium" data-forecast-tab="holtForecast">
                                    Holt-Winters
                                </button>
                                <button class="forecast-tab-button font-medium" data-forecast-tab="prophetForecast">
                                    趨勢 + 季節分解
                                </button>
                                <button class="forecast-tab-button font-medium" data-forecast-tab="arimaForecast">
                                    ARIMA
                                </button>
                                <button class="forecast-tab-button font-medium" data-forecast-tab="crostonForecast">
                                    Croston 間歇需求
                                </button>
                            </nav>
                        </div>

                        <!-- Holt-Winters 子功能：完整保留原本 UI 與邏輯 -->
                        <div id="holtForecastContent" class="forecast-tab-content">
                            <p class="text-gray-600 mb-4">使用 Holt-Winters 方法進行時間序列預測。</p>
                            <div class="grid md:grid-cols-2 lg:grid-cols-4 gap-4 items-end">
                                <div>
                                    <label for="forecastTimeVar" class="block text-sm font-medium text-gray-700">選擇時間欄位
                                        (X)</label>
                                    <select id="forecastTimeVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="forecastValueVar" class="block text-sm font-medium text-gray-700">選擇數值欄位
                                        (Y)</label>
                                    <select id="forecastValueVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="forecastPeriod" class="block text-sm font-medium text-gray-700">季節長度
                                        (Period)</label>
                                    <input type="number" id="forecastPeriod" value="12"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                </div>
                                <div>
                                    <label for="forecastSteps"
                                        class="block text-sm font-medium text-gray-700">預測期數</label>
                                    <input type="number" id="forecastSteps" value="12"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                </div>
                            </div>
                            <details class="mt-4">
                                <summary class="cursor-pointer text-sm font-medium text-blue-600">進階選項</summary>
                                <div class="grid md:grid-cols-3 gap-4 mt-2 p-4 bg-gray-50 rounded-md">
                                    <div>
                                        <label for="forecastAlpha"
                                            class="block text-sm font-medium text-gray-700">Alpha</label>
                                        <input type="number" id="forecastAlpha" value="0.5" step="0.1" min="0" max="1"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    </div>
                                    <div>
                                        <label for="forecastBeta"
                                            class="block text-sm font-medium text-gray-700">Beta</label>
                                        <input type="number" id="forecastBeta" value="0.5" step="0.1" min="0" max="1"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    </div>
                                    <div>
                                        <label for="forecastGamma"
                                            class="block text-sm font-medium text-gray-700">Gamma</label>
                                        <input type="number" id="forecastGamma" value="0.5" step="0.1" min="0" max="1"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    </div>
                                </div>
                            </details>
                            <div class="mt-4">
                                <button id="runForecastBtn"
                                    class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-700">
                                    執行預測
                                </button>
                            </div>
                            <div id="forecastResults" class="mt-6"></div>
                        </div>

                        <!-- 趨勢 + 季節分解 子功能（原 Prophet 風格） -->
                        <div id="prophetForecastContent" class="forecast-tab-content hidden">
                            <p class="text-gray-600 mb-4">
                                使用「趨勢 + 季節分解」模型（Decomposition Forecast, Trend + Seasonality）進行時間序列預測，適合具有明顯趨勢與季節性的資料。
                            </p>
                            <div class="grid md:grid-cols-2 lg:grid-cols-4 gap-4 items-end">
                                <div>
                                    <label for="prophetTimeVar" class="block text-sm font-medium text-gray-700">選擇時間欄位
                                        (X)</label>
                                    <select id="prophetTimeVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="prophetValueVar" class="block text-sm font-medium text-gray-700">選擇數值欄位
                                        (Y)</label>
                                    <select id="prophetValueVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="prophetPeriod" class="block text-sm font-medium text-gray-700">季節長度
                                        (Period)</label>
                                    <input type="number" id="prophetPeriod" value="12"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="text-xs text-gray-500 mt-1">
                                        例如：月資料多為 12、週資料可設 52。
                                    </p>
                                </div>
                                <div>
                                    <label for="prophetSteps"
                                        class="block text-sm font-medium text-gray-700">預測期數</label>
                                    <input type="number" id="prophetSteps" value="12"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                </div>
                            </div>

                            <div class="mt-4">
                                <button id="runProphetBtn"
                                    class="bg-amber-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-amber-700">
                                    執行趨勢 + 季節分解預測
                                </button>
                            </div>

                            <div id="prophetResults" class="mt-6"></div>
                        </div>

                        <!-- ARIMA 子功能 -->
                        <div id="arimaForecastContent" class="forecast-tab-content hidden">
                            <p class="text-gray-600 mb-4">
                                使用 ARIMA 模型（差分 + 自迴歸 AR + 移動平均 MA）進行時間序列預測，適合平穩或經差分後平穩的資料。
                                本工具實作 ARIMA(p, d, q)，在純 JavaScript 環境中，採用 Hannan–Rissanen 兩階段迴歸法，以 OLS 估計 AR (φ) 與 MA
                                (θ) 係數。
                            </p>
                            <div class="grid md:grid-cols-2 lg:grid-cols-4 gap-4 items-end">
                                <div>
                                    <label for="arimaTimeVar" class="block text-sm font-medium text-gray-700">選擇時間欄位
                                        (X)</label>
                                    <select id="arimaTimeVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="arimaValueVar" class="block text-sm font-medium text-gray-700">選擇數值欄位
                                        (Y)</label>
                                    <select id="arimaValueVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="arimaP" class="block text-sm font-medium text-gray-700">自迴歸階數 p</label>
                                    <input type="number" id="arimaP" value="1" min="0" max="5"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="text-xs text-gray-500 mt-1">
                                        建議先從 p = 1 或 2 開始。
                                    </p>
                                </div>
                                <div>
                                    <label for="arimaD" class="block text-sm font-medium text-gray-700">差分階數 d</label>
                                    <input type="number" id="arimaD" value="0" min="0" max="1"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="text-xs text-gray-500 mt-1">
                                        d = 0 表示直接建模原始序列；d = 1 表示一階差分後再建模。
                                    </p>
                                </div>
                            </div>
                            <div class="grid md:grid-cols-2 lg:grid-cols-4 gap-4 items-end mt-4">
                                <div>
                                    <label for="arimaQ" class="block text-sm font-medium text-gray-700">移動平均階數 q</label>
                                    <input type="number" id="arimaQ" value="0" min="0" max="5"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="text-xs text-gray-500 mt-1">
                                        q = 0 退化為純 AR(p)；q &gt; 0 會同時估計 MA(θ) 係數。
                                    </p>
                                </div>
                                <div>
                                    <label for="arimaSteps" class="block text-sm font-medium text-gray-700">預測期數</label>
                                    <input type="number" id="arimaSteps" value="12" min="1"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                </div>
                            </div>
                            <div class="mt-4">
                                <button id="runArimaBtn"
                                    class="bg-orange-700 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-800">
                                    執行 ARIMA 預測
                                </button>
                            </div>
                            <div id="arimaResults" class="mt-6"></div>
                        </div>

                        <!-- Croston 子功能 -->
                        <!-- Croston 子功能 -->
                        <div id="crostonForecastContent" class="forecast-tab-content hidden">
                            <p class="text-gray-600 mb-4">
                                使用 Croston 方法處理間歇性需求（多為 0，偶爾出現正需求），適合備品、慢料等需求預測教學。
                                Croston 模型對未來各期提供相同的預測水準。
                            </p>
                            <div class="grid md:grid-cols-2 lg:grid-cols-4 gap-4 items-end">

                                <div>
                                    <label for="crostonTimeVar" class="block text-sm font-medium text-gray-700">選擇時間欄位
                                        (X)</label>
                                    <select id="crostonTimeVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="crostonValueVar" class="block text-sm font-medium text-gray-700">選擇需求量欄位
                                        (Y)</label>
                                    <select id="crostonValueVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="crostonAlpha" class="block text-sm font-medium text-gray-700">平滑係數
                                        α（需求大小）</label>
                                    <input type="number" id="crostonAlpha" value="0.3" step="0.05" min="0.01" max="1"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="text-xs text-gray-500 mt-1">
                                        控制「每次需求大小」的平滑速度，α 越大，對最新需求反應越敏感；建議 0.1～0.3 作為起點。
                                    </p>
                                </div>
                                <div>
                                    <label for="crostonBeta" class="block text-sm font-medium text-gray-700">平滑係數
                                        β（需求間隔）</label>
                                    <input type="number" id="crostonBeta" value="0.3" step="0.05" min="0.01" max="1"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="text-xs text-gray-500 mt-1">
                                        控制「需求到達間隔」的平滑速度；建議與 α 相近作為起點。
                                    </p>
                                </div>
                                <div>
                                    <label for="crostonSteps"
                                        class="block text-sm font-medium text-gray-700">預測期數</label>
                                    <input type="number" id="crostonSteps" value="12" min="1"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                </div>
                            </div>

                            <div class="mt-4">
                                <button id="runCrostonBtn"
                                    class="bg-lime-700 text-white font-bold py-2 px-4 rounded-lg hover:bg-lime-800">
                                    執行 Croston 預測
                                </button>
                            </div>
                            <div id="crostonResults" class="mt-6"></div>
                        </div>
                    </div>
                    <!-- Machine Learning -->
                    <div id="mlContent" class="tab-content hidden">
                        <div class="border-b border-gray-200">
                            <nav class="flex flex-wrap gap-2" aria-label="MLTabs">
                                <button class="ml-tab-button active font-medium" data-ml-tab="logistic">邏輯斯迴歸</button>
                                <button class="ml-tab-button font-medium" data-ml-tab="decisionTree">決策樹</button>
                                <button class="ml-tab-button font-medium" data-ml-tab="pca">主成分分析 PCA</button>
                                <button class="ml-tab-button font-medium" data-ml-tab="factorAnalysis">因素分析 FA</button>
                                <button class="ml-tab-button font-medium" data-ml-tab="kmeans">K-Means 集群</button>
                                <button class="ml-tab-button font-medium" data-ml-tab="hierarchical">階層式集群</button>
                                <button class="ml-tab-button font-medium" data-ml-tab="apriori">關聯規則 Apriori</button>
                                <button class="ml-tab-button font-medium" data-ml-tab="randomForest">隨機森林 RF</button>
                                <button class="ml-tab-button font-medium" data-ml-tab="neuralNetwork">神經網絡</button>
                            </nav>
                        </div>
                        <!-- Logistic Regression Content -->
                        <div id="logisticContent" class="ml-tab-content mt-4">
                            <p class="text-gray-600 mb-4">建立模型以預測二元結果 (例如：是/否、成功/失敗)。</p>
                            <div class="grid md:grid-cols-2 gap-x-8 gap-y-4 items-start">
                                <div>
                                    <label for="logisticY" class="block text-sm font-medium text-gray-700">選擇應變數 (Y,
                                        二元類別)</label>
                                    <select id="logisticY"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    <p class="mt-2 text-xs text-gray-500">此選單只會顯示資料中剛好有兩種值的類別欄位。</p>
                                </div>
                                <div>
                                    <label for="logisticX" class="block text-sm font-medium text-gray-700">選擇自變數 (X,
                                        數值)</label>
                                    <select id="logisticX" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm h-32"></select>
                                    <p class="mt-2 text-xs text-gray-500">按住 Ctrl (或 Mac 上的 Command) 可複選。</p>
                                </div>
                            </div>
                            <div class="mt-4"><button id="runLogisticBtn"
                                    class="bg-rose-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-rose-700">執行邏輯斯迴歸</button>
                            </div>
                            <div id="logisticResults" class="mt-6"></div>
                        </div>
                        <!-- Decision Tree Content -->
                        <div id="decisionTreeContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">建立迴歸決策樹模型，預測數值結果並找出關鍵因子。</p>
                            <div class="grid md:grid-cols-2 gap-x-8 gap-y-4 items-start">
                                <div>
                                    <label for="dtY" class="block text-sm font-medium text-gray-700">選擇應變數 (Y,
                                        數值)</label>
                                    <select id="dtY"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="dtX" class="block text-sm font-medium text-gray-700">選擇自變數 (X)</label>
                                    <select id="dtX" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm h-32"></select>
                                </div>
                                <div>
                                    <label for="dtMaxDepth" class="block text-sm font-medium text-gray-700">最大深度</label>
                                    <input type="number" id="dtMaxDepth" value="5"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                </div>
                                <div>
                                    <label for="dtMinSamplesLeaf"
                                        class="block text-sm font-medium text-gray-700">最小葉節點樣本數</label>
                                    <input type="number" id="dtMinSamplesLeaf" value="5"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                </div>
                            </div>
                            <div class="mt-4"><button id="runDtBtn"
                                    class="bg-amber-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-amber-700">建立決策樹</button>
                            </div>
                            <div id="dtResults" class="mt-6"></div>
                        </div>
                        <!-- PCA Content -->
                        <div id="pcaContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">主成分分析：降維、特徵提取、變數縮減，找出解釋最多變異的主要成分。</p>
                            <div class="space-y-4">
                                <div>
                                    <label for="pcaVariables"
                                        class="block text-sm font-medium text-gray-700">選擇變數（可多選）</label>
                                    <select id="pcaVariables" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                        style="height:120px;"></select>
                                    <p class="text-xs text-gray-500 mt-1">💡 按住 Ctrl (Win) 或 Cmd (Mac) 選擇多個變數</p>
                                </div>
                                <div>
                                    <label for="pcaNumComponents"
                                        class="block text-sm font-medium text-gray-700">主成分數量（留空則自動）</label>
                                    <input type="number" id="pcaNumComponents" min="1"
                                        class="mt-1 block w-48 rounded-md border-gray-300 shadow-sm"
                                        placeholder="自動選擇（特徵值>1）">
                                </div>
                                <div class="flex items-center">
                                    <input type="checkbox" id="pcaStandardize" checked
                                        class="rounded border-gray-300 text-indigo-600 mr-2">
                                    <label for="pcaStandardize" class="text-sm text-gray-700">標準化變數（建議）</label>
                                </div>
                                <button id="runPcaBtn"
                                    class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700">執行
                                    PCA 分析</button>
                            </div>
                            <div id="pcaResults" class="mt-6"></div>
                        </div>
                        <!-- Factor Analysis Content -->
                        <div id="factorAnalysisContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">因素分析：找出潛在因子，解釋變數間的共同變異，適合量表編製和結構探索。</p>
                            <div class="space-y-4">
                                <div>
                                    <label for="faVariables"
                                        class="block text-sm font-medium text-gray-700">選擇變數（可多選）</label>
                                    <select id="faVariables" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                        style="height:120px;"></select>
                                    <p class="text-xs text-gray-500 mt-1">💡 按住 Ctrl (Win) 或 Cmd (Mac) 選擇多個變數</p>
                                </div>
                                <div>
                                    <label for="faNumFactors"
                                        class="block text-sm font-medium text-gray-700">因子數量（留空則自動）</label>
                                    <input type="number" id="faNumFactors" min="1"
                                        class="mt-1 block w-48 rounded-md border-gray-300 shadow-sm"
                                        placeholder="自動選擇（特徵值>1）">
                                </div>
                                <div class="flex items-center">
                                    <input type="checkbox" id="faRotation" checked
                                        class="rounded border-gray-300 text-pink-600 mr-2">
                                    <label for="faRotation" class="text-sm text-gray-700">Varimax 旋轉（建議）</label>
                                </div>
                                <button id="runFaBtn"
                                    class="bg-pink-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-pink-700">執行因素分析</button>
                            </div>
                            <div id="faResults" class="mt-6"></div>
                        </div>
                        <!-- K-Means Clustering Content -->
                        <div id="kmeansContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">K-Means 集群分析：將資料點依相似性分成 K 個群組,適用於客戶分群、市場區隔、異常偵測等應用。</p>
                            <div class="bg-green-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-green-900 mb-2">🎯 應用場景</h4>
                                <ul class="text-sm text-green-800 space-y-1">
                                    <li>• 客戶分群(RFM分析)</li>
                                    <li>• 產品定位與市場區隔</li>
                                    <li>• 庫存管理優化</li>
                                    <li>• 異常值偵測</li>
                                </ul>
                            </div>
                            <div class="space-y-4">
                                <div>
                                    <label for="kmeansVariables"
                                        class="block text-sm font-medium text-gray-700">選擇數值變數（可多選，建議2-5個）</label>
                                    <select id="kmeansVariables" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                        style="height:120px;"></select>
                                    <p class="text-xs text-gray-500 mt-1">💡 按住 Ctrl (Win) 或 Cmd (Mac) 選擇多個變數</p>
                                </div>
                                <div class="grid md:grid-cols-3 gap-4">
                                    <div>
                                        <label for="kmeansK" class="block text-sm font-medium text-gray-700">集群數量
                                            (K)</label>
                                        <input type="number" id="kmeansK" value="3" min="2" max="10"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">建議先用Elbow法找最佳K值</p>
                                    </div>
                                    <div>
                                        <label for="kmeansMaxIter"
                                            class="block text-sm font-medium text-gray-700">最大迭代次數</label>
                                        <input type="number" id="kmeansMaxIter" value="100" min="10"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    </div>
                                    <div class="flex items-end">
                                        <div class="flex items-center mb-2">
                                            <input type="checkbox" id="kmeansStandardize" checked
                                                class="rounded border-gray-300 text-green-600 mr-2">
                                            <label for="kmeansStandardize"
                                                class="text-sm text-gray-700">標準化變數（建議）</label>
                                        </div>
                                    </div>
                                </div>
                                <div class="flex space-x-3">
                                    <button id="runKmeansElbowBtn"
                                        class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">🔍
                                        Elbow 法找最佳 K</button>
                                    <button id="runKmeansBtn"
                                        class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700">執行
                                        K-Means 集群</button>
                                </div>
                            </div>
                            <div id="kmeansResults" class="mt-6"></div>
                        </div>

                        <!-- Hierarchical Clustering Content -->
                        <div id="hierarchicalContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">
                                階層式集群 (Hierarchical Clustering)：適用於 <strong>&lt; 1000 筆樣本</strong> 的分群分析，支援數值 / 類別 /
                                混合資料。
                                可用於客戶分群、問卷分群、產品組合分析等情境。
                            </p>

                            <div class="bg-emerald-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-emerald-900 mb-2">📐 功能重點</h4>
                                <ul class="text-sm text-emerald-800 space-y-1">
                                    <li>• 支援數值、類別與混合型資料 (Gower 距離)</li>
                                    <li>• 多種連結方法：Ward、Complete、Single、Average、Centroid</li>
                                    <li>• 互動式樹狀圖 + 動態切割線 (拖曳群集數)</li>
                                    <li>• 集群著色熱圖 + 輪廓係數 (Silhouette) 評估圖</li>
                                </ul>
                            </div>

                            <!-- 變數選擇與距離設定 -->
                            <div class="space-y-4">
                                <div>
                                    <label for="hierVariables" class="block text-sm font-medium text-gray-700">
                                        選擇用於分群的變數（可多選，支援數值 + 類別）
                                    </label>
                                    <select id="hierVariables" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                        style="height:140px;"></select>
                                    <p class="text-xs text-gray-500 mt-1">💡 建議 2–6 個變數，樣本 &lt; 1000 筆，以維持瀏覽器流暢度。</p>
                                </div>

                                <div class="grid md:grid-cols-3 gap-4">
                                    <div>
                                        <label for="hierDistanceMetric" class="block text-sm font-medium text-gray-700">
                                            距離計算方法
                                        </label>
                                        <select id="hierDistanceMetric"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            <option value="auto">自動依變數型態選擇</option>
                                            <option value="euclidean">Euclidean (數值)</option>
                                            <option value="manhattan">Manhattan (數值)</option>
                                            <option value="minkowski">Minkowski (數值)</option>
                                            <option value="hamming">Hamming (類別)</option>
                                            <option value="jaccard">Jaccard (類別)</option>
                                            <option value="gower">Gower (混合資料建議)</option>
                                        </select>
                                        <p class="text-xs text-gray-500 mt-1">
                                            🔎 若混合數值 + 類別，系統會自動改用 Gower 距離。
                                        </p>
                                    </div>

                                    <div>
                                        <label for="hierMinkowskiP" class="block text-sm font-medium text-gray-700">
                                            Minkowski 次方 p（僅 Minkowski 有效）
                                        </label>
                                        <input type="number" id="hierMinkowskiP" value="3" min="1" step="0.5"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">
                                            預設 p = 3。p=2 相當於 Euclidean，p=1 為 Manhattan。
                                        </p>
                                    </div>

                                    <div>
                                        <label for="hierLinkage" class="block text-sm font-medium text-gray-700">
                                            連結方法 (Linkage)
                                        </label>
                                        <select id="hierLinkage"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            <option value="ward">Ward's Method（最小變異，預設，需數值 + Euclidean）</option>
                                            <option value="complete">Complete Linkage（最遠鄰）</option>
                                            <option value="single">Single Linkage（最近鄰）</option>
                                            <option value="average">Average Linkage（平均連結）</option>
                                            <option value="centroid">Centroid Method（重心法，需數值 + Euclidean）</option>
                                        </select>
                                        <p class="text-xs text-gray-500 mt-1">
                                            ⚠️ Ward / Centroid 僅在「全部為數值變數且距離為 Euclidean」時啟用，否則自動改為 Average。
                                        </p>
                                    </div>
                                </div>

                                <div class="flex space-x-3">
                                    <button id="runHierarchicalBtn"
                                        class="bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-700">
                                        執行階層式集群
                                    </button>
                                    <p id="hierMessage" class="text-xs text-gray-500 self-center"></p>
                                </div>
                            </div>

                            <!-- 群集數調整（動態切割線） -->
                            <div id="hierClusterSection"
                                class="mt-6 hidden bg-gray-50 p-4 rounded-lg border border-gray-200">
                                <div class="flex items-center space-x-4">
                                    <div class="flex-1">
                                        <label for="hierClusterCount" class="block text-sm font-medium text-gray-700">
                                            群集數 (K) – 拖曳以切割樹狀圖
                                        </label>
                                        <input type="range" id="hierClusterCount" min="2" max="10" value="3"
                                            class="w-full">
                                    </div>
                                    <div class="w-20 text-center">
                                        <span class="text-sm text-gray-500">目前 K：</span>
                                        <span id="hierClusterCountLabel"
                                            class="text-lg font-semibold text-emerald-700">3</span>
                                    </div>
                                </div>
                                <p class="text-xs text-gray-500 mt-1">
                                    系統會依 K 值在樹狀圖上畫出切割線，同時更新熱圖與輪廓係數圖。
                                </p>
                            </div>

                            <!-- 結果視覺化區 -->
                            <div class="mt-6 space-y-6">
                                <div>
                                    <h4 class="font-semibold mb-2">🌳 互動式樹狀圖 (Dendrogram)</h4>
                                    <div id="hierDendrogram"></div>
                                </div>
                                <div>
                                    <h4 class="font-semibold mb-2">🔥 集群著色熱圖</h4>
                                    <div id="hierHeatmap"></div>
                                </div>
                                <div>
                                    <h4 class="font-semibold mb-2">📈 輪廓係數 (Silhouette) 評估圖</h4>
                                    <div id="hierSilhouette"></div>
                                </div>
                            </div>
                        </div>
                        <!-- Apriori Association Rules Content -->
                        <div id="aprioriContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">關聯規則挖掘 (Apriori Algorithm)：發現交易資料中商品之間的關聯性，適用於購物籃分析、交叉銷售策略。
                            </p>
                            <div class="bg-purple-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-purple-900 mb-2">🛒 經典案例</h4>
                                <ul class="text-sm text-purple-800 space-y-1">
                                    <li>• 啤酒 🍺 → 尿布 👶 (週五晚上購物關聯)</li>
                                    <li>• 筆記型電腦 💻 → 滑鼠 🖱️ + 滑鼠墊</li>
                                    <li>• 麵包 🍞 → 牛奶 🥛 + 果醬</li>
                                </ul>
                            </div>
                            <div class="bg-blue-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-blue-900 mb-2">📊 資料格式要求</h4>
                                <p class="text-sm text-blue-800 mb-2">Excel需包含以下欄位結構:</p>
                                <div class="bg-white p-3 rounded border border-blue-200">
                                    <table class="text-xs">
                                        <thead>
                                            <tr class="font-semibold">
                                                <td class="pr-4">交易ID</td>
                                                <td class="pr-4">商品名稱</td>
                                                <td>其他欄位(可選)</td>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td class="pr-4">T001</td>
                                                <td class="pr-4">啤酒</td>
                                                <td>...</td>
                                            </tr>
                                            <tr>
                                                <td class="pr-4">T001</td>
                                                <td class="pr-4">尿布</td>
                                                <td>...</td>
                                            </tr>
                                            <tr>
                                                <td class="pr-4">T002</td>
                                                <td class="pr-4">牛奶</td>
                                                <td>...</td>
                                            </tr>
                                            <tr>
                                                <td class="pr-4">T002</td>
                                                <td class="pr-4">麵包</td>
                                                <td>...</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <p class="text-xs text-blue-600 mt-2">💡 一筆交易可以有多列(每個商品一列)</p>
                            </div>
                            <div class="space-y-4">
                                <div class="grid md:grid-cols-2 gap-4">
                                    <div>
                                        <label for="aprioriTransactionId"
                                            class="block text-sm font-medium text-gray-700">選擇交易ID欄位</label>
                                        <select id="aprioriTransactionId"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                        <p class="text-xs text-gray-500 mt-1">用於區分不同交易</p>
                                    </div>
                                    <div>
                                        <label for="aprioriItemName"
                                            class="block text-sm font-medium text-gray-700">選擇商品名稱欄位</label>
                                        <select id="aprioriItemName"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                        <p class="text-xs text-gray-500 mt-1">商品或項目名稱</p>
                                    </div>
                                </div>
                                <div class="grid md:grid-cols-3 gap-4">
                                    <div>
                                        <label for="aprioriMinSupport"
                                            class="block text-sm font-medium text-gray-700">最小支持度 (Min Support)</label>
                                        <input type="number" id="aprioriMinSupport" value="0.01" step="0.01" min="0.01"
                                            max="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">預設 0.01 (1%)</p>
                                    </div>
                                    <div>
                                        <label for="aprioriMinConfidence"
                                            class="block text-sm font-medium text-gray-700">最小信賴度 (Min
                                            Confidence)</label>
                                        <input type="number" id="aprioriMinConfidence" value="0.3" step="0.05" min="0.1"
                                            max="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">預設 0.3 (30%)</p>
                                    </div>
                                    <div>
                                        <label for="aprioriMinLift"
                                            class="block text-sm font-medium text-gray-700">最小提升度 (Min Lift)</label>
                                        <input type="number" id="aprioriMinLift" value="1.0" step="0.1" min="0.5"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">預設 1.0</p>
                                    </div>
                                </div>
                                <details class="bg-gray-50 p-3 rounded">
                                    <summary class="cursor-pointer text-sm font-medium text-gray-700">❓ 參數說明</summary>
                                    <div class="mt-2 text-sm text-gray-600 space-y-2">
                                        <p><strong>Support (支持度)</strong>: 項目組合在所有交易中出現的比例</p>
                                        <p><strong>Confidence (信賴度)</strong>: 買了A之後買B的條件機率</p>
                                        <p><strong>Lift (提升度)</strong>: 關聯強度，>1表示正相關，=1表示獨立，<1表示負相關< /p>
                                    </div>
                                </details>
                                <button id="runAprioriBtn"
                                    class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700">執行關聯規則挖掘</button>
                            </div>
                            <div id="aprioriResults" class="mt-6"></div>
                        </div>
                        <div id="randomForestContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">
                                隨機森林 (Random Forest)：強大的整體學習方法，透過組合多棵決策樹提升預測準確度。
                                支援<strong>分類</strong>和<strong>迴歸</strong>兩種任務，並提供變數重要性排名。
                            </p>

                            <div class="bg-green-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-green-900 mb-2">🌲 核心優勢</h4>
                                <ul class="text-sm text-green-800 space-y-1">
                                    <li>• <strong>高準確度</strong>：多棵樹投票，降低過擬合風險</li>
                                    <li>• <strong>變數重要性</strong>：識別關鍵影響因子（適合 DOE 分析）</li>
                                    <li>• <strong>穩健性</strong>：對雜訊和缺失值有較強容忍度</li>
                                    <li>• <strong>無需特徵縮放</strong>：直接處理不同尺度的變數</li>
                                </ul>
                            </div>

                            <!-- 任務類型選擇 -->
                            <div class="flex space-x-2 mb-4 border-b border-gray-300">
                                <button id="rfRegressionTab" onclick="switchRFTask('regression')"
                                    class="px-4 py-2 font-semibold border-b-2 border-green-500 text-green-600">
                                    迴歸 Regression
                                </button>
                                <button id="rfClassificationTab" onclick="switchRFTask('classification')"
                                    class="px-4 py-2 font-semibold text-gray-500 hover:text-green-600">
                                    分類 Classification
                                </button>
                            </div>

                            <!-- ============== 迴歸任務面板 ============== -->
                            <div id="rfRegressionPanel">
                                <p class="text-gray-600 mb-4">
                                    預測連續數值結果（如：銷售額、產品硬度、良率）。系統將建立多棵迴歸樹並平均預測值。
                                </p>

                                <div class="space-y-4">
                                    <!-- 變數選擇 -->
                                    <div class="grid md:grid-cols-2 gap-x-8 gap-y-4">
                                        <div>
                                            <label for="rfRegY" class="block text-sm font-medium text-gray-700">
                                                選擇應變數 (Y, 連續數值)
                                            </label>
                                            <select id="rfRegY"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                        </div>
                                        <div>
                                            <label for="rfRegX" class="block text-sm font-medium text-gray-700">
                                                選擇自變數 (X, 可多選)
                                            </label>
                                            <select id="rfRegX" multiple
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm h-32"></select>
                                            <p class="mt-1 text-xs text-gray-500">💡 按住 Ctrl (Win) 或 Cmd (Mac) 多選，建議
                                                5-50 個變數</p>
                                        </div>
                                    </div>

                                    <!-- 模型參數 -->
                                    <details class="border rounded-lg p-3 bg-gray-50">
                                        <summary class="cursor-pointer font-medium text-gray-700">⚙️ 模型參數設定</summary>
                                        <div class="grid md:grid-cols-4 gap-4 mt-3">
                                            <div>
                                                <label for="rfRegNTrees"
                                                    class="block text-sm font-medium text-gray-700">樹的數量</label>
                                                <input type="number" id="rfRegNTrees" value="100" min="10" max="200"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                <p class="text-xs text-gray-500 mt-1">預設 100（50-200 推薦）</p>
                                            </div>
                                            <div>
                                                <label for="rfRegMaxDepth"
                                                    class="block text-sm font-medium text-gray-700">最大深度</label>
                                                <input type="number" id="rfRegMaxDepth" value="10" min="3" max="20"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                <p class="text-xs text-gray-500 mt-1">預設 10（避免過擬合）</p>
                                            </div>
                                            <div>
                                                <label for="rfRegMinSamples"
                                                    class="block text-sm font-medium text-gray-700">最小葉節點樣本</label>
                                                <input type="number" id="rfRegMinSamples" value="5" min="2" max="20"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                <p class="text-xs text-gray-500 mt-1">預設 5</p>
                                            </div>
                                            <div>
                                                <label for="rfRegFeatureMethod"
                                                    class="block text-sm font-medium text-gray-700">特徵採樣</label>
                                                <select id="rfRegFeatureMethod"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                    <option value="sqrt" selected>sqrt(n) - 推薦</option>
                                                    <option value="log2">log2(n)</option>
                                                    <option value="all">全部特徵</option>
                                                </select>
                                                <p class="text-xs text-gray-500 mt-1">每棵樹隨機選取的特徵數</p>
                                            </div>
                                        </div>
                                    </details>

                                    <!-- 執行按鈕 -->
                                    <div>
                                        <button id="runRFRegressionBtn"
                                            class="bg-green-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-green-700 transition duration-300">
                                            🚀 訓練隨機森林（迴歸）
                                        </button>
                                        <span id="rfRegProgress" class="ml-4 text-sm text-gray-600"></span>
                                    </div>
                                </div>

                                <!-- 結果顯示區 -->
                                <div id="rfRegressionResults" class="mt-6"></div>
                            </div>

                            <!-- ============== 分類任務面板 ============== -->
                            <div id="rfClassificationPanel" style="display:none;">
                                <p class="text-gray-600 mb-4">
                                    預測類別結果（如：良品/不良品、高/中/低風險）。系統將建立多棵分類樹並透過投票決定最終類別。
                                </p>

                                <div class="space-y-4">
                                    <!-- 變數選擇 -->
                                    <div class="grid md:grid-cols-2 gap-x-8 gap-y-4">
                                        <div>
                                            <label for="rfClsY" class="block text-sm font-medium text-gray-700">
                                                選擇應變數 (Y, 類別)
                                            </label>
                                            <select id="rfClsY"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                            <p class="mt-1 text-xs text-gray-500">自動偵測類別變數（2-10 個類別）</p>
                                        </div>
                                        <div>
                                            <label for="rfClsX" class="block text-sm font-medium text-gray-700">
                                                選擇自變數 (X, 可多選)
                                            </label>
                                            <select id="rfClsX" multiple
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm h-32"></select>
                                            <p class="mt-1 text-xs text-gray-500">💡 支援數值和類別變數混合</p>
                                        </div>
                                    </div>

                                    <!-- 模型參數 -->
                                    <details class="border rounded-lg p-3 bg-gray-50">
                                        <summary class="cursor-pointer font-medium text-gray-700">⚙️ 模型參數設定</summary>
                                        <div class="grid md:grid-cols-4 gap-4 mt-3">
                                            <div>
                                                <label for="rfClsNTrees"
                                                    class="block text-sm font-medium text-gray-700">樹的數量</label>
                                                <input type="number" id="rfClsNTrees" value="100" min="10" max="200"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            </div>
                                            <div>
                                                <label for="rfClsMaxDepth"
                                                    class="block text-sm font-medium text-gray-700">最大深度</label>
                                                <input type="number" id="rfClsMaxDepth" value="10" min="3" max="20"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            </div>
                                            <div>
                                                <label for="rfClsMinSamples"
                                                    class="block text-sm font-medium text-gray-700">最小葉節點樣本</label>
                                                <input type="number" id="rfClsMinSamples" value="5" min="2" max="20"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            </div>
                                            <div>
                                                <label for="rfClsFeatureMethod"
                                                    class="block text-sm font-medium text-gray-700">特徵採樣</label>
                                                <select id="rfClsFeatureMethod"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                    <option value="sqrt" selected>sqrt(n) - 推薦</option>
                                                    <option value="log2">log2(n)</option>
                                                    <option value="all">全部特徵</option>
                                                </select>
                                            </div>
                                        </div>
                                    </details>

                                    <!-- 執行按鈕 -->
                                    <div>
                                        <button id="runRFClassificationBtn"
                                            class="bg-green-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-green-700 transition duration-300">
                                            🚀 訓練隨機森林（分類）
                                        </button>
                                        <span id="rfClsProgress" class="ml-4 text-sm text-gray-600"></span>
                                    </div>
                                </div>

                                <!-- 結果顯示區 -->
                                <div id="rfClassificationResults" class="mt-6"></div>
                            </div>
                        </div>
                        <!-- Neural Network Content -->
                        <div id="neuralNetworkContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">
                                神經網絡 (Neural Network)：適合處理非線性關係的分類與迴歸問題，常用於影像辨識、文字分類、異常偵測等情境。
                            </p>

                            <div class="bg-purple-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-purple-900 mb-2">🧠 使用建議</h4>
                                <ul class="text-sm text-purple-800 space-y-1">
                                    <li>• 當「線性迴歸」或「決策樹」效果不足時，可嘗試神經網絡。</li>
                                    <li>• 資料筆數越多、特徵越多，神經網絡的優勢越明顯。</li>
                                    <li>• 需注意過擬合，建議搭配驗證集、正規化與早停策略。</li>
                                </ul>
                            </div>

                            <div class="grid md:grid-cols-2 gap-x-8 gap-y-4 items-start">
                                <div>
                                    <label for="nnY" class="block text-sm font-medium text-gray-700">選擇應變數 (Y)</label>
                                    <select id="nnY"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    <p class="mt-2 text-xs text-gray-500">
                                        Y 可為連續數值（迴歸）或類別變數（分類）；系統會自動判斷任務型型。
                                    </p>
                                </div>
                                <div>
                                    <label for="nnX" class="block text-sm font-medium text-gray-700">選擇自變數 (X,
                                        可多選)</label>
                                    <select id="nnX" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm h-32"></select>
                                    <p class="mt-2 text-xs text-gray-500">
                                        建議優先選擇數值型特徵；類別變數需先做 One-Hot Encoding 或數值化處理。
                                    </p>
                                </div>
                                <div>
                                    <label for="nnHiddenUnits" class="block text-sm font-medium text-gray-700">隱藏層神經元數
                                        (Hidden Units)</label>
                                    <input type="number" id="nnHiddenUnits" value="8" min="1"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="mt-2 text-xs text-gray-500">可先從 8~32 嘗試，再視效能調整。</p>
                                </div>
                                <div>
                                    <label for="nnEpochs" class="block text-sm font-medium text-gray-700">訓練迭代次數
                                        (Epochs)</label>
                                    <input type="number" id="nnEpochs" value="200" min="10"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="mt-2 text-xs text-gray-500">示範用途建議 100~300；實務應視資料量調整。</p>
                                </div>
                            </div>

                            <div class="mt-4">
                                <button id="runNNBtn"
                                    class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700">
                                    執行神經網絡 (訓練 + Permutation Importance)
                                </button>
                            </div>

                            <div id="nnResults" class="mt-6 text-sm text-gray-700 space-y-3">
                                <p>此版本將在瀏覽器端使用 <strong>TensorFlow.js</strong> 訓練簡單的 MLP 模型，並計算 <strong>Permutation
                                        Importance</strong>，搭配 Plotly 長條圖展示特徵重要度。</p>
                            </div>

                            <div id="nnImportanceSummary" class="mt-4 text-sm text-gray-700"></div>
                            <div id="nnImportancePlot" class="mt-4"></div>

                            <!-- 新增：Learning Curve 與 Confusion Matrix -->
                            <div id="nnLearningCurve" class="mt-6"></div>
                            <div id="nnConfusionMatrix" class="mt-6"></div>
                        </div>

                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- Global Variables & DOM References ---
        let jsonData = [], headers = [], numericHeaders = [], categoricalHeaders = [];
        let currentWorkbook = null;
        let logisticModel = null;
        let hierarchicalState = null;   // 新增：階層式集群狀態
        let currentInputMode = "file";  // 資料輸入方式：file 或 paste

        // --- Event Listeners Setup ---

        // ═══════════════════════════════════════════════════════════════
        // 隨機森林 (Random Forest) 核心實作
        // ═══════════════════════════════════════════════════════════════

        // ═══════════════════════════════════════════════════════════════
        // 隨機森林 (Random Forest) 核心實作
        // 支援分類 (Classification) 和迴歸 (Regression)
        // ═══════════════════════════════════════════════════════════════

        /**
         * Bootstrap 採樣 - 從原始數據中隨機抽取樣本(允許重複)
         * @param {Array} data - 原始數據陣列
         * @param {number} sampleSize - 採樣數量（預設為原始數據大小）
         * @returns {Object} { sample: 採樣數據, oobIndices: OOB樣本索引 }
         */
        function bootstrapSample(data, sampleSize = data.length) {
            const sample = [];
            const usedIndices = new Set();

            for (let i = 0; i < sampleSize; i++) {
                const randomIndex = Math.floor(Math.random() * data.length);
                sample.push(data[randomIndex]);
                usedIndices.add(randomIndex);
            }

            // Out-of-Bag (OOB) 樣本：未被抽到的樣本索引
            const oobIndices = [];
            for (let i = 0; i < data.length; i++) {
                if (!usedIndices.has(i)) {
                    oobIndices.push(i);
                }
            }

            return { sample, oobIndices };
        }

        /**
         * 特徵隨機選擇 - 從所有特徵中隨機選取子集
         * @param {number} totalFeatures - 總特徵數
         * @param {string} method - 選擇方法 ('sqrt' | 'log2' | 'all' | number)
         * @returns {Array} 選中的特徵索引陣列
         */
        function randomFeatureSelection(totalFeatures, method = 'sqrt') {
            let numFeatures;

            if (typeof method === 'number') {
                numFeatures = Math.min(method, totalFeatures);
            } else if (method === 'sqrt') {
                numFeatures = Math.floor(Math.sqrt(totalFeatures));
            } else if (method === 'log2') {
                numFeatures = Math.floor(Math.log2(totalFeatures)) + 1;
            } else {
                numFeatures = totalFeatures; // 'all'
            }

            // 隨機選擇特徵
            const allIndices = Array.from({ length: totalFeatures }, (_, i) => i);
            const shuffled = allIndices.sort(() => Math.random() - 0.5);
            return shuffled.slice(0, numFeatures);
        }

        /**
         * 訓練單棵決策樹（迴歸）
         * @param {Array} X - 特徵矩陣
         * @param {Array} y - 目標變數
         * @param {Object} options - 樹的參數
         * @returns {Object} 訓練好的樹模型
         */
        function trainSingleRegressionTree(X, y, options) {
            const tree = new ML.DecisionTreeRegression(options);
            tree.train(X, y);
            return tree;
        }

        /**
         * 訓練單棵決策樹（分類）- 使用迴歸樹近似
         * @param {Array} X - 特徵矩陣
         * @param {Array} y - 目標變數（數值編碼的類別）
         * @param {Object} options - 樹的參數
         * @returns {Object} 訓練好的樹模型
         */
        function trainSingleClassificationTree(X, y, options) {
            // ml.js 沒有內建分類樹，使用迴歸樹 + 四捨五入近似
            const tree = new ML.DecisionTreeRegression(options);
            tree.train(X, y);
            return tree;
        }

        /**
         * 隨機森林訓練（迴歸版本）
         * @param {Array} X - 完整特徵矩陣 [n_samples x n_features]
         * @param {Array} y - 完整目標變數 [n_samples]
         * @param {Object} params - 隨機森林參數
         * @returns {Object} 訓練好的隨機森林模型
         */
        function trainRandomForestRegressor(X, y, params = {}) {
            const {
                nTrees = 100,
                maxDepth = 10,
                minSamplesLeaf = 5,
                featureSubsetMethod = 'sqrt',
                progressCallback = null
            } = params;

            const n = X.length;
            const m = X[0].length;
            const trees = [];
            const oobSamples = []; // 儲存每棵樹的OOB樣本

            console.log(`🌲 開始訓練隨機森林迴歸器：${nTrees}棵樹，${m}個特徵`);

            for (let t = 0; t < nTrees; t++) {
                // 1. Bootstrap 採樣
                const indices = Array.from({ length: n }, (_, i) => i);
                const { sample: sampledIndices, oobIndices } = bootstrapSample(indices);

                const X_sample = sampledIndices.map(idx => X[idx]);
                const y_sample = sampledIndices.map(idx => y[idx]);

                // 2. 特徵隨機選擇
                const selectedFeatures = randomFeatureSelection(m, featureSubsetMethod);
                const X_subset = X_sample.map(row => selectedFeatures.map(i => row[i]));

                // 3. 訓練決策樹
                const treeOptions = { maxDepth, minNumSamples: minSamplesLeaf };
                const tree = trainSingleRegressionTree(X_subset, y_sample, treeOptions);

                trees.push({
                    model: tree,
                    selectedFeatures,
                    oobIndices
                });

                oobSamples.push(oobIndices);

                // 進度回調
                if (progressCallback && (t + 1) % 10 === 0) {
                    progressCallback(t + 1, nTrees);
                }
            }

            console.log(`✅ 隨機森林訓練完成！共 ${trees.length} 棵樹`);

            return {
                trees,
                nTrees,
                nFeatures: m,
                type: 'regression',
                oobSamples
            };
        }

        /**
         * 隨機森林訓練（分類版本）
         * @param {Array} X - 完整特徵矩陣
         * @param {Array} y - 完整目標變數（數值編碼）
         * @param {Object} params - 隨機森林參數
         * @returns {Object} 訓練好的隨機森林模型
         */
        function trainRandomForestClassifier(X, y, params = {}) {
            const {
                nTrees = 100,
                maxDepth = 10,
                minSamplesLeaf = 5,
                featureSubsetMethod = 'sqrt',
                progressCallback = null
            } = params;

            const n = X.length;
            const m = X[0].length;
            const trees = [];
            const oobSamples = [];

            console.log(`🌲 開始訓練隨機森林分類器：${nTrees}棵樹，${m}個特徵`);

            for (let t = 0; t < nTrees; t++) {
                const indices = Array.from({ length: n }, (_, i) => i);
                const { sample: sampledIndices, oobIndices } = bootstrapSample(indices);

                const X_sample = sampledIndices.map(idx => X[idx]);
                const y_sample = sampledIndices.map(idx => y[idx]);

                const selectedFeatures = randomFeatureSelection(m, featureSubsetMethod);
                const X_subset = X_sample.map(row => selectedFeatures.map(i => row[i]));

                const treeOptions = { maxDepth, minNumSamples: minSamplesLeaf };
                const tree = trainSingleClassificationTree(X_subset, y_sample, treeOptions);

                trees.push({
                    model: tree,
                    selectedFeatures,
                    oobIndices
                });

                oobSamples.push(oobIndices);

                if (progressCallback && (t + 1) % 10 === 0) {
                    progressCallback(t + 1, nTrees);
                }
            }

            console.log(`✅ 隨機森林訓練完成！共 ${trees.length} 棵樹`);

            return {
                trees,
                nTrees,
                nFeatures: m,
                type: 'classification',
                oobSamples,
                uniqueClasses: [...new Set(y)]
            };
        }

        /**
         * 隨機森林預測（迴歸）
         * @param {Object} forest - 訓練好的森林模型
         * @param {Array} X_test - 測試特徵矩陣
         * @returns {Array} 預測值
         */
        function predictRandomForestRegressor(forest, X_test) {
            const predictions = X_test.map(sample => {
                const treePredictions = forest.trees.map(treeObj => {
                    const { model, selectedFeatures } = treeObj;
                    const subset = selectedFeatures.map(i => sample[i]);
                    return model.predict([subset])[0];
                });

                // 平均所有樹的預測
                return treePredictions.reduce((a, b) => a + b, 0) / treePredictions.length;
            });

            return predictions;
        }

        /**
         * 隨機森林預測（分類）
         * @param {Object} forest - 訓練好的森林模型
         * @param {Array} X_test - 測試特徵矩陣
         * @returns {Array} 預測類別
         */
        function predictRandomForestClassifier(forest, X_test) {
            const predictions = X_test.map(sample => {
                const treePredictions = forest.trees.map(treeObj => {
                    const { model, selectedFeatures } = treeObj;
                    const subset = selectedFeatures.map(i => sample[i]);
                    const pred = model.predict([subset])[0];
                    return Math.round(pred); // 四捨五入到最近的類別
                });

                // 投票：找出出現最多次的類別
                const counts = {};
                treePredictions.forEach(p => {
                    counts[p] = (counts[p] || 0) + 1;
                });

                let maxCount = 0;
                let majorityClass = treePredictions[0];
                for (const [cls, count] of Object.entries(counts)) {
                    if (count > maxCount) {
                        maxCount = count;
                        majorityClass = parseInt(cls);
                    }
                }

                return majorityClass;
            });

            return predictions;
        }

        /**
         * 計算 OOB 誤差（迴歸）
         * @param {Object} forest - 訓練好的森林模型
         * @param {Array} X - 原始訓練特徵矩陣
         * @param {Array} y - 原始訓練目標變數
         * @returns {Object} OOB誤差統計
         */
        function calculateOOBErrorRegression(forest, X, y) {
            const n = X.length;
            const oobPredictions = new Array(n).fill(null);
            const oobCounts = new Array(n).fill(0);

            // 對每個樣本，用未抽到該樣本的樹進行預測
            forest.trees.forEach(treeObj => {
                const { model, selectedFeatures, oobIndices } = treeObj;

                oobIndices.forEach(idx => {
                    const subset = selectedFeatures.map(i => X[idx][i]);
                    const pred = model.predict([subset])[0];

                    if (oobPredictions[idx] === null) {
                        oobPredictions[idx] = pred;
                    } else {
                        oobPredictions[idx] += pred;
                    }
                    oobCounts[idx]++;
                });
            });

            // 平均OOB預測
            const finalOOBPredictions = oobPredictions.map((sum, idx) =>
                oobCounts[idx] > 0 ? sum / oobCounts[idx] : null
            );

            // 計算誤差
            let sumSquaredError = 0;
            let validCount = 0;

            for (let i = 0; i < n; i++) {
                if (finalOOBPredictions[i] !== null) {
                    const error = y[i] - finalOOBPredictions[i];
                    sumSquaredError += error * error;
                    validCount++;
                }
            }

            const oobMSE = validCount > 0 ? sumSquaredError / validCount : null;
            const oobRMSE = oobMSE !== null ? Math.sqrt(oobMSE) : null;

            return {
                oobMSE,
                oobRMSE,
                oobPredictions: finalOOBPredictions,
                oobCoverage: validCount / n
            };
        }

        /**
         * 計算特徵重要性（基於所有樹的平均）
         * @param {Object} forest - 訓練好的森林模型
         * @param {Array} featureNames - 特徵名稱
         * @returns {Array} 特徵重要性陣列
         */
        function calculateFeatureImportance(forest, featureNames) {
            const m = forest.nFeatures;
            const importanceSum = new Array(m).fill(0);
            const importanceCount = new Array(m).fill(0);

            forest.trees.forEach(treeObj => {
                const { model, selectedFeatures } = treeObj;
                const treeJSON = model.toJSON();

                // 使用現有的 calculateDtImportance 函數
                const treeImportances = calculateDtImportance(treeJSON, selectedFeatures.length);

                // 映射回原始特徵索引
                treeImportances.forEach((imp, localIdx) => {
                    const globalIdx = selectedFeatures[localIdx];
                    importanceSum[globalIdx] += imp;
                    importanceCount[globalIdx]++;
                });
            });

            // 平均並標準化
            const importances = importanceSum.map((sum, idx) =>
                importanceCount[idx] > 0 ? sum / importanceCount[idx] : 0
            );

            const total = importances.reduce((a, b) => a + b, 0);
            const normalized = total > 0 ? importances.map(x => x / total) : importances;

            return normalized.map((imp, idx) => ({
                feature: featureNames[idx],
                importance: imp,
                index: idx
            })).sort((a, b) => b.importance - a.importance);
        }

        /**
         * 計算迴歸評估指標
         * @param {Array} yTrue - 真實值
         * @param {Array} yPred - 預測值
         * @returns {Object} 評估指標
         */
        function calculateRegressionMetrics(yTrue, yPred) {
            const n = yTrue.length;
            const mean = yTrue.reduce((a, b) => a + b, 0) / n;

            let sst = 0, sse = 0, sae = 0;
            let mape_sum = 0;

            for (let i = 0; i < n; i++) {
                const error = yTrue[i] - yPred[i];
                sse += error * error;
                sae += Math.abs(error);
                sst += (yTrue[i] - mean) ** 2;
                if (yTrue[i] !== 0) {
                    mape_sum += Math.abs(error / yTrue[i]);
                }
            }

            const r2 = sst > 0 ? 1 - (sse / sst) : 0;
            const mse = sse / n;
            const rmse = Math.sqrt(mse);
            const mae = sae / n;
            const mape = (mape_sum / n) * 100;

            return { r2, mse, rmse, mae, mape };
        }

        /**
         * 計算混淆矩陣
         * @param {Array} yTrue - 真實類別
         * @param {Array} yPred - 預測類別
         * @param {Array} classes - 所有類別
         * @returns {Object} 混淆矩陣和統計
         */
        function calculateConfusionMatrix(yTrue, yPred, classes) {
            const n = classes.length;
            const matrix = Array(n).fill(0).map(() => Array(n).fill(0));

            for (let i = 0; i < yTrue.length; i++) {
                const trueIdx = classes.indexOf(yTrue[i]);
                const predIdx = classes.indexOf(yPred[i]);
                if (trueIdx >= 0 && predIdx >= 0) {
                    matrix[trueIdx][predIdx]++;
                }
            }

            // 計算準確度、精確度、召回率
            let totalCorrect = 0;
            const classMetrics = classes.map((cls, idx) => {
                const tp = matrix[idx][idx];
                const fp = matrix.map((row, i) => i !== idx ? row[idx] : 0).reduce((a, b) => a + b, 0);
                const fn = matrix[idx].reduce((a, b, i) => i !== idx ? a + b : a, 0);
                const tn = matrix.map((row, i) => i !== idx ? row.reduce((a, b, j) => j !== idx ? a + b : a, 0) : 0).reduce((a, b) => a + b, 0);

                totalCorrect += tp;

                const precision = (tp + fp) > 0 ? tp / (tp + fp) : 0;
                const recall = (tp + fn) > 0 ? tp / (tp + fn) : 0;
                const f1 = (precision + recall) > 0 ? 2 * precision * recall / (precision + recall) : 0;

                return { class: cls, precision, recall, f1 };
            });

            const accuracy = totalCorrect / yTrue.length;

            return { matrix, accuracy, classMetrics };
        }

        console.log('✅ 隨機森林核心模組載入完成！');


        // ═══════════════════════════════════════════════════════════════
        // 隨機森林主函數實作
        // ═══════════════════════════════════════════════════════════════

        // ═══════════════════════════════════════════════════════════════
        // 隨機森林主函數實作 - 迴歸 & 分類
        // ═══════════════════════════════════════════════════════════════

        /**
         * 執行隨機森林迴歸分析
         */
        function runRandomForestRegression() {
            const yVar = document.getElementById('rfRegY').value;
            const rawXVars = Array.from(document.getElementById('rfRegX').selectedOptions).map(opt => opt.value);

            // Check for overlap
            if (rawXVars.includes(yVar)) {
                alert(`錯誤：目標變數 (Y) "${yVar}" 不能同時作為特徵變數 (X)。請從特徵變數中移除它。`);
                return;
            }

            // 避免 Y 與 X 重複，並移除重複的 X 欄位
            const xVars = [...new Set(rawXVars.filter(v => v !== yVar))];
            const nTrees = parseInt(document.getElementById('rfRegNTrees').value);
            const maxDepth = parseInt(document.getElementById('rfRegMaxDepth').value);
            const minSamples = parseInt(document.getElementById('rfRegMinSamples').value);
            const featureMethod = document.getElementById('rfRegFeatureMethod').value;

            const resultsDiv = document.getElementById('rfRegressionResults');
            const progressSpan = document.getElementById('rfRegProgress');

            resultsDiv.innerHTML = '';
            progressSpan.textContent = '';

            // 驗證輸入
            if (!yVar || xVars.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇應變數 (Y) 和至少一個自變數 (X)。</p>`;
                return;
            }

            if (xVars.length > 50) {
                resultsDiv.innerHTML = `<p class="text-red-600">自變數超過 50 個，建議精簡特徵以提升效率。</p>`;
                return;
            }

            // 準備數據（類別編碼）
            const encoders = {};
            xVars.forEach(header => {
                if (categoricalHeaders.includes(header)) {
                    const uniqueValues = [...new Set(jsonData.map(row => row[header]).filter(v => v != null))];
                    encoders[header] = {};
                    uniqueValues.forEach((val, i) => { encoders[header][val] = i; });
                }
            });

            const X = [], y = [];
            for (const row of jsonData) {
                let isValidRow = true;
                const featureRow = [];

                for (const xVar of xVars) {
                    const val = row[xVar];
                    if (val == null) { isValidRow = false; break; }
                    featureRow.push(categoricalHeaders.includes(xVar) ? encoders[xVar][val] : val);
                }

                const yVal = row[yVar];
                if (yVal == null || typeof yVal !== 'number') isValidRow = false;

                if (isValidRow) {
                    X.push(featureRow);
                    y.push(yVal);
                }
            }

            if (X.length < 40) {
                resultsDiv.innerHTML = `<p class="text-red-600">有效資料列不足 (${X.length} 筆)，隨機森林建議至少 40 筆樣本。</p>`;
                return;
            }

            // 顯示載入指示
            resultsDiv.innerHTML = `<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在訓練 ${nTrees} 棵決策樹...</p>`;

            // 延遲執行以更新 UI
            setTimeout(() => {
                try {
                    // 訓練隨機森林
                    const forest = trainRandomForestRegressor(X, y, {
                        nTrees,
                        maxDepth,
                        minSamplesLeaf: minSamples,
                        featureSubsetMethod: featureMethod,
                        progressCallback: (current, total) => {
                            progressSpan.textContent = `訓練進度：${current}/${total} 棵樹`;
                        }
                    });

                    progressSpan.textContent = '✅ 訓練完成！正在評估...';

                    // 預測訓練集
                    const yPred = predictRandomForestRegressor(forest, X);

                    // 計算評估指標
                    const metrics = calculateRegressionMetrics(y, yPred);

                    // 計算 OOB 誤差
                    const oobStats = calculateOOBErrorRegression(forest, X, y);

                    // 計算特徵重要性
                    const importances = calculateFeatureImportance(forest, xVars);

                    // 生成結果 HTML
                    let html = `
                <div class="bg-white p-6 rounded-lg border shadow-sm">
                    <h3 class="text-xl font-bold mb-4 text-green-700">🌲 隨機森林迴歸模型結果</h3>
                    
                    <!-- 模型摘要 -->
                    <div class="grid md:grid-cols-2 gap-4 mb-6">
                        <div class="bg-gray-50 p-4 rounded">
                            <h4 class="font-semibold mb-2">📊 模型配置</h4>
                            <ul class="text-sm space-y-1">
                                <li>• 樹的數量：${nTrees} 棵</li>
                                <li>• 最大深度：${maxDepth} 層</li>
                                <li>• 訓練樣本：${X.length} 筆</li>
                                <li>• 特徵數量：${xVars.length} 個</li>
                            </ul>
                        </div>
                        <div class="bg-green-50 p-4 rounded">
                            <h4 class="font-semibold mb-2">📈 預測效能（訓練集）</h4>
                            <ul class="text-sm space-y-1">
                                <li>• <strong>R² 決定係數</strong>：${metrics.r2.toFixed(4)} ${metrics.r2 > 0.8 ? '✅ 優秀' : metrics.r2 > 0.6 ? '⚠️ 良好' : '❌ 需改進'}</li>
                                <li>• <strong>RMSE</strong>：${metrics.rmse.toFixed(4)}</li>
                                <li>• <strong>MAE</strong>：${metrics.mae.toFixed(4)}</li>
                                <li>• <strong>MAPE</strong>：${metrics.mape.toFixed(2)}%</li>
                            </ul>
                        </div>
                    </div>
                    
                    <!-- OOB 評估 -->
                    <div class="bg-blue-50 p-4 rounded mb-6">
                        <h4 class="font-semibold mb-2">🎯 Out-of-Bag (OOB) 評估</h4>
                        <p class="text-sm text-gray-700 mb-2">OOB 評估使用未參與訓練的樣本預測，更接近真實泛化能力。</p>
                        <ul class="text-sm space-y-1">
                            <li>• <strong>OOB RMSE</strong>：${oobStats.oobRMSE ? oobStats.oobRMSE.toFixed(4) : 'N/A'}</li>
                            <li>• <strong>OOB 覆蓋率</strong>：${(oobStats.oobCoverage * 100).toFixed(1)}%</li>
                        </ul>
                    </div>
                    
                    <!-- 特徵重要性 -->
                    <div class="mb-6">
                        <h4 class="font-semibold mb-3">🔑 變數重要性排名（適合 DOE 分析）</h4>
                        <div id="rfRegImportancePlot"></div>
                        <div class="overflow-x-auto mt-4">
                            <table class="min-w-full divide-y divide-gray-200 border">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">排名</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">變數</th>
                                        <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">重要性</th>
                                        <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">百分比</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-white divide-y divide-gray-200">
            `;

                    importances.forEach((imp, idx) => {
                        const percentage = (imp.importance * 100).toFixed(2);
                        const barWidth = imp.importance * 200; // 視覺化長條
                        html += `
                    <tr>
                        <td class="px-4 py-2 text-sm text-gray-900">${idx + 1}</td>
                        <td class="px-4 py-2 text-sm font-medium text-gray-900">${imp.feature}</td>
                        <td class="px-4 py-2 text-sm text-right text-gray-500">${imp.importance.toFixed(4)}</td>
                        <td class="px-4 py-2 text-sm text-right">
                            <div class="flex items-center justify-end">
                                <div class="w-20 bg-gray-200 rounded-full h-2 mr-2">
                                    <div class="bg-green-600 h-2 rounded-full" style="width: ${barWidth}px"></div>
                                </div>
                                <span class="text-gray-600">${percentage}%</span>
                            </div>
                        </td>
                    </tr>
                `;
                    });

                    html += `
                                </tbody>
                            </table>
                        </div>
                        <p class="text-xs text-gray-500 mt-3">💡 重要性越高，表示該變數對預測結果的影響越大（基於所有樹的平均貢獻度）</p>
                    </div>
                    
                    <!-- 實際 vs 預測散點圖 -->
                    <div class="mb-6">
                        <h4 class="font-semibold mb-3">📊 實際值 vs 預測值</h4>
                        <div id="rfRegScatterPlot"></div>
                    </div>
                    
                    <!-- 殘差圖 -->
                    <div>
                        <h4 class="font-semibold mb-3">📉 殘差分析</h4>
                        <div id="rfRegResidualPlot"></div>
                        <p class="text-xs text-gray-500 mt-2">💡 殘差應隨機分布在零線附近，無明顯模式</p>
                    </div>

                    <!-- Prediction Section -->
                    <div class="mt-6 p-4 bg-gray-50 rounded border border-gray-200">
                        <h4 class="text-md font-semibold mb-3">🔮 模型預測 (Prediction)</h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="rfRegPredictionInputs">
                            ${xVars.map((xVar, i) => {
                        if (categoricalHeaders.includes(xVar)) {
                            const options = Object.keys(encoders[xVar]).map(c => `<option value="${c}">${c}</option>`).join('');
                            return `
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700 mb-1">${xVar}</label>
                                            <select id="rf_reg_pred_input_${i}" class="w-full p-2 border rounded">
                                                ${options}
                                            </select>
                                        </div>
                                    `;
                        } else {
                            return `
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700 mb-1">${xVar}</label>
                                            <input type="number" id="rf_reg_pred_input_${i}" class="w-full p-2 border rounded" placeholder="輸入數值">
                                        </div>
                                    `;
                        }
                    }).join('')}
                        </div>
                        <button id="btnPredictRFReg" class="mt-4 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition">
                            進行預測
                        </button>
                        <div id="rfRegPredictionResult" class="mt-4 hidden p-3 bg-white border rounded"></div>
                    </div>
                </div>
            `;

                    resultsDiv.innerHTML = html;
                    progressSpan.textContent = '';

                    // Bind Prediction Event
                    document.getElementById('btnPredictRFReg').addEventListener('click', () => {
                        const resultDiv = document.getElementById('rfRegPredictionResult');
                        resultDiv.classList.remove('hidden');

                        try {
                            const inputVector = [];
                            for (let i = 0; i < xVars.length; i++) {
                                const xVar = xVars[i];
                                const el = document.getElementById(`rf_reg_pred_input_${i}`);
                                const val = el.value;

                                if (categoricalHeaders.includes(xVar)) {
                                    if (!(val in encoders[xVar])) throw new Error(`無效的類別值：${xVar}`);
                                    inputVector.push(encoders[xVar][val]);
                                } else {
                                    const numVal = parseFloat(val);
                                    if (isNaN(numVal)) throw new Error(`請輸入有效的數值：${xVar}`);
                                    inputVector.push(numVal);
                                }
                            }

                            const pred = predictRandomForestRegressor(forest, [inputVector])[0];
                            resultDiv.innerHTML = `<p class="text-lg">預測結果 (${yVar})：<strong>${pred.toFixed(4)}</strong></p>`;
                        } catch (e) {
                            resultDiv.innerHTML = `<p class="text-red-600">錯誤：${e.message}</p>`;
                        }
                    });

                    // 繪製特徵重要性圖
                    const importanceTrace = {
                        x: importances.map(imp => imp.importance).reverse(),
                        y: importances.map(imp => imp.feature).reverse(),
                        type: 'bar',
                        orientation: 'h',
                        marker: { color: 'rgb(34, 197, 94)' }
                    };
                    Plotly.newPlot('rfRegImportancePlot', [importanceTrace], {
                        title: '變數重要性',
                        xaxis: { title: '重要性分數' },
                        margin: { l: 150 }
                    }, { responsive: true });

                    // 繪製散點圖
                    const scatterTrace = {
                        x: y,
                        y: yPred,
                        mode: 'markers',
                        type: 'scatter',
                        marker: { color: 'rgba(34, 197, 94, 0.6)', size: 6 },
                        name: '預測值'
                    };
                    const idealLine = {
                        x: [Math.min(...y), Math.max(...y)],
                        y: [Math.min(...y), Math.max(...y)],
                        mode: 'lines',
                        line: { color: 'red', dash: 'dash', width: 2 },
                        name: '理想預測'
                    };
                    Plotly.newPlot('rfRegScatterPlot', [scatterTrace, idealLine], {
                        title: `實際值 vs 預測值 (R² = ${metrics.r2.toFixed(3)})`,
                        xaxis: { title: `實際 ${yVar}` },
                        yaxis: { title: `預測 ${yVar}` }
                    }, { responsive: true });

                    // 繪製殘差圖
                    const residuals = y.map((actual, idx) => actual - yPred[idx]);
                    const residualTrace = {
                        x: yPred,
                        y: residuals,
                        mode: 'markers',
                        type: 'scatter',
                        marker: { color: 'rgba(239, 68, 68, 0.6)', size: 6 }
                    };
                    const zeroLine = {
                        x: [Math.min(...yPred), Math.max(...yPred)],
                        y: [0, 0],
                        mode: 'lines',
                        line: { color: 'black', dash: 'dash', width: 1 }
                    };
                    Plotly.newPlot('rfRegResidualPlot', [residualTrace, zeroLine], {
                        title: '殘差圖',
                        xaxis: { title: '預測值' },
                        yaxis: { title: '殘差 (實際 - 預測)' }
                    }, { responsive: true });

                } catch (err) {
                    resultsDiv.innerHTML = `<p class="text-red-600">訓練時發生錯誤：${err.message}</p>`;
                    console.error(err);
                    progressSpan.textContent = '';
                }
            }, 100);
        }

        /**
         * 執行隨機森林分類分析
         */
        function runRandomForestClassification() {
            const yVar = document.getElementById('rfClsY').value;
            const rawXVars = Array.from(document.getElementById('rfClsX').selectedOptions).map(opt => opt.value);

            // Check for overlap
            if (rawXVars.includes(yVar)) {
                alert(`錯誤：目標變數 (Y) "${yVar}" 不能同時作為特徵變數 (X)。請從特徵變數中移除它。`);
                return;
            }

            // 避免 Y 與 X 重複，並移除重複的 X 欄位
            const xVars = [...new Set(rawXVars.filter(v => v !== yVar))];
            const nTrees = parseInt(document.getElementById('rfClsNTrees').value);
            const maxDepth = parseInt(document.getElementById('rfClsMaxDepth').value);
            const minSamples = parseInt(document.getElementById('rfClsMinSamples').value);
            const featureMethod = document.getElementById('rfClsFeatureMethod').value;

            const resultsDiv = document.getElementById('rfClassificationResults');
            const progressSpan = document.getElementById('rfClsProgress');

            resultsDiv.innerHTML = '';
            progressSpan.textContent = '';

            if (!yVar || xVars.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇應變數 (Y) 和至少一個自變數 (X)。</p>`;
                return;
            }

            if (!jsonData || jsonData.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">請先載入資料並完成欄位設定。</p>`;
                return;
            }

            // 編碼 Y 變數（類別）
            const yValues = jsonData.map(row => row[yVar]).filter(v => v != null);
            const uniqueClasses = [...new Set(yValues)];

            if (uniqueClasses.length < 2 || uniqueClasses.length > 10) {
                resultsDiv.innerHTML = `<p class="text-red-600">應變數類別數應在 2-10 之間（當前：${uniqueClasses.length}）。</p>`;
                return;
            }

            const yEncoder = {};
            uniqueClasses.forEach((cls, idx) => { yEncoder[cls] = idx; });

            // 編碼 X 變數
            const encoders = {};
            xVars.forEach(header => {
                if (categoricalHeaders.includes(header)) {
                    const uniqueValues = [...new Set(jsonData.map(row => row[header]).filter(v => v != null))];
                    encoders[header] = {};
                    uniqueValues.forEach((val, i) => { encoders[header][val] = i; });
                }
            });

            const X = [], y = [];
            for (const row of jsonData) {
                let isValidRow = true;
                const featureRow = [];

                for (const xVar of xVars) {
                    const val = row[xVar];
                    if (val == null) { isValidRow = false; break; }
                    featureRow.push(categoricalHeaders.includes(xVar) ? encoders[xVar][val] : val);
                }

                const yVal = row[yVar];
                if (yVal == null || !(yVal in yEncoder)) isValidRow = false;

                if (isValidRow) {
                    X.push(featureRow);
                    y.push(yEncoder[yVal]);
                }
            }

            if (X.length < 40) {
                resultsDiv.innerHTML = `<p class="text-red-600">有效資料列不足 (${X.length} 筆)，建議至少 40 筆樣本。</p>`;
                return;
            }

            resultsDiv.innerHTML = `<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在訓練 ${nTrees} 棵分類樹...</p>`;

            setTimeout(() => {
                try {
                    const forest = trainRandomForestClassifier(X, y, {
                        nTrees,
                        maxDepth,
                        minSamplesLeaf: minSamples,
                        featureSubsetMethod: featureMethod,
                        progressCallback: (current, total) => {
                            progressSpan.textContent = `訓練進度：${current}/${total} 棵樹`;
                        }
                    });

                    progressSpan.textContent = '✅ 訓練完成！正在評估...';

                    const yPred = predictRandomForestClassifier(forest, X);
                    const confusionResult = calculateConfusionMatrix(y, yPred, forest.uniqueClasses);
                    const importances = calculateFeatureImportance(forest, xVars);

                    // 由編碼值還原類別標籤
                    const classLabels = forest.uniqueClasses.map(c =>
                        Object.keys(yEncoder).find(k => yEncoder[k] === c)
                    );

                    const classMetrics = confusionResult.classMetrics || [];
                    let macroPrecision = 0, macroRecall = 0, macroF1 = 0;
                    if (classMetrics.length > 0) {
                        macroPrecision = classMetrics.reduce((s, m) => s + m.precision, 0) / classMetrics.length;
                        macroRecall = classMetrics.reduce((s, m) => s + m.recall, 0) / classMetrics.length;
                        macroF1 = classMetrics.reduce((s, m) => s + m.f1, 0) / classMetrics.length;
                    }

                    // 組出帶標籤的指標陣列，方便排序與說明
                    const metricsWithLabels = forest.uniqueClasses.map((cls, idx) => {
                        const label = classLabels[idx] ?? cls;
                        const m = classMetrics.find(cm => cm.class === cls) || { precision: 0, recall: 0, f1: 0 };
                        return {
                            classId: cls,
                            label,
                            precision: m.precision,
                            recall: m.recall,
                            f1: m.f1
                        };
                    });

                    // 產生每一類別的 Precision / Recall / F1 列表
                    const metricsRowsHtml = metricsWithLabels.map(m => `
                <tr class="border-t">
                    <td class="px-3 py-1 text-gray-800">${m.label}</td>
                    <td class="px-3 py-1 text-right">${(m.precision * 100).toFixed(1)}%</td>
                    <td class="px-3 py-1 text-right">${(m.recall * 100).toFixed(1)}%</td>
                    <td class="px-3 py-1 text-right">${(m.f1 * 100).toFixed(1)}%</td>
                </tr>
            `).join('');

                    // 自動產生一段簡短的模型診斷說明
                    let summaryText = `整體準確度約為 ${(confusionResult.accuracy * 100).toFixed(1)}%，`;
                    if (metricsWithLabels.length > 0) {
                        const byRecall = [...metricsWithLabels].sort((a, b) => b.recall - a.recall);
                        const byPrecision = [...metricsWithLabels].sort((a, b) => b.precision - a.precision);
                        const bestRecall = byRecall[0];
                        const worstRecall = byRecall[byRecall.length - 1];
                        const bestPrec = byPrecision[0];
                        const worstPrec = byPrecision[byPrecision.length - 1];

                        summaryText += `平均 Precision 約為 ${(macroPrecision * 100).toFixed(1)}%，Recall 約為 ${(macroRecall * 100).toFixed(1)}%，F1 約為 ${(macroF1 * 100).toFixed(1)}%。`;
                        summaryText += ` 在召回率方面，「${bestRecall.label}」類別辨識最佳（${(bestRecall.recall * 100).toFixed(1)}%），`;
                        summaryText += `「${worstRecall.label}」較容易被漏判（${(worstRecall.recall * 100).toFixed(1)}%）。`;
                        summaryText += ` 在精確度方面，「${bestPrec.label}」預測最精準（${(bestPrec.precision * 100).toFixed(1)}%），`;
                        summaryText += `「${worstPrec.label}」則較常被誤判，建議檢視其樣本數與特徵分佈。`;
                    }

                    // 生成結果 HTML（混淆矩陣 + 指標表 + 特徵重要性）
                    let html = `
                <div class="bg-white p-6 rounded-lg border shadow-sm">
                    <h3 class="text-xl font-bold mb-4 text-green-700">🌲 隨機森林分類模型結果</h3>

                    <div class="bg-green-50 p-4 rounded mb-6">
                        <h4 class="font-semibold mb-2">📊 整體準確度</h4>
                        <p class="text-3xl font-bold text-green-700">${(confusionResult.accuracy * 100).toFixed(2)}%</p>
                        <p class="text-sm text-gray-600 mt-1">
                            訓練集準確度（${X.length} 筆樣本，${forest.uniqueClasses.length} 個類別）<br>
                            平均 Precision：${(macroPrecision * 100).toFixed(1)}%，
                            Recall：${(macroRecall * 100).toFixed(1)}%，
                            F1：${(macroF1 * 100).toFixed(1)}%
                        </p>
                    </div>

                    <div class="mb-6">
                        <h4 class="font-semibold mb-3">📉 混淆矩陣</h4>
                        <div id="rfClsConfusionPlot"></div>
                    </div>

                    <div class="mb-6">
                        <h4 class="font-semibold mb-2">📌 Precision / Recall / F1 指標</h4>
                        <div class="overflow-x-auto">
                            <table class="min-w-full text-sm border border-gray-200">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-3 py-2 text-left border-b">類別</th>
                                        <th class="px-3 py-2 text-right border-b">Precision</th>
                                        <th class="px-3 py-2 text-right border-b">Recall</th>
                                        <th class="px-3 py-2 text-right border-b">F1-score</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${metricsRowsHtml}
                                </tbody>
                            </table>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">＊上述指標為「訓練資料」上的表現，實務上建議另行切分驗證集或使用交叉驗證。</p>
                    </div>

                    <div class="mb-6">
                        <h4 class="font-semibold mb-2">📝 模型診斷摘要</h4>
                        <p class="text-sm text-gray-700 leading-relaxed">${summaryText}</p>
                    </div>

                    <div class="mb-6">
                        <h4 class="font-semibold mb-3">🔑 變數重要性排名</h4>
                        <div id="rfClsImportancePlot"></div>
                    </div>

                    <!-- Prediction Section -->
                    <div class="mt-6 p-4 bg-gray-50 rounded border border-gray-200">
                        <h4 class="text-md font-semibold mb-3">🔮 模型預測 (Prediction)</h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="rfClsPredictionInputs">
                            ${xVars.map((xVar, i) => {
                        if (categoricalHeaders.includes(xVar)) {
                            const options = Object.keys(encoders[xVar]).map(c => `<option value="${c}">${c}</option>`).join('');
                            return `
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700 mb-1">${xVar}</label>
                                            <select id="rf_cls_pred_input_${i}" class="w-full p-2 border rounded">
                                                ${options}
                                            </select>
                                        </div>
                                    `;
                        } else {
                            return `
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700 mb-1">${xVar}</label>
                                            <input type="number" id="rf_cls_pred_input_${i}" class="w-full p-2 border rounded" placeholder="輸入數值">
                                        </div>
                                    `;
                        }
                    }).join('')}
                        </div>
                        <button id="btnPredictRFCls" class="mt-4 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition">
                            進行預測
                        </button>
                        <div id="rfClsPredictionResult" class="mt-4 hidden p-3 bg-white border rounded"></div>
                    </div>
                </div>
            `;

                    resultsDiv.innerHTML = html;
                    progressSpan.textContent = '';

                    // Bind Prediction Event
                    document.getElementById('btnPredictRFCls').addEventListener('click', () => {
                        const resultDiv = document.getElementById('rfClsPredictionResult');
                        resultDiv.classList.remove('hidden');

                        try {
                            const inputVector = [];
                            for (let i = 0; i < xVars.length; i++) {
                                const xVar = xVars[i];
                                const el = document.getElementById(`rf_cls_pred_input_${i}`);
                                const val = el.value;

                                if (categoricalHeaders.includes(xVar)) {
                                    if (!(val in encoders[xVar])) throw new Error(`無效的類別值：${xVar}`);
                                    inputVector.push(encoders[xVar][val]);
                                } else {
                                    const numVal = parseFloat(val);
                                    if (isNaN(numVal)) throw new Error(`請輸入有效的數值：${xVar}`);
                                    inputVector.push(numVal);
                                }
                            }

                            // Manual Prediction with Probabilities
                            const treePredictions = forest.trees.map(treeObj => {
                                const { model, selectedFeatures } = treeObj;
                                const subset = selectedFeatures.map(idx => inputVector[idx]);
                                const pred = model.predict([subset])[0];
                                return Math.round(pred);
                            });

                            const counts = {};
                            forest.uniqueClasses.forEach(cls => counts[cls] = 0);
                            treePredictions.forEach(p => {
                                if (counts[p] !== undefined) counts[p]++;
                            });

                            const totalTrees = forest.trees.length;
                            const probs = forest.uniqueClasses.map(cls => ({
                                classId: cls,
                                label: Object.keys(yEncoder).find(k => yEncoder[k] === cls) || cls,
                                prob: counts[cls] / totalTrees
                            }));

                            // Find majority
                            const best = probs.reduce((prev, current) => (prev.prob > current.prob) ? prev : current);

                            const probList = probs.map(p => {
                                const pct = (p.prob * 100).toFixed(2);
                                const barColor = p.classId === best.classId ? 'bg-green-600' : 'bg-gray-300';
                                return `
                                    <div class="mb-2">
                                        <div class="flex justify-between text-sm mb-1">
                                            <span>${p.label}</span>
                                            <span>${pct}%</span>
                                        </div>
                                        <div class="w-full bg-gray-200 rounded-full h-2.5">
                                            <div class="${barColor} h-2.5 rounded-full" style="width: ${pct}%"></div>
                                        </div>
                                    </div>
                                `;
                            }).join('');

                            resultDiv.innerHTML = `
                                <h5 class="font-semibold mb-2">預測結果：<span class="text-green-700">${best.label}</span></h5>
                                <div class="mt-2">
                                    ${probList}
                                </div>
                            `;

                        } catch (e) {
                            resultDiv.innerHTML = `<p class="text-red-600">錯誤：${e.message}</p>`;
                        }
                    });

                    // 繪製混淆矩陣熱圖
                    Plotly.newPlot('rfClsConfusionPlot', [{
                        z: confusionResult.matrix,
                        x: classLabels,
                        y: classLabels,
                        type: 'heatmap',
                        colorscale: 'Blues',
                        text: confusionResult.matrix,
                        texttemplate: '%{text}',
                        textfont: { size: 14 }
                    }], {
                        title: '混淆矩陣',
                        xaxis: { title: '預測類別' },
                        yaxis: { title: '實際類別' }
                    }, { responsive: true });

                    // 繪製特徵重要性
                    Plotly.newPlot('rfClsImportancePlot', [{
                        x: importances.map(imp => imp.importance).reverse(),
                        y: importances.map(imp => imp.feature).reverse(),
                        type: 'bar',
                        orientation: 'h',
                        marker: { color: '#10b981' }
                    }], {
                        title: '變數重要性',
                        xaxis: { title: '重要性 (Importance)' },
                        margin: { l: 150, t: 20, b: 20 }
                    }, { responsive: true });

                } catch (err) {
                    resultsDiv.innerHTML = `<p class="text-red-600">訓練時發生錯誤：${err.message}</p>`;
                    console.error(err);
                    progressSpan.textContent = '';
                }
            }, 100);
        }



        console.log('✅ 隨機森林主函數載入完成！');


        function setupEventListeners() {
            document.getElementById('fileInput').addEventListener('change', () => {
                const fileInput = document.getElementById('fileInput');
                const loadDataBtn = document.getElementById('loadDataBtn');
                if (fileInput.files.length > 0) {
                    // 切換回 Excel 檔案模式並啟用載入按鈕
                    setInputMode('file');
                    loadDataBtn.disabled = false;
                } else {
                    loadDataBtn.disabled = true;
                }
            });

            document.getElementById('loadDataBtn').addEventListener('click', handleFileUpload);

            // 載入範例資料按鈕
            const loadExampleBtn = document.getElementById('loadExampleBtn');
            if (loadExampleBtn) {
                loadExampleBtn.addEventListener('click', async () => {
                    try {
                        // 顯示載入指示器
                        document.getElementById('loadingIndicator').classList.remove('hidden');
                        document.getElementById('mainContent').classList.add('hidden');

                        // 使用 fetch 載入 Example.xlsx
                        const response = await fetch('Example.xlsx');
                        if (!response.ok) throw new Error('無法載入範例檔案');

                        const arrayBuffer = await response.arrayBuffer();
                        const data = new Uint8Array(arrayBuffer);

                        // 使用 XLSX 讀取檔案
                        currentWorkbook = XLSX.read(data, { type: 'array', cellDates: true });
                        const sheetNames = currentWorkbook.SheetNames || [];

                        // 更新工作表選擇器
                        const sheetSelectorContainer = document.getElementById('sheetSelectorContainer');
                        const sheetSelector = document.getElementById('sheetSelector');
                        if (sheetSelector) {
                            sheetSelector.innerHTML = '';
                            sheetNames.forEach((name, idx) => {
                                const opt = document.createElement('option');
                                opt.value = name;
                                opt.textContent = `${idx + 1}. ${name}`;
                                sheetSelector.appendChild(opt);
                            });
                        }
                        if (sheetSelectorContainer) {
                            sheetSelectorContainer.classList.remove('hidden');
                        }

                        if (sheetNames.length === 0) {
                            throw new Error("範例檔案中找不到任何工作表。");
                        } else if (sheetNames.length === 1) {
                            // 只有一個工作表，自動載入
                            const firstSheetName = sheetNames[0];
                            const sheet = currentWorkbook.Sheets[firstSheetName];
                            jsonData = XLSX.utils.sheet_to_json(sheet, { defval: null });
                            if (jsonData.length === 0) throw new Error("範例工作表是空的或格式不正確。");
                            processData();
                        } else {
                            // 多個工作表，等待用戶選擇
                            alert('已載入範例資料，請選擇要匯入的工作表並按「確認匯入」。');
                        }

                        // 切換到 Excel 檔案模式
                        setInputMode('file');

                    } catch (error) {
                        alert(`載入範例資料失敗: ${error.message}`);
                        resetUI();
                    } finally {
                        document.getElementById('loadingIndicator').classList.add('hidden');
                    }
                });
            }


            // 資料輸入方式切換按鈕
            const inputModeFileBtn = document.getElementById('inputModeFileBtn');
            const inputModePasteBtn = document.getElementById('inputModePasteBtn');
            if (inputModeFileBtn && inputModePasteBtn) {
                inputModeFileBtn.addEventListener('click', () => setInputMode('file'));
                inputModePasteBtn.addEventListener('click', () => setInputMode('paste'));
            }

            // Copy & Paste 匯入按鈕
            const pasteLoadBtn = document.getElementById('pasteLoadBtn');
            if (pasteLoadBtn) {
                pasteLoadBtn.addEventListener('click', handlePasteInput);
            }

            const confirmSheetBtn = document.getElementById('confirmSheetBtn');
            if (confirmSheetBtn) {
                confirmSheetBtn.addEventListener('click', handleSheetSelection);
            }
            document.querySelectorAll('.tab-button').forEach(button =>
                button.addEventListener('click', e => switchTab(button, '.tab-button', '.tab-content', 'data-tab')));
            document.querySelectorAll('.ml-tab-button').forEach(button =>
                button.addEventListener('click', e => switchTab(button, '.ml-tab-button', '.ml-tab-content', 'data-ml-tab')));
            document.querySelectorAll('.basic-tab-button').forEach(button =>
                button.addEventListener('click', e => switchTab(button, '.basic-tab-button', '.basic-tab-content', 'data-basic-tab')));

            // 時間序列預測子功能切換
            document.querySelectorAll('.forecast-tab-button').forEach(button =>
                button.addEventListener('click', e => switchTab(button, '.forecast-tab-button', '.forecast-tab-content', 'data-forecast-tab')));

            document.getElementById('runParetoBtn').addEventListener('click', runPareto);
            document.getElementById('runTTestBtn').addEventListener('click', runAnovaStyleTest);
            document.getElementById('runRegressionBtn').addEventListener('click', runRegression);
            document.getElementById('runMultipleRegressionBtn').addEventListener('click', runMultipleRegression);
            document.getElementById('runForecastBtn').addEventListener('click', runForecast);

            const runProphetBtn = document.getElementById('runProphetBtn');
            if (runProphetBtn) {
                runProphetBtn.addEventListener('click', runProphetForecast);
            }
            const runArimaBtn = document.getElementById('runArimaBtn');
            if (runArimaBtn) {
                runArimaBtn.addEventListener('click', runArimaForecast);
            }
            const runCrostonBtn = document.getElementById('runCrostonBtn');
            if (runCrostonBtn) {
                runCrostonBtn.addEventListener('click', runCrostonForecast);
            }
            document.getElementById('runLogisticBtn').addEventListener('click', runLogistic);
            document.getElementById('runDtBtn').addEventListener('click', runDecisionTree);
            document.getElementById('runCorrelationMatrixBtn').addEventListener('click', runCorrelationMatrix);
            document.getElementById('runPcaBtn').addEventListener('click', runPCA);
            document.getElementById('runFaBtn').addEventListener('click', runFactorAnalysis);
            document.getElementById('runChiSquareBtn').addEventListener('click', runChiSquareTest);
            document.getElementById('runKmeansElbowBtn').addEventListener('click', runKmeansElbow);
            document.getElementById('runKmeansBtn').addEventListener('click', runKmeansClustering);
            document.getElementById('runAprioriBtn').addEventListener('click', runAprioriAnalysis);
            document.getElementById('runOutlierBtn').addEventListener('click', runOutlierDetection);
            const runWordcloudBtn = document.getElementById('runWordcloudBtn');
            if (runWordcloudBtn) {
                runWordcloudBtn.addEventListener('click', runWordcloud);
            }

            // 隨機森林事件監聽器
            document.getElementById('runRFRegressionBtn')?.addEventListener('click', runRandomForestRegression);
            document.getElementById('runRFClassificationBtn')?.addEventListener('click', runRandomForestClassification);

            document.getElementById('runHierarchicalBtn').addEventListener('click', runHierarchical);

            const hierClusterSlider = document.getElementById('hierClusterCount');
            if (hierClusterSlider) {
                hierClusterSlider.addEventListener('input', () => {
                    const k = parseInt(hierClusterSlider.value, 10);
                    document.getElementById('hierClusterCountLabel').textContent = k.toString();
                    if (hierarchicalState) {
                        updateHierarchicalClusterViews(k);
                    }
                });
            }

            // Add event listener for dynamic X variable filtering in Decision Tree
            document.getElementById('dtY').addEventListener('change', updateDtXOptions);

            // 初始化資料輸入模式（預設為 Excel 檔案上傳）
            // Also sync the initial active top-tab to the analysisContent wrapper
            const initiallyActiveTop = document.querySelector('.tab-button.active');
            if (initiallyActiveTop) {
                const initialTabName = initiallyActiveTop.getAttribute('data-tab');
                const analysisWrapperInit = document.getElementById('analysisContent');
                if (analysisWrapperInit) {
                    analysisWrapperInit.classList.add('active-tab-' + initialTabName);
                }
            }
            setInputMode('file');
        }

        function switchTab(clickedButton, buttonClass, contentClass, dataAttribute) {
            document.querySelectorAll(buttonClass).forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll(contentClass).forEach(content => content.classList.add('hidden'));
            clickedButton.classList.add('active');
            const tabName = clickedButton.getAttribute(dataAttribute);
            document.getElementById(tabName + 'Content').classList.remove('hidden');
            // Only update the analysisContent color class when switching top-level tabs
            if (dataAttribute === 'data-tab') {
                const analysisWrapper = document.getElementById('analysisContent');
                if (analysisWrapper) {
                    analysisWrapper.classList.remove('active-tab-eda', 'active-tab-basic', 'active-tab-forecast', 'active-tab-ml');
                    if (['eda', 'basic', 'forecast', 'ml'].includes(tabName)) {
                        analysisWrapper.classList.add('active-tab-' + tabName);
                    }
                }
            }
        }

        // --- Core Data Handling ---
        function handleFileUpload() {
            const file = document.getElementById('fileInput').files[0];
            if (!file) { alert('請先選擇一個 Excel 檔案'); return; }
            document.getElementById('loadingIndicator').classList.remove('hidden');
            document.getElementById('mainContent').classList.add('hidden');

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    currentWorkbook = XLSX.read(data, { type: 'array', cellDates: true });
                    const sheetNames = currentWorkbook.SheetNames || [];

                    const sheetSelectorContainer = document.getElementById('sheetSelectorContainer');
                    const sheetSelector = document.getElementById('sheetSelector');
                    if (sheetSelector) {
                        sheetSelector.innerHTML = '';
                        sheetNames.forEach((name, idx) => {
                            const opt = document.createElement('option');
                            opt.value = name;
                            opt.textContent = `${idx + 1}. ${name}`;
                            sheetSelector.appendChild(opt);
                        });
                    }
                    if (sheetSelectorContainer) {
                        sheetSelectorContainer.classList.remove('hidden');
                    }

                    if (sheetNames.length === 0) {
                        throw new Error("找不到任何工作表，請確認 Excel 檔案內容。");
                    } else if (sheetNames.length === 1) {
                        const firstSheetName = sheetNames[0];
                        const sheet = currentWorkbook.Sheets[firstSheetName];
                        jsonData = XLSX.utils.sheet_to_json(sheet, { defval: null });
                        if (jsonData.length === 0) throw new Error("選取的工作表是空的或格式不正確。");
                        processData();
                    } else {
                        // 偵測到多個工作表：下方下拉選單已列出可選工作表，這裡不再彈出提醒，以維持流暢的 UI/UX。
                    }
                } catch (error) {
                    alert(`檔案處理失敗: ${error.message}`);
                    resetUI();
                } finally {
                    document.getElementById('loadingIndicator').classList.add('hidden');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function handleSheetSelection() {
            if (!currentWorkbook) {
                alert('請先選擇並載入 Excel 檔案');
                return;
            }
            const sheetSelector = document.getElementById('sheetSelector');
            if (!sheetSelector || !sheetSelector.value) {
                alert('請先選擇要匯入的工作表');
                return;
            }
            const sheetName = sheetSelector.value;
            try {
                document.getElementById('loadingIndicator').classList.remove('hidden');
                const sheet = currentWorkbook.Sheets[sheetName];
                if (!sheet) throw new Error('找不到選取的工作表。');
                jsonData = XLSX.utils.sheet_to_json(sheet, { defval: null });
                if (jsonData.length === 0) throw new Error('選取的工作表是空的或格式不正確。');
                processData();
            } catch (error) {
                alert(`匯入工作表失敗: ${error.message}`);
                resetUI();
            } finally {
                document.getElementById('loadingIndicator').classList.add('hidden');
            }
        }

        // --- Copy & Paste 資料匯入相關函式 ---
        function parsePastedData(rawText, delimiterMode) {
            if (!rawText || !rawText.trim()) {
                throw new Error('貼上的內容為空，請確認是否已從 Excel 或 CSV 複製資料。');
            }

            const lines = rawText
                .split(/\r?\n/)
                .map(line => line.trimEnd())
                .filter(line => line.length > 0);

            if (lines.length < 2) {
                throw new Error('請至少包含一列欄位名稱與一列資料。');
            }

            // 判斷分隔符號
            let delimiter = '\t';
            if (delimiterMode === 'tab') {
                delimiter = '\t';
            } else if (delimiterMode === 'comma') {
                delimiter = ',';
            } else if (delimiterMode === 'semicolon') {
                delimiter = ';';
            } else {
                // auto 模式：依欄位名稱列自動判斷
                const headerLine = lines[0];
                if (headerLine.indexOf('\t') !== -1) {
                    delimiter = '\t';
                } else if (headerLine.indexOf(',') !== -1) {
                    delimiter = ',';
                } else if (headerLine.indexOf(';') !== -1) {
                    delimiter = ';';
                } else {
                    // 回退策略：以任何連續空白當作分隔
                    delimiter = /\s+/;
                }
            }

            const splitLine = (line) => {
                return typeof delimiter === 'string'
                    ? line.split(delimiter)
                    : line.trim().split(delimiter);
            };

            const headerCells = splitLine(lines[0]).map(h => h.trim());
            const colCount = headerCells.length;
            if (colCount === 0) {
                throw new Error('無法解析欄位名稱列，請確認資料格式。');
            }

            const tryParseValue = (v) => {
                if (v === null || v === undefined) return null;
                const s = String(v).trim();
                if (s === '') return null;

                // 嘗試解析為數值
                const num = Number(s);
                if (!isNaN(num)) return num;

                // 嘗試解析為日期
                const date = new Date(s);
                if (!isNaN(date.getTime())) return date;

                // 回傳原始字串
                return s;
            };

            const records = [];
            for (let i = 1; i < lines.length; i++) {
                const cells = splitLine(lines[i]);
                if (cells.length === 1 && cells[0].trim() === '') continue;
                const rowObj = {};
                for (let c = 0; c < colCount; c++) {
                    const key = headerCells[c] || `欄位_${c + 1}`;
                    const value = c < cells.length ? tryParseValue(cells[c]) : null;
                    rowObj[key] = value;
                }
                records.push(rowObj);
            }

            if (records.length === 0) {
                throw new Error('無法從貼上的內容解析出有效資料列。');
            }

            return {
                data: records,
                headers: headerCells
            };
        }

        function handlePasteInput() {
            const textarea = document.getElementById('pasteTextarea');
            if (!textarea) {
                alert('找不到貼上輸入區塊，請重新整理頁面。');
                return;
            }

            const rawText = textarea.value;
            const delimiterInput = document.querySelector('input[name="pasteDelimiter"]:checked');
            const delimiterMode = delimiterInput ? delimiterInput.value : 'auto';

            try {
                document.getElementById('loadingIndicator').classList.remove('hidden');

                const parsed = parsePastedData(rawText, delimiterMode);
                jsonData = parsed.data;

                if (!jsonData || jsonData.length === 0) {
                    throw new Error('解析後的資料為空，請確認貼上的內容格式。');
                }

                // 更新檔名顯示
                const fileNameDisplay = document.getElementById('fileName');
                if (fileNameDisplay) {
                    fileNameDisplay.textContent = `已從貼上的資料匯入：${jsonData.length} 筆記錄，${Object.keys(jsonData[0] || {}).length} 個欄位。`;
                }

                // 清空檔案與工作表相關 UI（避免誤解）
                const fileInput = document.getElementById('fileInput');
                const sheetSelectorContainer = document.getElementById('sheetSelectorContainer');
                const sheetSelector = document.getElementById('sheetSelector');
                const loadDataBtn = document.getElementById('loadDataBtn');

                if (fileInput) fileInput.value = '';
                if (loadDataBtn) loadDataBtn.disabled = true;
                if (sheetSelectorContainer) sheetSelectorContainer.classList.add('hidden');
                if (sheetSelector) sheetSelector.innerHTML = '';

                processData();
            } catch (error) {
                alert(`貼上資料處理失敗: ${error.message}`);
                console.error(error);
            } finally {
                document.getElementById('loadingIndicator').classList.add('hidden');
            }
        }

        function setInputMode(mode) {
            currentInputMode = mode === 'paste' ? 'paste' : 'file';

            const excelArea = document.getElementById('excelInputArea');
            const pasteArea = document.getElementById('pasteInputArea');
            const fileBtn = document.getElementById('inputModeFileBtn');
            const pasteBtn = document.getElementById('inputModePasteBtn');

            if (excelArea && pasteArea && fileBtn && pasteBtn) {
                if (currentInputMode === 'file') {
                    excelArea.classList.remove('hidden');
                    pasteArea.classList.add('hidden');

                    fileBtn.classList.add('bg-blue-50', 'text-blue-700', 'border-blue-500', 'shadow-sm');
                    fileBtn.classList.remove('text-gray-600', 'border-gray-300');

                    pasteBtn.classList.remove('bg-blue-50', 'text-blue-700', 'border-blue-500', 'shadow-sm');
                    pasteBtn.classList.add('text-gray-600', 'border-gray-300');
                } else {
                    excelArea.classList.add('hidden');
                    pasteArea.classList.remove('hidden');

                    pasteBtn.classList.add('bg-blue-50', 'text-blue-700', 'border-blue-500', 'shadow-sm');
                    pasteBtn.classList.remove('text-gray-600', 'border-gray-300');

                    fileBtn.classList.remove('bg-blue-50', 'text-blue-700', 'border-blue-500', 'shadow-sm');
                    fileBtn.classList.add('text-gray-600', 'border-gray-300');
                }
            }
        }




        function clearAllOutputs() {
            const outputIds = [
                'edaResults', 'paretoResults', 'tTestResults', 'regressionResults',
                'forecastResults', 'logisticResults', 'dtResults', 'correlationMatrixResults',
                'chiSquareResults', 'kmeansResults', 'hierarchicalResults', 'aprioriResults',
                'outlierResults', 'pcaResults', 'faResults', 'rfRegressionResults', 'rfClassificationResults',
                'wordcloudContainer', 'prophetResults', 'arimaResults', 'crostonResults'
            ];
            outputIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.innerHTML = '';
            });
            const dataPreview = document.getElementById('dataPreview');
            if (dataPreview) dataPreview.innerHTML = '';
            logisticModel = null;
            hierarchicalState = null;
        }

        function processData() {

            clearAllOutputs();
            headers = Object.keys(jsonData[0]);
            classifyHeaders();
            displayDataPreview();
            populateSelects();
            document.getElementById('mainContent').classList.remove('hidden');
            runEDA();
        }

        function resetUI() {
            document.getElementById('mainContent').classList.add('hidden');
            document.getElementById('loadDataBtn').disabled = true;
            document.getElementById('fileInput').value = '';
            document.getElementById('fileName').textContent = '';
            jsonData = [];
            headers = [];
            numericHeaders = [];
            categoricalHeaders = [];
            currentWorkbook = null;
            clearAllOutputs();
            const sheetSelectorContainer = document.getElementById('sheetSelectorContainer');
            const sheetSelector = document.getElementById('sheetSelector');
            if (sheetSelectorContainer) sheetSelectorContainer.classList.add('hidden');
            if (sheetSelector) sheetSelector.innerHTML = '';
        }

        function classifyHeaders() {
            numericHeaders = [];
            categoricalHeaders = [];
            headers.forEach(header => {
                const sampleRows = jsonData.slice(0, 50);
                const values = sampleRows
                    .map(row => row[header])
                    .filter(v => v !== null && v !== undefined && v !== '');
                if (values.length === 0) return;

                const isDate = sampleRows.some(row => row[header] instanceof Date);
                const allNumbers = values.every(v => typeof v === 'number' && !isNaN(v));

                if (allNumbers && !isDate) {
                    numericHeaders.push(header);
                    const uniqueValues = [...new Set(values)];
                    const allIntegers = uniqueValues.every(v => Number.isInteger(v));
                    if (allIntegers && uniqueValues.length > 1 && uniqueValues.length <= 10) {
                        if (!categoricalHeaders.includes(header)) {
                            categoricalHeaders.push(header);
                        }
                    }
                } else {
                    if (!categoricalHeaders.includes(header)) {
                        categoricalHeaders.push(header);
                    }
                }
            });
        }

        function displayDataPreview() {
            const previewDiv = document.getElementById('dataPreview');
            // Modern Table Styling
            let tableHTML = `
                <div class="border border-gray-200 rounded-lg overflow-hidden shadow-sm">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50 sticky top-0 z-10">
                            <tr>`;
            headers.forEach(h => tableHTML += `<th class="px-6 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider whitespace-nowrap bg-gray-50 border-b border-gray-200">${h}</th>`);
            tableHTML += `  </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">`;

            jsonData.slice(0, 50).forEach((row, index) => {
                const bgClass = index % 2 === 0 ? 'bg-white' : 'bg-gray-50/50'; // Subtle striping
                tableHTML += `<tr class="${bgClass} hover:bg-blue-50 transition-colors duration-150">`;
                headers.forEach(h => {
                    let cellValue = row[h];
                    if (cellValue instanceof Date) cellValue = cellValue.toLocaleDateString();
                    // Check if value is number for alignment
                    const alignClass = (typeof cellValue === 'number') ? 'text-right font-mono' : 'text-left';
                    tableHTML += `<td class="px-6 py-3 whitespace-nowrap text-sm text-gray-700 ${alignClass}">${cellValue != null ? cellValue : '<span class="text-gray-300 italic">N/A</span>'}</td>`;
                });
                tableHTML += `</tr>`;
            });
            tableHTML += `</tbody></table></div>`;

            // Add a footer note
            tableHTML += `<div class="mt-2 text-xs text-gray-500 text-right">顯示前 50 筆資料預覽</div>`;

            previewDiv.innerHTML = tableHTML;
        }

        function populateSelects() {
            const binaryCategoricalHeaders = headers.filter(h => {
                const uniqueValues = [...new Set(jsonData.map(row => row[h]).filter(v => v != null))];
                return uniqueValues.length === 2;
            });

            const selects = [
                { id: 'paretoCategoryVar', headers: categoricalHeaders },
                { id: 'paretoValueVar', headers: numericHeaders },
                { id: 'tTestCategoricalVar', headers: categoricalHeaders },
                { id: 'tTestNumericalVar', headers: numericHeaders },
                { id: 'regressionX', headers: numericHeaders },
                { id: 'regressionY', headers: numericHeaders },
                { id: 'multipleRegressionX', headers: numericHeaders },
                { id: 'multipleRegressionY', headers: numericHeaders },
                { id: 'forecastTimeVar', headers: headers },
                { id: 'forecastValueVar', headers: numericHeaders },
                { id: 'prophetTimeVar', headers: headers },
                { id: 'prophetValueVar', headers: numericHeaders },
                { id: 'arimaTimeVar', headers: headers },
                { id: 'arimaValueVar', headers: numericHeaders },
                { id: 'crostonTimeVar', headers: headers },
                { id: 'crostonValueVar', headers: numericHeaders },
                { id: 'logisticY', headers: binaryCategoricalHeaders },
                { id: 'logisticX', headers: numericHeaders },
                { id: 'dtY', headers: numericHeaders }, // Decision Tree Y is now numeric
                { id: 'dtX', headers: headers },
                { id: 'pcaVariables', headers: numericHeaders },
                { id: 'faVariables', headers: numericHeaders },
                { id: 'chiSquareVar1', headers: categoricalHeaders },
                { id: 'chiSquareVar2', headers: categoricalHeaders },
                { id: 'kmeansVariables', headers: numericHeaders },
                { id: 'hierVariables', headers: headers },         // 新增：階層式集群可選所有欄位
                { id: 'aprioriTransactionId', headers: headers },
                { id: 'aprioriItemName', headers: headers },
                { id: 'outlierVariable', headers: numericHeaders },
                { id: 'rfRegY', headers: numericHeaders },
                { id: 'rfRegX', headers: headers },
                { id: 'rfClsY', headers: categoricalHeaders },
                { id: 'rfClsX', headers: headers },
                { id: 'nnY', headers: headers },
                { id: 'nnX', headers: headers }
            ];
            selects.forEach(s => {
                const selectEl = document.getElementById(s.id);
                if (!selectEl) return;
                selectEl.innerHTML = selectEl.multiple ? '' : '<option value="">請選擇欄位</option>';
                s.headers.forEach(header => {
                    const option = document.createElement('option');
                    option.value = header, option.textContent = header;
                    selectEl.appendChild(option);
                });
            });

            // 文字雲欄位選擇：優先使用類別/文字欄位，若無則退回全部欄位
            const wcSelect = document.getElementById('wordcloudTextColumn');
            if (wcSelect) {
                wcSelect.innerHTML = '<option value="">請選擇欄位</option>';
                const textHeaders = (categoricalHeaders && categoricalHeaders.length > 0)
                    ? categoricalHeaders
                    : headers;
                textHeaders.forEach(h => {
                    const opt = document.createElement('option');
                    opt.value = h;
                    opt.textContent = h;
                    wcSelect.appendChild(opt);
                });
            }

            updateDtXOptions(); // Initial call
        }

        function updateDtXOptions() {
            const yVar = document.getElementById('dtY').value;
            const xSelect = document.getElementById('dtX');
            const currentX = Array.from(xSelect.selectedOptions).map(opt => opt.value);

            xSelect.innerHTML = '';
            headers.forEach(header => {
                if (header !== yVar) {
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    if (currentX.includes(header)) {
                        option.selected = true;
                    }
                    xSelect.appendChild(option);
                }
            });
        }



        function runWordcloud() {
            // 移除舊的下載按鈕事件監聽器，避免重複
            const oldBtn = document.getElementById('downloadWordcloudBtn');
            if (oldBtn) {
                const newBtn = oldBtn.cloneNode(true);
                oldBtn.parentNode.replaceChild(newBtn, oldBtn);
                newBtn.disabled = true;
            }
            if (!jsonData || jsonData.length === 0) {
                alert('請先載入資料');
                return;
            }
            const colSelect = document.getElementById('wordcloudTextColumn');
            if (!colSelect) {
                alert('找不到文字雲欄位選擇元件');
                return;
            }
            const col = colSelect.value;
            if (!col) {
                alert('請先選擇文字欄位');
                return;
            }

            const minFreq = parseInt(document.getElementById('wordcloudMinFreq').value) || 1;
            const maxWords = parseInt(document.getElementById('wordcloudMaxWords').value) || 60;
            const container = document.getElementById('wordcloudContainer');
            if (!container) return;
            container.innerHTML = '';
            container.style.position = 'relative';

            // 1. 統計詞頻
            const freqMap = {};
            jsonData.forEach(row => {
                const val = row[col];
                if (val === null || val === undefined) return;
                const text = String(val).toLowerCase();
                const tokens = text.split(/[\s,;，。\.\!！\?？:：;、]+/);
                tokens.forEach(tok => {
                    const w = tok.trim();
                    if (!w) return;
                    if (w.length <= 1) return; // 若要保留單一字元，可註解此行
                    freqMap[w] = (freqMap[w] || 0) + 1;
                });
            });

            let entries = Object.entries(freqMap)
                .filter(([w, c]) => c >= minFreq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, maxWords);

            if (entries.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-500">沒有符合條件的文字，請調整欄位或門檻。</p>';
                return;
            }

            // 2. 準備畫布與測量工具
            const rect = container.getBoundingClientRect();
            const cx = (rect.width || container.clientWidth || 400) / 2;
            const cy = (rect.height || container.clientHeight || 300) / 2;

            // 建立隱藏 Canvas 用於測量文字大小
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const counts = entries.map(e => e[1]);
            const minC = Math.min.apply(null, counts);
            const maxC = Math.max.apply(null, counts);
            const range = maxC - minC || 1;

            const placedWords = []; // {x, y, width, height, right, bottom}

            // 輔助函式：檢查碰撞
            function checkCollision(box) {
                for (let i = 0; i < placedWords.length; i++) {
                    const other = placedWords[i];
                    if (!(box.right < other.x ||
                        box.x > other.right ||
                        box.bottom < other.y ||
                        box.y > other.bottom)) {
                        return true;
                    }
                }
                return false;
            }

            // 3. 螺旋排布 + 碰撞檢測
            entries.forEach(([word, count], index) => {
                const norm = (count - minC) / range; // 0 = 低頻, 1 = 高頻

                // 字體大小與樣式計算 (保持原邏輯)
                const minFont = 16;
                const maxFont = 48;
                const fontSize = minFont + norm * (maxFont - minFont);

                let fontWeight = '400';
                if (norm > 0.7) fontWeight = '900';
                else if (norm > 0.4) fontWeight = '700';
                else if (norm > 0.1) fontWeight = '500';

                // 顏色計算 (保持原邏輯)
                let hue;
                if (norm > 0.6) {
                    const t = (norm - 0.6) / 0.4;
                    hue = 30 - t * 30; // 30 (橘) -> 0 (紅)
                } else if (norm > 0.3) {
                    const t = (norm - 0.3) / 0.3;
                    hue = 30 + t * (240 - 30); // 30 -> 240
                } else {
                    const t = norm / 0.3;
                    hue = 240 - t * (240 - 120); // 240 (藍) -> 120 (綠)
                }
                const sat = 75;
                const light = 50 + norm * 10;
                const color = `hsl(${hue}, ${sat}%, ${light}%)`;

                // 測量文字尺寸
                ctx.font = `${fontWeight} ${fontSize}px Inter, "Noto Sans TC", sans-serif`;
                const metrics = ctx.measureText(word);
                const textWidth = metrics.width;
                const textHeight = fontSize * 1.2; // 估算高度

                // 螺旋搜尋位置
                let angle = 0;
                let radius = 0;
                const angleStep = 0.2; // 角度增量
                const radiusStep = 5;  // 半徑參數 (b in r = a + b*theta)

                // 第一個字直接放中間
                if (index === 0) {
                    const box = {
                        x: cx - textWidth / 2,
                        y: cy - textHeight / 2,
                        width: textWidth,
                        height: textHeight,
                        right: cx + textWidth / 2,
                        bottom: cy + textHeight / 2
                    };
                    placedWords.push(box);
                    createWordSpan(word, box.x, box.y, fontSize, fontWeight, color, norm);
                    return;
                }

                // 其他字螺旋尋找
                let found = false;
                // 限制最大嘗試次數以防無限迴圈
                const maxIter = 2000;
                for (let i = 0; i < maxIter; i++) {
                    // 阿基米德螺旋
                    radius = radiusStep * angle;

                    const x = cx + radius * Math.cos(angle) - textWidth / 2;
                    const y = cy + radius * Math.sin(angle) - textHeight / 2;

                    const box = {
                        x: x,
                        y: y,
                        width: textWidth,
                        height: textHeight,
                        right: x + textWidth,
                        bottom: y + textHeight
                    };

                    if (!checkCollision(box)) {
                        placedWords.push(box);
                        createWordSpan(word, x, y, fontSize, fontWeight, color, norm);
                        found = true;
                        break;
                    }

                    angle += angleStep;
                }

                if (!found) {
                    console.warn(`無法放置文字: ${word} (空間不足或嘗試次數過多)`);
                }
            });

            function createWordSpan(text, x, y, fontSize, fontWeight, color, norm) {
                const span = document.createElement('span');
                span.textContent = text;
                span.className = 'wordcloud-word';
                span.style.position = 'absolute';
                span.style.fontSize = fontSize + 'px';
                span.style.fontWeight = fontWeight;
                span.style.left = x + 'px';
                span.style.top = y + 'px';
                span.style.color = color;
                span.style.zIndex = 10 + Math.round(norm * 90);
                span.style.whiteSpace = 'nowrap';
                span.style.lineHeight = '1.2';
                container.appendChild(span);
            }

            // 4. 啟用下載功能
            const downloadBtn = document.getElementById('downloadWordcloudBtn');
            if (downloadBtn) {
                downloadBtn.disabled = false;
                downloadBtn.addEventListener('click', downloadWordcloud);
            }
        }

        function downloadWordcloud() {
            const container = document.getElementById('wordcloudContainer');
            if (!container) return;

            // 使用 html2canvas 渲染文字雲容器
            html2canvas(container, {
                scale: 2, // 提高解析度
                backgroundColor: '#ffffff', // 設定背景為白色
                useCORS: true,
                allowTaint: true,
            }).then(canvas => {
                // 轉換為 PNG 圖片
                const image = canvas.toDataURL('image/png');

                // 建立下載連結
                const link = document.createElement('a');
                link.href = image;
                link.download = 'wordcloud_analysis.png';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }).catch(error => {
                console.error('文字雲下載失敗:', error);
                alert('文字雲下載失敗，請檢查瀏覽器控制台。');
            });
        }


        // --- Analysis Functions ---

        // --- Enhanced EDA Helper Functions ---

        function renderNumericDistribution(plotId, values, header) {
            const traceViolin = {
                type: 'violin',
                x: values,
                points: 'all',
                box: { visible: true },
                line: { color: 'black' },
                fillcolor: '#8dd3c7',
                opacity: 0.6,
                meanline: { visible: true },
                name: header,
                jitter: 0.05,
                pointpos: -1.8
            };

            const layout = {
                title: {
                    text: `${header} 分佈詳情 (Violin + Box)`,
                    font: { size: 16, color: '#333' }
                },
                xaxis: { title: header, zeroline: false },
                yaxis: { title: '密度/頻率', zeroline: false },
                margin: { t: 50, b: 40, l: 60, r: 20 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                showlegend: false,
                hovermode: 'closest'
            };

            Plotly.newPlot(plotId, [traceViolin], layout, { responsive: true, displayModeBar: false });
        }

        function renderCategoricalDistribution(plotId, counts, header) {
            const labels = Object.keys(counts);
            const values = Object.values(counts);

            // Sort by count descending
            const sortedIndices = values.map((v, i) => i).sort((a, b) => values[b] - values[a]);
            const sortedLabels = sortedIndices.map(i => labels[i]);
            const sortedValues = sortedIndices.map(i => values[i]);

            // Decide between Bar and Donut based on category count
            let data = [];
            let layout = {};

            if (labels.length <= 5) {
                // Donut Chart for few categories
                data = [{
                    values: sortedValues,
                    labels: sortedLabels,
                    type: 'pie',
                    hole: 0.4,
                    textinfo: 'label+percent',
                    textposition: 'outside',
                    automargin: true,
                    marker: {
                        colors: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd']
                    }
                }];
                layout = {
                    title: { text: `${header} 類別佔比`, font: { size: 16 } },
                    showlegend: true,
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    margin: { t: 50, b: 20, l: 20, r: 20 }
                };
            } else {
                // Bar Chart for many categories
                data = [{
                    x: sortedLabels,
                    y: sortedValues,
                    type: 'bar',
                    marker: {
                        color: sortedValues,
                        colorscale: 'Viridis',
                        showscale: false
                    }
                }];
                layout = {
                    title: { text: `${header} 類別計數`, font: { size: 16 } },
                    xaxis: { title: header, tickangle: -45 },
                    yaxis: { title: '數量' },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    margin: { t: 50, b: 60, l: 60, r: 20 }
                };
            }

            Plotly.newPlot(plotId, data, layout, { responsive: true, displayModeBar: false });
        }

        function renderCorrelationHeatmap(containerId, data, headers) {
            if (headers.length < 2) return;

            // Calculate correlation matrix
            const matrix = [];
            for (let i = 0; i < headers.length; i++) {
                matrix[i] = [];
                for (let j = 0; j < headers.length; j++) {
                    if (i === j) {
                        matrix[i][j] = 1;
                    } else if (i > j) {
                        // Symmetric
                        matrix[i][j] = matrix[j][i];
                    } else {
                        const col1 = data.map(row => row[headers[i]]);
                        const col2 = data.map(row => row[headers[j]]);
                        matrix[i][j] = ss.sampleCorrelation(col1, col2);
                    }
                }
            }

            // Fill lower triangle
            for (let i = 0; i < headers.length; i++) {
                for (let j = 0; j < i; j++) {
                    matrix[i][j] = matrix[j][i];
                }
            }

            const trace = {
                z: matrix,
                x: headers,
                y: headers,
                type: 'heatmap',
                colorscale: 'RdBu',
                zmin: -1,
                zmax: 1,
                hoverongaps: false
            };

            const layout = {
                title: '數值變數相關係數熱力圖',
                xaxis: { side: 'bottom' },
                yaxis: { autorange: 'reversed' },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                margin: { t: 60, b: 60, l: 80, r: 20 } // Increased left margin for labels
            };

            Plotly.newPlot(containerId, [trace], layout, { responsive: true });
        }

        function runEDA() {
            const resultsDiv = document.getElementById('edaResults');
            resultsDiv.innerHTML = '';

            // 1. Numeric Stats Table (Enhanced Style)
            const stats = numericHeaders.map(header => {
                const values = jsonData.map(row => row[header]).filter(v => typeof v === 'number');
                if (values.length === 0) return null;
                const q1 = ss.quantile(values, 0.25);
                const q3 = ss.quantile(values, 0.75);
                return {
                    column: header,
                    count: values.length,
                    mean: ss.mean(values).toFixed(2),
                    median: ss.median(values).toFixed(2),
                    stdDev: ss.standardDeviation(values).toFixed(2),
                    min: ss.min(values),
                    max: ss.max(values),
                    skewness: calculateSkewness(values).toFixed(2),
                    kurtosis: calculateKurtosis(values).toFixed(2)
                };
            }).filter(s => s !== null);

            let statsHtml = `
                <div class="bg-white/80 backdrop-blur-md rounded-xl shadow-lg border border-white/20 p-6 mb-8">
                    <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
                        <span class="bg-blue-100 text-blue-600 p-2 rounded-lg">📊</span> 數值資料摘要
                    </h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50/50">
                                <tr>
                                    <th class="px-4 py-3 text-left text-xs font-bold text-gray-500 uppercase tracking-wider">欄位</th>
                                    <th class="px-4 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider">個數 n</th>
                                    <th class="px-4 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider">平均值</th>
                                    <th class="px-4 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider">中位數</th>
                                    <th class="px-4 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider">標準差</th>
                                    <th class="px-4 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider">Min / Max</th>
                                    <th class="px-4 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider">偏態 / 峰態</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-100">
                                ${stats.map(s => `
                                    <tr class="hover:bg-blue-50/30 transition-colors">
                                        <td class="px-4 py-3 text-sm font-medium text-gray-900">${s.column}</td>
                                        <td class="px-4 py-3 text-sm text-gray-600 text-right font-mono">${s.count}</td>
                                        <td class="px-4 py-3 text-sm text-gray-600 text-right font-mono">${s.mean}</td>
                                        <td class="px-4 py-3 text-sm text-gray-600 text-right font-mono">${s.median}</td>
                                        <td class="px-4 py-3 text-sm text-gray-600 text-right font-mono">${s.stdDev}</td>
                                        <td class="px-4 py-3 text-sm text-gray-500 text-right font-mono text-xs">${s.min} / ${s.max}</td>
                                        <td class="px-4 py-3 text-sm text-gray-500 text-right font-mono text-xs">${s.skewness} / ${s.kurtosis}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            resultsDiv.innerHTML += statsHtml;

            // 2. Visualizations Grid
            resultsDiv.innerHTML += `<h3 class="text-xl font-bold text-gray-800 mb-6 pl-2 border-l-4 border-purple-500">進階資料視覺化</h3>`;

            const plotsContainer = document.createElement('div');
            plotsContainer.className = 'grid grid-cols-1 md:grid-cols-2 gap-8 mb-8';
            resultsDiv.appendChild(plotsContainer);

            // Render Numeric Plots
            numericHeaders.forEach(header => {
                const values = jsonData.map(row => row[header]).filter(v => typeof v === 'number');
                if (values.length > 0) {
                    const card = document.createElement('div');
                    card.className = 'bg-white/90 backdrop-blur rounded-xl shadow-md border border-gray-100 p-4 hover:shadow-xl transition-shadow duration-300';
                    const plotId = `plot-${header.replace(/\s/g, '')}`;
                    card.id = plotId;
                    card.style.minHeight = '400px';
                    plotsContainer.appendChild(card);
                    renderNumericDistribution(plotId, values, header);
                }
            });

            // Render Categorical Plots
            categoricalHeaders.forEach(header => {
                const values = jsonData.map(row => row[header]).filter(v => v != null);
                if (values.length > 0) {
                    const counts = values.reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});
                    const card = document.createElement('div');
                    card.className = 'bg-white/90 backdrop-blur rounded-xl shadow-md border border-gray-100 p-4 hover:shadow-xl transition-shadow duration-300';
                    const plotId = `plot-${header.replace(/\s/g, '')}`;
                    card.id = plotId;
                    card.style.minHeight = '400px';
                    plotsContainer.appendChild(card);
                    renderCategoricalDistribution(plotId, counts, header);
                }
            });

            // 3. Correlation Heatmap
            if (numericHeaders.length >= 2) {
                const heatmapContainer = document.createElement('div');
                heatmapContainer.className = 'bg-white/90 backdrop-blur rounded-xl shadow-lg border border-gray-100 p-6 mt-8';
                heatmapContainer.id = 'correlationHeatmap';
                heatmapContainer.style.minHeight = '600px';
                resultsDiv.appendChild(heatmapContainer);

                renderCorrelationHeatmap('correlationHeatmap', jsonData, numericHeaders);
            }
        }

        function runPareto() {
            const categoryVar = document.getElementById('paretoCategoryVar').value;
            const valueVar = document.getElementById('paretoValueVar').value;
            const resultsDiv = document.getElementById('paretoResults');
            resultsDiv.innerHTML = '';
            if (!categoryVar || !valueVar) { resultsDiv.innerHTML = `<p class="text-red-600">請選擇類別與數值欄位。</p>`; return; }

            const sums = jsonData.reduce((acc, row) => {
                const category = row[categoryVar];
                const value = parseFloat(row[valueVar]);
                if (category != null && !isNaN(value)) {
                    acc[category] = (acc[category] || 0) + value;
                }
                return acc;
            }, {});

            const sortedData = Object.entries(sums).sort(([, a], [, b]) => b - a);
            if (sortedData.length === 0) { resultsDiv.innerHTML = `<p class="text-gray-500">找不到有效的配對資料來產生柏拉圖。</p>`; return; }

            const totalSum = sortedData.reduce((sum, [, value]) => sum + value, 0);

            let cumulativePercentage = 0;
            const labels = [], values = [], percentages = [];
            sortedData.forEach(([label, value]) => {
                labels.push(label);
                values.push(value);
                cumulativePercentage += (value / totalSum) * 100;
                percentages.push(cumulativePercentage);
            });

            const plotDiv = document.createElement('div');
            plotDiv.id = 'paretoPlot';
            resultsDiv.appendChild(plotDiv);

            const trace1 = { x: labels, y: values, type: 'bar', name: '數值', marker: { color: 'rgb(37, 99, 235)' } };
            const trace2 = { x: labels, y: percentages, type: 'scatter', mode: 'lines+markers', name: '累積百分比 (%)', yaxis: 'y2', line: { color: 'rgb(220, 38, 38)' } };

            const layout = {
                title: `柏拉圖分析: ${valueVar} by ${categoryVar}`,
                xaxis: { title: categoryVar },
                yaxis: { title: `加總 ${valueVar}` },
                yaxis2: { title: '累積百分比 (%)', overlaying: 'y', side: 'right', range: [0, 105] },
                showlegend: true,
                legend: { x: 0.7, y: 1.15 }
            };
            Plotly.newPlot(plotDiv, [trace1, trace2], layout, { responsive: true });
        }

        function runAnovaStyleTest() {
            const catVar = document.getElementById('tTestCategoricalVar').value;
            const numVar = document.getElementById('tTestNumericalVar').value;
            const resultsDiv = document.getElementById('tTestResults');
            resultsDiv.innerHTML = '';
            if (!catVar || !numVar) { resultsDiv.innerHTML = `<p class="text-red-600">請選擇分組變數與數值變數。</p>`; return; }

            const groupedData = jsonData.reduce((acc, row) => {
                const groupKey = row[catVar], numValue = row[numVar];
                if (groupKey != null && typeof numValue === 'number') {
                    if (!acc[groupKey]) acc[groupKey] = [];
                    acc[groupKey].push(numValue);
                }
                return acc;
            }, {});

            const groups = Object.keys(groupedData);
            if (groups.length < 2) { resultsDiv.innerHTML = `<p class="text-red-600">分組變數至少需要兩個組別。目前有 ${groups.length} 組。</p>`; return; }

            // 自動選擇：2組用 T檢定，3組以上用 ANOVA
            if (groups.length === 2) {
                // T 檢定
                const data1 = groupedData[groups[0]], data2 = groupedData[groups[1]];
                if (data1.length < 2 || data2.length < 2) { resultsDiv.innerHTML = `<p class="text-red-600">組別內沒有足夠的數值資料。</p>`; return; }

                const n1 = data1.length, n2 = data2.length;
                const mean1 = ss.mean(data1), mean2 = ss.mean(data2);
                const var1 = ss.variance(data1), var2 = ss.variance(data2);

                if (var1 === 0 || var2 === 0) {
                    resultsDiv.innerHTML = `<p class="text-red-600">錯誤：至少有一個組別的變異數為零，無法計算 T 檢定。</p>`;
                    return;
                }

                const tStat = (mean1 - mean2) / Math.sqrt(var1 / n1 + var2 / n2);
                const df_num = Math.pow(var1 / n1 + var2 / n2, 2);
                const df_den = (Math.pow(var1 / n1, 2) / (n1 - 1)) + (Math.pow(var2 / n2, 2) / (n2 - 1));
                const df = df_num / df_den;
                const pValue = jStat.studentt.cdf(-Math.abs(tStat), df) * 2;

                let resultHtml = `<h3 class="text-lg font-semibold mb-2">📊 T 檢定結果: ${numVar} by ${catVar}</h3><div class="overflow-x-auto"><table class="min-w-full bg-white"><tbody class="divide-y divide-gray-200"><tr><td class="px-6 py-4 font-medium text-gray-900">比較組別</td><td class="px-6 py-4 text-gray-700">${groups[0]} vs ${groups[1]}</td></tr><tr><td class="px-6 py-4 font-medium text-gray-900">T 統計量</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${tStat.toFixed(4)}</td></tr><tr><td class="px-6 py-4 font-medium text-gray-900">P 值</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${pValue.toFixed(4)}</td></tr></tbody></table></div><div class="mt-4 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-r-lg"><h4 class="font-bold">結果判讀:</h4><p class="text-gray-700 mt-1">${pValue < 0.05 ? `由於 p-value (${pValue.toFixed(4)}) 小於 0.05，兩組在 <strong>${numVar}</strong> 的平均值上存在<strong>顯著差異</strong>。` : `由於 p-value (${pValue.toFixed(4)}) 大於 0.05，兩組在 <strong>${numVar}</strong> 的平均值上<strong>沒有顯著差異</strong>。`}</p></div>`;
                resultsDiv.innerHTML = resultHtml;

                const plotDiv = document.createElement('div');
                plotDiv.id = 'tTestPlot', plotDiv.className = 'mt-6', resultsDiv.appendChild(plotDiv);
                const trace1 = { y: data1, type: 'box', name: groups[0] }, trace2 = { y: data2, type: 'box', name: groups[1] };
                Plotly.newPlot('tTestPlot', [trace1, trace2], { title: '兩組資料分佈比較', yaxis: { title: numVar }, paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9' }, { responsive: true });
            } else {
                // ANOVA (多組比較)
                const allData = [];
                const groupMeans = [];
                const groupSizes = [];
                let grandTotal = 0;
                let totalN = 0;

                groups.forEach(group => {
                    const data = groupedData[group];
                    if (data.length < 2) { resultsDiv.innerHTML = `<p class="text-red-600">組別 "${group}" 沒有足夠的資料。</p>`; return; }
                    allData.push(...data);
                    const mean = ss.mean(data);
                    groupMeans.push(mean);
                    groupSizes.push(data.length);
                    grandTotal += ss.sum(data);
                    totalN += data.length;
                });

                const grandMean = grandTotal / totalN;

                // 組間變異 (Between-group variation)
                let ssb = 0;
                groups.forEach((group, i) => {
                    ssb += groupSizes[i] * Math.pow(groupMeans[i] - grandMean, 2);
                });

                // 組內變異 (Within-group variation)
                let ssw = 0;
                groups.forEach((group, i) => {
                    const data = groupedData[group];
                    const mean = groupMeans[i];
                    data.forEach(val => {
                        ssw += Math.pow(val - mean, 2);
                    });
                });

                const dfb = groups.length - 1;
                const dfw = totalN - groups.length;
                const msb = ssb / dfb;
                const msw = ssw / dfw;
                const fStat = msb / msw;

                // F 分佈的 p-value
                const pValue = 1 - jStat.centralF.cdf(fStat, dfb, dfw);

                // 效果量 Eta-squared (η²)
                const etaSquared = ssb / (ssb + ssw);

                let resultHtml = `<h3 class="text-lg font-semibold mb-2">📊 ANOVA 分析結果: ${numVar} by ${catVar}</h3>`;
                resultHtml += `<div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-100"><tr><th class="px-4 py-2 border">變異來源</th><th class="px-4 py-2 border">SS</th><th class="px-4 py-2 border">df</th><th class="px-4 py-2 border">MS</th><th class="px-4 py-2 border">F</th><th class="px-4 py-2 border">p-value</th></tr></thead><tbody><tr><td class="px-4 py-2 border font-medium">組間 Between</td><td class="px-4 py-2 border">${ssb.toFixed(3)}</td><td class="px-4 py-2 border">${dfb}</td><td class="px-4 py-2 border">${msb.toFixed(3)}</td><td class="px-4 py-2 border font-mono text-lg">${fStat.toFixed(4)}</td><td class="px-4 py-2 border font-mono text-lg">${pValue.toFixed(4)}</td></tr><tr><td class="px-4 py-2 border font-medium">組內 Within</td><td class="px-4 py-2 border">${ssw.toFixed(3)}</td><td class="px-4 py-2 border">${dfw}</td><td class="px-4 py-2 border">${msw.toFixed(3)}</td><td class="px-4 py-2 border">-</td><td class="px-4 py-2 border">-</td></tr><tr><td class="px-4 py-2 border font-medium">總變異 Total</td><td class="px-4 py-2 border">${(ssb + ssw).toFixed(3)}</td><td class="px-4 py-2 border">${totalN - 1}</td><td class="px-4 py-2 border">-</td><td class="px-4 py-2 border">-</td><td class="px-4 py-2 border">-</td></tr></tbody></table></div>`;
                resultHtml += `<div class="bg-purple-50 p-4 rounded mb-4"><p class="font-semibold">效果量 (Effect Size - η²): <span class="text-lg text-purple-700">${etaSquared.toFixed(4)}</span></p><p class="text-sm text-gray-600 mt-1">解釋：η² = ${(etaSquared * 100).toFixed(1)}% 的變異可由組別差異解釋。</p></div>`;
                resultHtml += `<div class="mt-4 p-4 bg-green-50 border-l-4 border-green-500 rounded-r-lg"><h4 class="font-bold">結果判讀:</h4><p class="text-gray-700 mt-1">${pValue < 0.05 ? `由於 p-value (${pValue.toFixed(4)}) 小於 0.05，F 統計量 = ${fStat.toFixed(4)}，至少有一組在 <strong>${numVar}</strong> 的平均值上與其他組存在<strong>顯著差異</strong>。` : `由於 p-value (${pValue.toFixed(4)}) 大於 0.05，所有組別在 <strong>${numVar}</strong> 的平均值上<strong>沒有顯著差異</strong>。`}</p></div>`;

                // 組別摘要
                resultHtml += `<h4 class="text-md font-semibold mt-4 mb-2">組別摘要統計:</h4><div class="overflow-x-auto"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">組別</th><th class="px-4 py-2 border">樣本數</th><th class="px-4 py-2 border">平均值</th><th class="px-4 py-2 border">標準差</th></tr></thead><tbody>`;
                groups.forEach((group, i) => {
                    const data = groupedData[group];
                    const std = ss.standardDeviation(data);
                    resultHtml += `<tr><td class="px-4 py-2 border font-medium">${group}</td><td class="px-4 py-2 border">${groupSizes[i]}</td><td class="px-4 py-2 border">${groupMeans[i].toFixed(3)}</td><td class="px-4 py-2 border">${std.toFixed(3)}</td></tr>`;
                });
                resultHtml += `</tbody></table></div>`;

                resultsDiv.innerHTML = resultHtml;

                // 視覺化
                const plotDiv = document.createElement('div');
                plotDiv.id = 'anovaPlot', plotDiv.className = 'mt-6', resultsDiv.appendChild(plotDiv);
                const traces = groups.map(group => ({ y: groupedData[group], type: 'box', name: group }));
                Plotly.newPlot('anovaPlot', traces, { title: `${groups.length} 組資料分佈比較`, yaxis: { title: numVar }, paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9' }, { responsive: true });
            }
        }

        function runRegression() {
            const xVar = document.getElementById('regressionX').value;
            const yVar = document.getElementById('regressionY').value;
            const resultsDiv = document.getElementById('regressionResults');
            resultsDiv.innerHTML = '';
            if (!xVar || !yVar) { resultsDiv.innerHTML = `<p class="text-red-600">請選擇自變數 (X) 與應變數 (Y)。</p>`; return; }
            if (xVar === yVar) { resultsDiv.innerHTML = `<p class="text-red-600">自變數與應變數不能相同。</p>`; return; }
            const dataPairs = jsonData.map(row => [row[xVar], row[yVar]]).filter(pair => typeof pair[0] === 'number' && typeof pair[1] === 'number');
            if (dataPairs.length < 3) { resultsDiv.innerHTML = `<p class="text-red-600">沒有足夠的配對數值資料進行迴歸分析。</p>`; return; }

            const linearModel = ss.linearRegression(dataPairs);
            const rSquared = ss.rSquared(dataPairs, ss.linearRegressionLine(linearModel));
            const line = ss.linearRegressionLine(linearModel);

            const xValues = dataPairs.map(p => p[0]), yValues = dataPairs.map(p => p[1]);
            const n = dataPairs.length;

            // 計算殘差和統計推論
            const predictions = xValues.map(x => line(x));
            const residuals = yValues.map((y, i) => y - predictions[i]);
            const sse = residuals.reduce((sum, r) => sum + r * r, 0);
            const mse = sse / (n - 2);
            const syx = Math.sqrt(mse);

            // 調整後 R²
            const adjRSquared = 1 - (1 - rSquared) * (n - 1) / (n - 2);

            // 斜率的標準誤和 t 統計量
            const xMean = ss.mean(xValues);
            const sxx = xValues.reduce((sum, x) => sum + Math.pow(x - xMean, 2), 0);
            const seSlope = syx / Math.sqrt(sxx);
            const tStatSlope = linearModel.m / seSlope;
            const dfResidual = n - 2;
            const pValueSlope = 2 * (1 - jStat.studentt.cdf(Math.abs(tStatSlope), dfResidual));

            // 斜率 95% 信賴區間
            const tCritical = jStat.studentt.inv(0.975, dfResidual);
            const slopeCI_lower = linearModel.m - tCritical * seSlope;
            const slopeCI_upper = linearModel.m + tCritical * seSlope;

            // 截距的標準誤
            const seIntercept = syx * Math.sqrt(1 / n + (xMean * xMean) / sxx);
            const tStatIntercept = linearModel.b / seIntercept;
            const pValueIntercept = 2 * (1 - jStat.studentt.cdf(Math.abs(tStatIntercept), dfResidual));
            const interceptCI_lower = linearModel.b - tCritical * seIntercept;
            const interceptCI_upper = linearModel.b + tCritical * seIntercept;

            let resultHtml = `<h3 class="text-lg font-semibold mb-2">📊 簡單線性迴歸結果 (增強版)</h3>`;
            resultHtml += `<div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><tbody class="divide-y divide-gray-200"><tr><td class="px-6 py-3 font-medium text-gray-900">迴歸方程式</td><td class="px-6 py-3 text-gray-700 font-mono text-lg">Y = ${linearModel.m.toFixed(4)} * X + ${linearModel.b.toFixed(4)}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">判定係數 R²</td><td class="px-6 py-3 text-gray-700 font-mono text-lg">${rSquared.toFixed(4)}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">調整後 R²</td><td class="px-6 py-3 text-gray-700 font-mono text-lg">${adjRSquared.toFixed(4)}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">標準誤 (S)</td><td class="px-6 py-3 text-gray-700 font-mono">${syx.toFixed(4)}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">樣本數</td><td class="px-6 py-3 text-gray-700">${n}</td></tr></tbody></table></div>`;

            resultHtml += `<h4 class="text-md font-semibold mb-2">係數統計推論:</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">係數</th><th class="px-4 py-2 border">估計值</th><th class="px-4 py-2 border">標準誤</th><th class="px-4 py-2 border">t 統計量</th><th class="px-4 py-2 border">p-value</th><th class="px-4 py-2 border">95% CI 下限</th><th class="px-4 py-2 border">95% CI 上限</th></tr></thead><tbody><tr><td class="px-4 py-2 border font-medium">截距 (b0)</td><td class="px-4 py-2 border font-mono">${linearModel.b.toFixed(4)}</td><td class="px-4 py-2 border">${seIntercept.toFixed(4)}</td><td class="px-4 py-2 border">${tStatIntercept.toFixed(3)}</td><td class="px-4 py-2 border font-mono">${pValueIntercept.toFixed(4)}</td><td class="px-4 py-2 border">${interceptCI_lower.toFixed(4)}</td><td class="px-4 py-2 border">${interceptCI_upper.toFixed(4)}</td></tr><tr><td class="px-4 py-2 border font-medium">斜率 (b1)</td><td class="px-4 py-2 border font-mono">${linearModel.m.toFixed(4)}</td><td class="px-4 py-2 border">${seSlope.toFixed(4)}</td><td class="px-4 py-2 border">${tStatSlope.toFixed(3)}</td><td class="px-4 py-2 border font-mono">${pValueSlope.toFixed(4)}</td><td class="px-4 py-2 border">${slopeCI_lower.toFixed(4)}</td><td class="px-4 py-2 border">${slopeCI_upper.toFixed(4)}</td></tr></tbody></table></div>`;

            resultHtml += `<div class="mt-4 p-4 bg-purple-50 border-l-4 border-purple-500 rounded-r-lg"><h4 class="font-bold">結果判讀:</h4><ul class="text-gray-700 mt-1 space-y-1 list-disc list-inside"><li>R² = ${rSquared.toFixed(4)}，表示 <strong>${(rSquared * 100).toFixed(1)}%</strong> 的 Y 變異可由 X 解釋。</li><li>斜率 p-value = ${pValueSlope.toFixed(4)} ${pValueSlope < 0.05 ? '< 0.05，<strong>顯著</strong>' : '≥ 0.05，不顯著'}。</li><li>95% 信賴區間：斜率真值落在 [${slopeCI_lower.toFixed(4)}, ${slopeCI_upper.toFixed(4)}] 之間。</li></ul></div>`;

            resultsDiv.innerHTML = resultHtml;

            // 散佈圖 + 迴歸線
            const xMin = ss.min(xValues), xMax = ss.max(xValues);
            const lineX = [xMin, xMax], lineY = [line(xMin), line(xMax)];
            const plotDiv1 = document.createElement('div');
            plotDiv1.id = 'regressionPlot', plotDiv1.className = 'mt-6', resultsDiv.appendChild(plotDiv1);
            const scatterTrace = { x: xValues, y: yValues, mode: 'markers', type: 'scatter', name: '原始數據', marker: { size: 8 } };
            const lineTrace = { x: lineX, y: lineY, mode: 'lines', type: 'scatter', name: '迴歸線', line: { color: 'rgba(219, 64, 82, 1)', width: 2 } };
            Plotly.newPlot('regressionPlot', [scatterTrace, lineTrace], { title: `${yVar} vs ${xVar} 散佈圖`, xaxis: { title: xVar }, yaxis: { title: yVar }, showlegend: true, paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9' }, { responsive: true });

            // 殘差圖
            const plotDiv2 = document.createElement('div');
            plotDiv2.id = 'residualPlot', plotDiv2.className = 'mt-6', resultsDiv.appendChild(plotDiv2);
            const residualTrace = { x: predictions, y: residuals, mode: 'markers', type: 'scatter', name: '殘差', marker: { color: 'rgba(55, 128, 191, 0.7)', size: 8 } };
            const zeroLine = { x: [ss.min(predictions), ss.max(predictions)], y: [0, 0], mode: 'lines', type: 'scatter', name: '零線', line: { color: 'red', dash: 'dash' } };
            Plotly.newPlot('residualPlot', [residualTrace, zeroLine], { title: '殘差圖 (Residual Plot)', xaxis: { title: '預測值' }, yaxis: { title: '殘差' }, showlegend: true, paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9' }, { responsive: true });

            // --- 新增：簡單迴歸預測功能 (參照多元迴歸 UI/UX) ---
            window.simpleRegressionModel = { m: linearModel.m, b: linearModel.b, xVar, yVar };

            const predictHtml = `
                <div class="mt-8 border-t pt-6">
                    <h4 class="text-lg font-bold mb-4 flex items-center gap-2">
                        <svg class="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        進行預測
                    </h4>
                    <div class="flex items-end gap-4 bg-gray-50 p-4 rounded-lg border border-gray-200">
                        <div class="flex-1">
                            <label class="block text-sm font-medium text-gray-700 mb-1">${xVar}</label>
                            <input type="number" id="simplePredInput" class="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500" placeholder="輸入 ${xVar} 數值">
                        </div>
                        <button onclick="predictSimpleRegression()" class="bg-purple-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-purple-700 shadow-md transition-colors flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>
                            計算預測值
                        </button>
                    </div>
                    <div id="simplePredResult" class="mt-4 hidden">
                        <!-- Result will be shown here -->
                    </div>
                </div>
            `;
            resultsDiv.insertAdjacentHTML('beforeend', predictHtml);
        }

        window.predictSimpleRegression = function () {
            const model = window.simpleRegressionModel;
            if (!model) {
                alert('請先執行簡單迴歸分析');
                return;
            }

            const inputElem = document.getElementById('simplePredInput');
            if (!inputElem) return;

            const inputVal = parseFloat(inputElem.value);
            if (isNaN(inputVal)) {
                alert(`請輸入有效的 ${model.xVar} 數值`);
                return;
            }

            const predictedY = model.m * inputVal + model.b;

            const resultDiv = document.getElementById('simplePredResult');
            resultDiv.innerHTML = `
                <div class="p-4 bg-white border border-purple-200 rounded-lg shadow-sm">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-gray-600 text-sm">當 <span class="font-medium text-gray-800">${model.xVar} = ${inputVal}</span> 時</p>
                            <p class="text-lg font-bold text-gray-800 mt-1">預測 ${model.yVar}</p>
                        </div>
                        <div class="text-2xl font-bold text-purple-600">
                            ${predictedY.toFixed(4)}
                        </div>
                    </div>
                </div>
            `;
            resultDiv.classList.remove('hidden');
        };

        function holtWinters(series, alpha, beta, gamma, period, m) {
            if (series.length < period * 2) throw new Error("需要至少兩個週期的數據來初始化 Holt-Winters 模型。");

            // 🔧 修復：計算數據範圍，用於後續保護
            const seriesMin = Math.min(...series);
            const seriesMax = Math.max(...series);
            const seriesRange = seriesMax - seriesMin;

            let level = 0, trend = 0;
            const seasons = new Array(period).fill(0);
            let initialLevelSum = 0;
            for (let i = 0; i < period; i++) initialLevelSum += series[i];
            level = initialLevelSum / period;

            let initialTrendSum = 0;
            for (let i = 0; i < period; i++) initialTrendSum += (series[i + period] - series[i]);
            trend = initialTrendSum / (period * period);

            // 🔧 修復：保護初始seasons，避免除以零或負值
            for (let i = 0; i < period; i++) {
                seasons[i] = Math.max(0.1, series[i] / level);
            }

            const smoothed = [], forecasts = [];
            for (let i = 0; i < series.length; i++) {
                const last_level = level, season_idx = i % period;

                // 🔧 修復：保護season因子，避免除以零
                const safe_season = Math.max(0.01, seasons[season_idx]);

                level = alpha * (series[i] / safe_season) + (1 - alpha) * (level + trend);
                trend = beta * (level - last_level) + (1 - beta) * trend;

                // 🔧 修復：更新season時確保不會變成負值或過小
                const new_season = gamma * (series[i] / level) + (1 - gamma) * seasons[season_idx];
                seasons[season_idx] = Math.max(0.1, Math.min(5.0, new_season));

                smoothed.push(level + trend * seasons[i % period]);
            }

            // 🔧 修復：預測時加入負值保護和趨勢約束
            for (let i = 0; i < m; i++) {
                const season_idx = (series.length + i) % period;

                // 基礎預測值
                let forecast = (level + (i + 1) * trend) * seasons[season_idx];

                // 🔧 保護1：預測值不應小於歷史最小值的50%
                const minThreshold = seriesMin * 0.5;
                if (forecast < minThreshold) {
                    // 使用衰減策略：逐步接近最小值，而不是突然變負
                    forecast = Math.max(minThreshold, level * seasons[season_idx] * 0.9);
                    console.warn(`預測第${i + 1}期被調整：原始值過低，調整為 ${forecast.toFixed(2)}`);
                }

                // 🔧 保護2：預測值不應超過歷史最大值的200%（防止爆炸式增長）
                const maxThreshold = seriesMax * 2.0;
                if (forecast > maxThreshold) {
                    forecast = Math.min(maxThreshold, level * seasons[season_idx] * 1.1);
                    console.warn(`預測第${i + 1}期被調整：原始值過高，調整為 ${forecast.toFixed(2)}`);
                }

                forecasts.push(forecast);
            }
            return { smoothed, forecasts };
        }

        function runForecast() {
            const timeVar = document.getElementById('forecastTimeVar').value;
            const valueVar = document.getElementById('forecastValueVar').value;
            const period = parseInt(document.getElementById('forecastPeriod').value);
            const steps = parseInt(document.getElementById('forecastSteps').value);
            const alpha = parseFloat(document.getElementById('forecastAlpha').value);
            const beta = parseFloat(document.getElementById('forecastBeta').value);
            const gamma = parseFloat(document.getElementById('forecastGamma').value);
            const resultsDiv = document.getElementById('forecastResults');
            resultsDiv.innerHTML = '';

            if (!timeVar || !valueVar || !period || !steps) { resultsDiv.innerHTML = `<p class="text-red-600">請選擇時間、數值欄位，並填寫季節長度與預測期數。</p>`; return; }
            if (period <= 1) { resultsDiv.innerHTML = `<p class="text-red-600">季節長度 (Period) 必須大於 1。</p>`; return; }

            const seriesData = jsonData.map(row => ({ time: row[timeVar], value: row[valueVar] })).filter(d => d.time != null && typeof d.value === 'number');
            seriesData.sort((a, b) => a.time < b.time ? -1 : 1);
            const yValues = seriesData.map(d => d.value);

            if (yValues.length < period * 2) { resultsDiv.innerHTML = `<p class="text-red-600">數據不足。Holt-Winters 需要至少兩倍季節長度的數據 (需要 ${period * 2} 筆，現有 ${yValues.length} 筆)。</p>`; return; }

            try {
                const { smoothed, forecasts } = holtWinters(yValues, alpha, beta, gamma, period, steps);

                let absPercentErrors = [];
                for (let i = 0; i < yValues.length; i++) {
                    if (yValues[i] !== 0) absPercentErrors.push(Math.abs((yValues[i] - smoothed[i]) / yValues[i]));
                }
                const mape = absPercentErrors.length > 0 ? ss.mean(absPercentErrors) * 100 : 0;

                const plotDiv = document.createElement('div');
                plotDiv.id = 'forecastPlot';
                resultsDiv.appendChild(plotDiv);

                const originalX = seriesData.map(d => d.time instanceof Date ? d.time.toLocaleDateString() : d.time);
                const futureX = [];
                const lastTime = seriesData[seriesData.length - 1].time;
                if (lastTime instanceof Date) {
                    for (let i = 1; i <= steps; i++) {
                        const nextDate = new Date(lastTime);
                        nextDate.setMonth(nextDate.getMonth() + i);
                        futureX.push(nextDate.toLocaleDateString());
                    }
                } else if (!isNaN(lastTime)) {
                    for (let i = 1; i <= steps; i++) futureX.push(lastTime + i);
                } else {
                    for (let i = 1; i <= steps; i++) futureX.push(`預測 ${i}`);
                }

                const trace1 = { x: originalX, y: yValues, mode: 'lines+markers', name: '原始數據' };
                const trace2 = { x: originalX, y: smoothed, mode: 'lines', name: '模型擬合值', line: { dash: 'dot', color: 'orange' } };
                const trace3 = { x: futureX, y: forecasts, mode: 'lines+markers', name: '預測值', line: { color: 'red' } };
                const layout = { title: `${valueVar} Holt-Winters 預測`, xaxis: { title: timeVar, type: 'category' }, yaxis: { title: valueVar }, showlegend: true, paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9' };
                Plotly.newPlot('forecastPlot', [trace1, trace2, trace3], layout, { responsive: true });

                let tableHtml = `<div class="mt-4 p-4 bg-sky-50 border-l-4 border-sky-500 rounded-r-lg"><h4 class="font-bold">模型準確度</h4><p class="text-gray-700 mt-1">平均絕對百分比誤差 (MAPE): <strong>${mape.toFixed(2)}%</strong> (越低越好)</p></div><h3 class="text-lg font-semibold mt-6 mb-2">預測值</h3><div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">未來期數</th><th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">預測值</th></tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
                forecasts.forEach((val, i) => {
                    tableHtml += `<tr><td class="p-2 whitespace-nowrap text-sm font-medium text-gray-900">${futureX[i]}</td><td class="p-2 text-sm text-gray-500">${val.toFixed(3)}</td></tr>`;
                });
                tableHtml += `</tbody></table></div>`;
                resultsDiv.innerHTML += tableHtml;

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">預測時發生錯誤: ${error.message}</p>`;
            }
        }


        // --- Prophet 風格模型：線性趨勢 + 季節性平均殘差 ---
        function prophetDecomposeForecast(series, period, steps) {
            const n = series.length;
            const xIdx = Array.from({ length: n }, (_, i) => i);

            // 線性趨勢：使用 simple-statistics 線性迴歸
            const points = xIdx.map((xi, i) => [xi, series[i]]);
            const lr = ss.linearRegression(points);  // { m, b }

            const trend = xIdx.map(x => lr.m * x + lr.b);
            const residuals = series.map((v, i) => v - trend[i]);

            // 建立季節性 pattern（長度 = period）
            const season = new Array(period).fill(0);
            const counts = new Array(period).fill(0);
            for (let i = 0; i < n; i++) {
                const idx = i % period;
                season[idx] += residuals[i];
                counts[idx] += 1;
            }
            for (let k = 0; k < period; k++) {
                if (counts[k] > 0) season[k] /= counts[k];
            }
            // 置中季節性，使其平均為 0
            const meanSeason = season.reduce((a, b) => a + b, 0) / period;
            for (let k = 0; k < period; k++) {
                season[k] -= meanSeason;
            }

            // 回填訓練期 fitted 值
            const fitted = xIdx.map(i => trend[i] + season[i % period]);

            // 取得歷史最小/最大值，用來做預測值保護
            const seriesMin = Math.min(...series);
            const seriesMax = Math.max(...series);

            // 產生未來 forecasts
            const forecasts = [];
            for (let i = 0; i < steps; i++) {
                const idx = n + i;
                const baseTrend = lr.m * idx + lr.b;
                const seasonVal = season[idx % period];
                let forecast = baseTrend + seasonVal;

                // 做簡單的上下界保護
                const minThreshold = seriesMin * 0.3;
                const maxThreshold = seriesMax * 3.0;
                if (forecast < minThreshold) forecast = minThreshold;
                if (forecast > maxThreshold) forecast = maxThreshold;

                forecasts.push(forecast);
            }

            return { fitted, forecasts };
        }

        function runProphetForecast() {
            const timeVar = document.getElementById('prophetTimeVar').value;
            const valueVar = document.getElementById('prophetValueVar').value;
            const period = parseInt(document.getElementById('prophetPeriod').value);
            const steps = parseInt(document.getElementById('prophetSteps').value);
            const resultsDiv = document.getElementById('prophetResults');
            resultsDiv.innerHTML = '';

            if (!timeVar || !valueVar || !period || !steps) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇時間、數值欄位，並填寫季節長度與預測期數。</p>`;
                return;
            }
            if (period <= 1) {
                resultsDiv.innerHTML = `<p class="text-red-600">季節長度 (Period) 必須大於 1。</p>`;
                return;
            }

            const seriesData = jsonData
                .map(row => ({ time: row[timeVar], value: row[valueVar] }))
                .filter(d => d.time != null && typeof d.value === 'number');

            if (seriesData.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">找不到有效的時間序列資料，請確認欄位內容。</p>`;
                return;
            }

            // 依時間排序（與 Holt-Winters 一致）
            seriesData.sort((a, b) => a.time < b.time ? -1 : 1);
            const yValues = seriesData.map(d => d.value);

            if (yValues.length < period * 2) {
                resultsDiv.innerHTML =
                    `<p class="text-red-600">數據不足。此分解模型建議至少有兩倍季節長度的數據 (需要 ${period * 2} 筆，現有 ${yValues.length} 筆)。</p>`;
                return;
            }

            try {
                const { fitted, forecasts } = prophetDecomposeForecast(yValues, period, steps);

                // MAPE：以訓練期 fitted vs 實際資料計算
                let absPercentErrors = [];
                for (let i = 0; i < yValues.length; i++) {
                    if (yValues[i] !== 0) {
                        absPercentErrors.push(Math.abs((yValues[i] - fitted[i]) / yValues[i]));
                    }
                }
                const mape = absPercentErrors.length > 0 ? ss.mean(absPercentErrors) * 100 : 0;

                // X 軸：與 Holt-Winters 一致
                const originalX = seriesData.map(d =>
                    d.time instanceof Date ? d.time.toLocaleDateString() : d.time
                );
                const futureX = [];
                const lastTime = seriesData[seriesData.length - 1].time;
                if (lastTime instanceof Date) {
                    for (let i = 1; i <= steps; i++) {
                        const nextDate = new Date(lastTime);
                        nextDate.setMonth(nextDate.getMonth() + i);
                        futureX.push(nextDate.toLocaleDateString());
                    }
                } else if (!isNaN(lastTime)) {
                    for (let i = 1; i <= steps; i++) futureX.push(lastTime + i);
                } else {
                    for (let i = 1; i <= steps; i++) futureX.push(`預測 ${i}`);
                }

                // 畫「趨勢 + 季節分解」預測圖
                const plotDiv = document.createElement('div');
                plotDiv.id = 'prophetForecastPlot';
                resultsDiv.appendChild(plotDiv);

                const trace1 = { x: originalX, y: yValues, mode: 'lines+markers', name: '原始數據' };
                const trace2 = { x: originalX, y: fitted, mode: 'lines', name: '分解擬合值 (Trend + Seasonality)', line: { dash: 'dot', color: 'orange' } };
                const trace3 = { x: futureX, y: forecasts, mode: 'lines+markers', name: '分解預測 (Trend + Seasonality)', line: { color: 'red' } };
                const layout = {
                    title: `${valueVar} 趨勢 + 季節分解預測`,
                    xaxis: { title: timeVar, type: 'category' },
                    yaxis: { title: valueVar },
                    showlegend: true,
                    paper_bgcolor: '#f9f9f9',
                    plot_bgcolor: '#f9f9f9'
                };
                Plotly.newPlot('prophetForecastPlot', [trace1, trace2, trace3], layout, { responsive: true });

                // 表格輸出
                let tableHtml = `
                <div class="mt-4 p-4 bg-amber-50 border-l-4 border-amber-500 rounded-r-lg">
                    <h4 class="font-bold">模型準確度</h4>
                    <p class="text-gray-700 mt-1">
                        平均絕對百分比誤差 (MAPE): <strong>${mape.toFixed(2)}%</strong> (越低越好)
                    </p>
                    <p class="text-xs text-gray-500 mt-1">
                        此「趨勢 + 季節分解」實作：線性趨勢 + 季節性平均殘差，適合作為 Holt-Winters 的對照模型。
                    </p>
                </div>
                <h3 class="text-lg font-semibold mt-6 mb-2">預測值</h3>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">未來期數</th>
                                <th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">預測值</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
            `;
                forecasts.forEach((val, i) => {
                    tableHtml += `
                    <tr>
                        <td class="p-2 whitespace-nowrap text-sm font-medium text-gray-900">${futureX[i]}</td>
                        <td class="p-2 text-sm text-gray-500">${val.toFixed(3)}</td>
                    </tr>
                `;
                });
                tableHtml += `</tbody></table></div>`;
                resultsDiv.innerHTML += tableHtml;

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">趨勢 + 季節分解預測時發生錯誤: ${error.message}</p>`;
            }
        }


        // --- ARIMA(p, d, q)：Hannan–Rissanen 兩階段估計（純 JS / OLS） ---
        function differenceSeries(series, d) {
            let result = series.slice();
            for (let k = 0; k < d; k++) {
                const diff = [];
                for (let i = 1; i < result.length; i++) {
                    diff.push(result[i] - result[i - 1]);
                }
                result = diff;
            }
            return result;
        }

        // 簡單 AR(p) OLS（給 q = 0 或 Hannan–Rissanen 第一步使用）
        function fitAR(series, p) {
            const n = series.length;
            if (p < 1) throw new Error('p 必須 >= 1');
            if (n <= p + 1) throw new Error('資料筆數需大於 p + 1 (目前 ' + n + ' 筆)');

            const X = [];
            const y = [];
            for (let t = p; t < n; t++) {
                const row = [1];
                for (let j = 1; j <= p; j++) {
                    row.push(series[t - j]);
                }
                X.push(row);
                y.push([series[t]]);
            }
            const XT = _T(X);
            const XTX = _mul(XT, X);
            const XTX_inv = _invGauss(XTX);
            const XTy = _mul(XT, y);
            const coefMat = _mul(XTX_inv, XTy);
            const coefs = coefMat.map(r => r[0]);

            const fitted = new Array(n).fill(null);
            for (let t = p; t < n; t++) {
                let pred = coefs[0];
                for (let j = 1; j <= p; j++) {
                    pred += coefs[j] * series[t - j];
                }
                fitted[t] = pred;
            }

            return { coefs, fitted };
        }

        // Hannan–Rissanen：估計 ARIMA 的 AR、MA 係數（在差分後的 ARMA 尺度上）
        function estimateARIMA_HR(series, p, q) {
            const n = series.length;

            if (p < 0 || q < 0) {
                throw new Error('p, q 必須 >= 0');
            }
            if (p === 0 && q === 0) {
                throw new Error('至少需有一個 AR 或 MA 階數 > 0');
            }
            if (n <= p + q + 2) {
                throw new Error(`資料筆數需大於 p + q + 2 (目前 ${n} 筆)`);
            }

            // 若 q = 0，退化為純 AR(p)
            if (q === 0) {
                const pEffective = p > 0 ? p : 1;
                const { coefs, fitted } = fitAR(series, pEffective);
                const residuals = new Array(n).fill(null);
                for (let t = pEffective; t < n; t++) {
                    residuals[t] = series[t] - fitted[t];
                }
                return {
                    constant: coefs[0],
                    ar: coefs.slice(1),
                    ma: [],
                    fitted,
                    residuals,
                    startIndex: pEffective
                };
            }

            // === 第一步：高階 AR(m) 估計，取得殘差 ===
            let m = Math.max(p + q + 1, 10);
            if (m >= n) m = n - 1;
            if (m <= 0) {
                throw new Error('資料筆數不足以進行 Hannan–Rissanen 估計。');
            }

            const X1 = [];
            const y1 = [];
            for (let t = m; t < n; t++) {
                const row = [1];
                for (let j = 1; j <= m; j++) {
                    row.push(series[t - j]);
                }
                X1.push(row);
                y1.push([series[t]]);
            }

            const XT1 = _T(X1);
            const XTX1 = _mul(XT1, X1);
            const XTX1_inv = _invGauss(XTX1);
            const XTy1 = _mul(XT1, y1);
            const coef1Mat = _mul(XTX1_inv, XTy1);
            const a = coef1Mat.map(r => r[0]);

            const residualsStep1 = new Array(n).fill(null);
            for (let t = m; t < n; t++) {
                let pred = a[0];
                for (let j = 1; j <= m; j++) {
                    pred += a[j] * series[t - j];
                }
                residualsStep1[t] = series[t] - pred;
            }

            // === 第二步：AR(p) + MA(q)（殘差當解釋變數）做 OLS ===
            const start = Math.max(m + 1, p, q + 1);
            if (start >= n) {
                throw new Error('資料筆數不足以建立 ARMA 模型，請降低 (p, q) 或縮短 m。');
            }

            const X2 = [];
            const y2 = [];
            for (let t = start; t < n; t++) {
                const row = [1];
                for (let j = 1; j <= p; j++) {
                    row.push(series[t - j]);
                }
                for (let k = 1; k <= q; k++) {
                    const eLag = residualsStep1[t - k] != null ? residualsStep1[t - k] : 0;
                    row.push(eLag);
                }
                X2.push(row);
                y2.push([series[t]]);
            }

            const XT2 = _T(X2);
            const XTX2 = _mul(XT2, X2);
            const XTX2_inv = _invGauss(XTX2);
            const XTy2 = _mul(XT2, y2);
            const betaMat = _mul(XTX2_inv, XTy2);
            const beta = betaMat.map(r => r[0]);

            const constant = beta[0];
            const ar = [];
            for (let j = 0; j < p; j++) {
                ar.push(beta[1 + j]);
            }
            const ma = [];
            for (let k = 0; k < q; k++) {
                ma.push(beta[1 + p + k]);
            }

            const fitted = new Array(n).fill(null);
            const residuals = new Array(n).fill(null);
            for (let t = start; t < n; t++) {
                let pred = constant;
                for (let j = 1; j <= p; j++) {
                    pred += ar[j - 1] * series[t - j];
                }
                for (let k = 1; k <= q; k++) {
                    const eLag = residualsStep1[t - k] != null ? residualsStep1[t - k] : 0;
                    pred += ma[k - 1] * eLag;
                }
                fitted[t] = pred;
                residuals[t] = series[t] - pred;
            }

            return { constant, ar, ma, fitted, residuals, startIndex: start };
        }

        // 使用估計好的 ARIMA 模型進行未來 steps 期預測（在差分後的 ARMA 尺度）
        function forecastARIMA_HR(series, params, steps) {
            const { constant, ar, ma, residuals } = params;
            const p = ar.length;
            const q = ma.length;

            const yHistory = series.slice();
            const eHistory = residuals.slice();
            const forecasts = [];

            for (let h = 0; h < steps; h++) {
                const t = yHistory.length;
                let pred = constant;

                for (let j = 1; j <= p; j++) {
                    const yLag = yHistory[t - j];
                    if (typeof yLag === 'number') {
                        pred += ar[j - 1] * yLag;
                    }
                }

                for (let k = 1; k <= q; k++) {
                    const eLag = eHistory[eHistory.length - k];
                    if (typeof eLag === 'number') {
                        pred += ma[k - 1] * eLag;
                    }
                }

                forecasts.push(pred);
                yHistory.push(pred);
                eHistory.push(0);
            }

            return forecasts;
        }

        function runArimaForecast() {
            const timeVar = document.getElementById('arimaTimeVar').value;
            const valueVar = document.getElementById('arimaValueVar').value;
            const p = parseInt(document.getElementById('arimaP').value);
            let d = parseInt(document.getElementById('arimaD').value);
            let q = parseInt(document.getElementById('arimaQ').value);
            const steps = parseInt(document.getElementById('arimaSteps').value);
            const resultsDiv = document.getElementById('arimaResults');
            resultsDiv.innerHTML = '';

            if (!timeVar || !valueVar || isNaN(p) || isNaN(steps)) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇時間、數值欄位，並設定 p、d、q 與預測期數。</p>`;
                return;
            }
            if (isNaN(d) || d < 0) d = 0;
            if (d > 1) d = 1;

            if (isNaN(q) || q < 0) q = 0;

            if (p < 0 || q < 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">p 與 q 必須為非負整數。</p>`;
                return;
            }
            if (p === 0 && q === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">至少需有一個階數 &gt; 0（p 或 q 必須大於 0）。</p>`;
                return;
            }

            const seriesData = jsonData
                .map(row => ({ time: row[timeVar], value: row[valueVar] }))
                .filter(d0 => d0.time != null && typeof d0.value === 'number');

            if (seriesData.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">找不到有效的時間序列資料，請確認欄位內容。</p>`;
                return;
            }

            seriesData.sort((a, b) => a.time < b.time ? -1 : 1);
            const yValues = seriesData.map(d0 => d0.value);

            let modelSeries = yValues.slice();
            if (d === 1) {
                if (yValues.length < 3) {
                    resultsDiv.innerHTML = `<p class="text-red-600">資料筆數過少，無法進行一階差分後的 ARIMA 建模。</p>`;
                    return;
                }
                modelSeries = differenceSeries(yValues, 1);
            }

            if (modelSeries.length <= p + q + 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">資料筆數不足以支援 ARIMA(${p},${d},${q}) 建模（模型序列僅 ${modelSeries.length} 筆）。</p>`;
                return;
            }

            try {
                const params = estimateARIMA_HR(modelSeries, p, q);
                const { fitted, startIndex } = params;

                let absPercentErrors = [];
                for (let t = startIndex; t < modelSeries.length; t++) {
                    const actual = modelSeries[t];
                    const pred = fitted[t];
                    if (actual !== 0 && pred != null && !isNaN(pred)) {
                        absPercentErrors.push(Math.abs((actual - pred) / actual));
                    }
                }
                const mape = absPercentErrors.length > 0 ? ss.mean(absPercentErrors) * 100 : 0;

                const modelForecasts = forecastARIMA_HR(modelSeries, params, steps);

                let levelForecasts = [];
                if (d === 0) {
                    levelForecasts = modelForecasts.slice();
                } else {
                    const levelHistory = yValues.slice();
                    modelForecasts.forEach(df => {
                        const next = levelHistory[levelHistory.length - 1] + df;
                        levelHistory.push(next);
                        levelForecasts.push(next);
                    });
                }

                const originalX = seriesData.map(d0 =>
                    d0.time instanceof Date ? d0.time.toLocaleDateString() : d0.time
                );
                const futureX = [];
                const lastTime = seriesData[seriesData.length - 1].time;
                if (lastTime instanceof Date) {
                    for (let i = 1; i <= steps; i++) {
                        const nextDate = new Date(lastTime);
                        nextDate.setMonth(nextDate.getMonth() + i);
                        futureX.push(nextDate.toLocaleDateString());
                    }
                } else if (!isNaN(lastTime)) {
                    for (let i = 1; i <= steps; i++) futureX.push(lastTime + i);
                } else {
                    for (let i = 1; i <= steps; i++) futureX.push(`預測 ${i}`);
                }

                const plotDiv = document.createElement('div');
                plotDiv.id = 'arimaForecastPlot';
                resultsDiv.appendChild(plotDiv);

                const traces = [];
                traces.push({
                    x: originalX,
                    y: yValues,
                    mode: 'lines+markers',
                    name: '原始數據'
                });

                if (d === 0) {
                    const fittedLevel = new Array(yValues.length).fill(null);
                    for (let t = startIndex; t < yValues.length; t++) {
                        fittedLevel[t] = fitted[t];
                    }
                    traces.push({
                        x: originalX,
                        y: fittedLevel,
                        mode: 'lines',
                        name: 'ARIMA 擬合值',
                        line: { dash: 'dot' }
                    });
                }

                traces.push({
                    x: futureX,
                    y: levelForecasts,
                    mode: 'lines+markers',
                    name: `ARIMA(${p},${d},${q}) 預測`
                });

                const layout = {
                    title: `${valueVar} ARIMA(${p},${d},${q}) 預測`,
                    xaxis: { title: timeVar, type: 'category' },
                    yaxis: { title: valueVar },
                    showlegend: true,
                    paper_bgcolor: '#f9f9f9',
                    plot_bgcolor: '#f9f9f9'
                };
                Plotly.newPlot('arimaForecastPlot', traces, layout, { responsive: true });

                let noteText = d === 0
                    ? 'MAPE 以原始序列（未差分）建模後的殘差計算。'
                    : 'MAPE 係以差分後序列為基準，適合作為模型相對比較指標。';

                let resultHtml = `
                <div class="mt-4 p-4 bg-orange-50 border-l-4 border-orange-500 rounded-r-lg">
                    <h4 class="font-bold">ARIMA 模型摘要</h4>
                    <p class="text-gray-700 mt-1">
                        選用模型：<strong>ARIMA(${p}, ${d}, ${q})</strong>
                    </p>
                    <p class="text-gray-700 mt-1">
                        平均絕對百分比誤差 (MAPE): <strong>${mape.toFixed(2)}%</strong>（${noteText}）
                    </p>
                    <p class="text-xs text-gray-500 mt-1">
                        本工具實作為教學用 ARIMA(p, d, q)：在純 JavaScript 環境下，
                        以 Hannan–Rissanen 兩階段 OLS 近似估計 AR(φ) 與 MA(θ) 係數，並透過差分處理趨勢。
                    </p>
                </div>
                <h3 class="text-lg font-semibold mt-6 mb-2">預測值</h3>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">未來期數</th>
                                <th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">預測值</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
            `;
                levelForecasts.forEach((val, i) => {
                    resultHtml += `
                    <tr>
                        <td class="p-2 whitespace-nowrap text-sm font-medium text-gray-900">${futureX[i]}</td>
                        <td class="p-2 text-sm text-gray-500">${val.toFixed(3)}</td>
                    </tr>
                `;
                });
                resultHtml += `</tbody></table></div>`;
                resultsDiv.innerHTML += resultHtml;

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">ARIMA 預測時發生錯誤: ${error.message}</p>`;
            }
        }



        // --- Croston 間歇性需求預測（專業版：α 控制需求大小，β 控制到達間隔，並回報 MAPE） ---
        function crostonForecast(series, alpha, beta) {
            // series 為非負需求量，允許出現許多 0（間歇性需求）
            const n = series.length;
            let firstNonZeroIndex = -1;
            for (let i = 0; i < n; i++) {
                if (series[i] > 0) {
                    firstNonZeroIndex = i;
                    break;
                }
            }
            if (firstNonZeroIndex === -1) {
                throw new Error('資料中完全沒有正需求，無法套用 Croston 方法。');
            }

            // 初始化：第一個正需求大小與平均間隔
            let z = series[firstNonZeroIndex]; // 需求大小平滑值
            let p = 1;                         // 間隔平滑值
            let lastDemandIndex = firstNonZeroIndex;

            let totalDemand = z;
            let demandCount = 1;
            const intervals = [];

            // 逐期更新
            for (let t = firstNonZeroIndex + 1; t < n; t++) {
                const y = series[t];
                if (y > 0) {
                    const interval = t - lastDemandIndex;
                    lastDemandIndex = t;
                    intervals.push(interval);

                    // 需求大小平滑（α）
                    z = alpha * y + (1 - alpha) * z;
                    // 間隔平滑（β）
                    p = beta * interval + (1 - beta) * p;

                    totalDemand += y;
                    demandCount += 1;
                }
                // 若為 0 需求則維持 z、p 不變
            }

            if (p === 0) {
                throw new Error('間隔平滑值為 0，請檢查資料是否適合 Croston 方法。');
            }

            const levelForecast = z / p;
            const demandDensity = demandCount / n;
            const avgDemand = totalDemand / demandCount;
            const avgInterval = intervals.length > 0 ? ss.mean(intervals) : null;

            return { levelForecast, demandCount, demandDensity, avgDemand, avgInterval };
        }

        function runCrostonForecast() {
            const timeVar = document.getElementById('crostonTimeVar').value;
            const valueVar = document.getElementById('crostonValueVar').value;
            let alpha = parseFloat(document.getElementById('crostonAlpha').value);
            let beta = parseFloat(document.getElementById('crostonBeta').value);
            const steps = parseInt(document.getElementById('crostonSteps').value);
            const resultsDiv = document.getElementById('crostonResults');
            resultsDiv.innerHTML = '';

            if (!timeVar || !valueVar || !steps) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇時間欄位、需求量欄位，並設定平滑係數與預測期數。</p>`;
                return;
            }
            if (isNaN(alpha) || alpha <= 0 || alpha > 1) {
                alpha = 0.3;
            }
            if (isNaN(beta) || beta <= 0 || beta > 1) {
                beta = 0.3;
            }

            const seriesData = jsonData
                .map(row => ({ time: row[timeVar], value: row[valueVar] }))
                .filter(d0 => d0.time != null && typeof d0.value === 'number');

            if (seriesData.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">找不到有效的時間序列資料，請確認欄位內容。</p>`;
                return;
            }

            // 依時間排序
            seriesData.sort((a, b) => a.time < b.time ? -1 : 1);
            const yValues = seriesData.map(d0 => d0.value);

            try {
                const stats = crostonForecast(yValues, alpha, beta);
                const levelForecast = stats.levelForecast;

                // 只針對非零需求期計算 MAPE
                const positiveDemands = yValues.filter(v => v > 0);
                let absPercentErrors = [];
                positiveDemands.forEach(v => {
                    if (v !== 0) {
                        absPercentErrors.push(Math.abs((v - levelForecast) / v));
                    }
                });
                const mape = absPercentErrors.length > 0 ? ss.mean(absPercentErrors) * 100 : NaN;

                const demandDensityPercent = stats.demandDensity * 100;

                // 建立未來 X 軸標籤（與其他方法一致）
                const originalX = seriesData.map(d0 =>
                    d0.time instanceof Date ? d0.time.toLocaleDateString() : d0.time
                );
                const futureX = [];
                const lastTime = seriesData[seriesData.length - 1].time;
                if (lastTime instanceof Date) {
                    for (let i = 1; i <= steps; i++) {
                        const nextDate = new Date(lastTime);
                        nextDate.setMonth(nextDate.getMonth() + i);
                        futureX.push(nextDate.toLocaleDateString());
                    }
                } else if (!isNaN(lastTime)) {
                    for (let i = 1; i <= steps; i++) futureX.push(lastTime + i);
                } else {
                    for (let i = 1; i <= steps; i++) futureX.push(`預測 ${i}`);
                }

                // Croston 的預測值在未來每一期皆相同
                const forecastSeries = new Array(steps).fill(levelForecast);

                const plotDiv = document.createElement('div');
                plotDiv.id = 'crostonForecastPlot';
                resultsDiv.appendChild(plotDiv);

                const traces = [
                    {
                        x: originalX,
                        y: yValues,
                        mode: 'lines+markers',
                        name: '原始需求'
                    },
                    {
                        x: futureX,
                        y: forecastSeries,
                        mode: 'lines+markers',
                        name: 'Croston 預測需求水準'
                    }
                ];

                const layout = {
                    title: `${valueVar} Croston 間歇需求預測`,
                    xaxis: { title: timeVar, type: 'category' },
                    yaxis: { title: valueVar },
                    showlegend: true,
                    paper_bgcolor: '#f9f9f9',
                    plot_bgcolor: '#f9f9f9'
                };
                Plotly.newPlot('crostonForecastPlot', traces, layout, { responsive: true });

                const mapeText = isNaN(mape)
                    ? '—'
                    : `${mape.toFixed(2)}%`;

                const avgDemandText = stats.avgDemand != null && !isNaN(stats.avgDemand)
                    ? stats.avgDemand.toFixed(3)
                    : '—';

                const avgIntervalText = stats.avgInterval != null && !isNaN(stats.avgInterval)
                    ? stats.avgInterval.toFixed(2)
                    : '—';

                let resultHtml = `
                <div class="mt-4 p-4 bg-lime-50 border-l-4 border-lime-500 rounded-r-lg">
                    <h4 class="font-bold">Croston 模型摘要（專業版）</h4>
                    <p class="text-gray-700 mt-1">
                        估計之平均需求水準：<strong>${levelForecast.toFixed(3)}</strong>
                    </p>
                    <p class="text-gray-700 mt-1">
                        需求密度：<strong>${demandDensityPercent.toFixed(1)}%</strong>（有需求期數 / 總期數）
                    </p>
                    <p class="text-gray-700 mt-1">
                        平均每次需求量：<strong>${avgDemandText}</strong>；平均到達間隔：<strong>${avgIntervalText}</strong> 期
                    </p>
                    <p class="text-gray-700 mt-1">
                        MAPE（僅針對非零需求期）：<strong>${mapeText}</strong>
                    </p>
                    <p class="text-xs text-gray-500 mt-1">
                        α 控制「每次需求大小」的平滑速度，β 控制「需求到達間隔」的平滑速度；本實作適合用於備品、慢料等間歇性需求模型的教學與比較。
                    </p>
                </div>
                <h3 class="text-lg font-semibold mt-6 mb-2">預測值</h3>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">未來期數</th>
                                <th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">預測需求</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
            `;
                forecastSeries.forEach((val, i) => {
                    resultHtml += `
                    <tr>
                        <td class="p-2 whitespace-nowrap text-sm font-medium text-gray-900">${futureX[i]}</td>
                        <td class="p-2 text-sm text-gray-500">${val.toFixed(3)}</td>
                    </tr>
                `;
                });
                resultHtml += `</tbody></table></div>`;
                resultsDiv.innerHTML += resultHtml;

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">Croston 預測時發生錯誤: ${error.message}</p>`;
            }
        }

        // --- Lightweight matrix utilities (avoid jStat shape pitfalls) ---
        function _eye(n) { return Array.from({ length: n }, (_, i) => Array.from({ length: n }, (_, j) => i === j ? 1 : 0)); }
        function _T(A) {
            const m = A.length, n = A[0].length; const AT = Array.from({ length: n }, () => Array(m).fill(0));
            for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { AT[j][i] = A[i][j]; } } return AT;
        }
        function _mul(A, B) { // (m×n)*(n×p) -> (m×p)
            const m = A.length, n = A[0].length, p = B[0].length; const C = Array.from({ length: m }, () => Array(p).fill(0));
            for (let i = 0; i < m; i++) {
                for (let k = 0; k < n; k++) {
                    const aik = A[i][k];
                    for (let j = 0; j < p; j++) { C[i][j] += aik * B[k][j]; }
                }
            } return C;
        }
        function _add(A, B) { return A.map((r, i) => r.map((v, j) => v + B[i][j])); }
        function _scale(A, c) { return A.map(r => r.map(v => v * c)); }
        function _invGauss(M) {
            const n = M.length; const A = M.map(r => r.slice()); const I = _eye(n);
            for (let i = 0; i < n; i++) {
                let piv = i; for (let r = i + 1; r < n; r++) if (Math.abs(A[r][i]) > Math.abs(A[piv][i])) piv = r;
                if (Math.abs(A[piv][i]) < 1e-12) throw new Error('矩陣不可逆（可能共線）');
                if (piv !== i) { [A[i], A[piv]] = [A[piv], A[i]];[I[i], I[piv]] = [I[piv], I[i]]; }
                const d = A[i][i]; for (let j = 0; j < n; j++) { A[i][j] /= d; I[i][j] /= d; }
                for (let r = 0; r < n; r++) if (r !== i) {
                    const f = A[r][i];
                    for (let j = 0; j < n; j++) { A[r][j] -= f * A[i][j]; I[r][j] -= f * I[i][j]; }
                }
            }
            return I;
        }

        // --- Logistic Regression with robust IRLS + Ridge ---
        function runLogistic() {
            const yVar = document.getElementById('logisticY').value;
            const xVars = Array.from(document.getElementById('logisticX').selectedOptions).map(opt => opt.value);
            const resultsDiv = document.getElementById('logisticResults');
            resultsDiv.innerHTML = '';
            logisticModel = null; // Reset the model

            if (!yVar || xVars.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇應變數 (Y) 和至少一個自變數 (X)。</p>`; return;
            }

            const uniqueY = [...new Set(jsonData.map(row => row[yVar]).filter(v => v != null))].sort();
            if (uniqueY.length !== 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">應變數必須為二元類別 (只有兩種值)。</p>`; return;
            }

            const Xraw = [], y = [];
            for (const row of jsonData) {
                if (row[yVar] == null) continue;
                const feat = [];
                let ok = true;
                for (const k of xVars) {
                    const v = Number(row[k]);
                    if (!Number.isFinite(v)) { ok = false; break; }
                    feat.push(v);
                }
                if (!ok) continue;
                Xraw.push(feat);
                y.push(row[yVar] === uniqueY[1] ? 1 : 0);
            }

            if (Xraw.length < xVars.length + 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">有效的數值資料列不足 (${Xraw.length} 筆)，至少需要 ${xVars.length + 2} 筆。</p>`; return;
            }

            const n = Xraw.length, p0 = xVars.length;
            const means = Array(p0).fill(0), sds = Array(p0).fill(1);
            for (let j = 0; j < p0; j++) {
                const col = Xraw.map(r => r[j]);
                const m = jStat.mean(col); let sd = jStat.stdev(col, true); if (sd === 0) sd = 1;
                means[j] = m; sds[j] = sd;
                for (let i = 0; i < n; i++) Xraw[i][j] = (Xraw[i][j] - m) / sd;
            }

            const X = Xraw.map(r => [1, ...r]);
            const p = X[0].length;
            const lambda = 1e-4, maxIter = 50, tol = 1e-6;
            let beta = Array(p).fill(0).map(v => [v]);

            try {
                for (let it = 0; it < maxIter; it++) {
                    const eta = _mul(X, beta);
                    const pHat = eta.map(e => 1 / (1 + Math.exp(-e[0])));
                    const Wdiag = pHat.map(pi => Math.max(pi * (1 - pi), 1e-6));
                    const z = eta.map((e, i) => [e[0] + (y[i] - pHat[i]) / Wdiag[i]]);
                    const WX = X.map((row, i) => row.map(v => v * Wdiag[i]));
                    let XTWX = _mul(_T(X), WX);
                    const reg = _eye(p); reg[0][0] = 0;
                    XTWX = _add(XTWX, _scale(reg, lambda));
                    const XTWz = _mul(_T(WX), z);
                    const inv = _invGauss(XTWX);
                    const betaNew = _mul(inv, XTWz);
                    let diff = 0;
                    for (let j = 0; j < p; j++) { const d = betaNew[j][0] - beta[j][0]; diff += d * d; }
                    beta = betaNew;
                    if (Math.sqrt(diff) < tol) break;
                }

                const etaF = _mul(X, beta).map(v => v[0]);
                const Wf = etaF.map(e => { const pi = 1 / (1 + Math.exp(-e)); return Math.max(pi * (1 - pi), 1e-6); });
                const WXf = X.map((row, i) => row.map(v => v * Wf[i]));
                let XTWXf = _mul(_T(X), WXf);
                const reg_final = _eye(p); reg_final[0][0] = 0;
                XTWXf = _add(XTWXf, _scale(reg_final, lambda));
                const cov = _invGauss(XTWXf);
                const se = cov.map((row, i) => Math.sqrt(Math.max(row[i], 0)));
                const betaVec = beta.map(b => b[0]);
                const zScores = betaVec.map((b, i) => se[i] === 0 ? 0 : b / se[i]);
                const pVals = zScores.map(z => 2 * (1 - jStat.normal.cdf(Math.abs(z), 0, 1)));
                const OR = betaVec.map(b => Math.exp(b));

                // Store model for prediction
                logisticModel = { beta: betaVec, xVars, uniqueY, means, sds };

                let html = `<h3 class="text-lg font-semibold mb-2">邏輯斯迴歸模型結果（IRLS + Ridge）</h3>
          <p class="text-sm text-gray-600 mb-4">Y 編碼：${uniqueY[1]} = 1，${uniqueY[0]} = 0</p>
          <div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200">
          <thead class="bg-gray-50"><tr>
            <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">變數</th>
            <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">β</th>
            <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">SE</th>
            <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">z</th>
            <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">p</th>
            <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">OR</th>
          </thead><tbody class="bg-white divide-y divide-gray-200">`;
                const names = ['截距 (Intercept)', ...xVars];
                for (let j = 0; j < p; j++) {
                    html += `<tr>
            <td class="px-4 py-2 text-sm">${names[j]}</td>
            <td class="px-4 py-2 text-sm text-right">${betaVec[j].toFixed(6)}</td>
            <td class="px-4 py-2 text-sm text-right">${se[j].toFixed(6)}</td>
            <td class="px-4 py-2 text-sm text-right">${zScores[j].toFixed(3)}</td>
            <td class="px-4 py-2 text-sm text-right">${pVals[j] < 1e-6 ? '&lt;1e-6' : pVals[j].toFixed(6)}</td>
            <td class="px-4 py-2 text-sm text-right">${OR[j].toFixed(4)}</td>
          </tr>`;
                }
                html += `</tbody></table></div>
          <div class="mt-3 p-3 bg-blue-50 border rounded text-xs">
            解讀：OR>1 表示變數增加，事件（=1）勝算提高；OR<1 表示降低。若遇到分離或高度共線，請減少特徵或增大 Ridge λ。
          </div>`;

                // === 計算分類指標 (Confusion Matrix & Metrics) ===
                const predictions = etaF.map(e => {
                    const prob = 1 / (1 + Math.exp(-e));
                    return prob >= 0.5 ? 1 : 0;
                });

                // Build confusion matrix
                let TP = 0, TN = 0, FP = 0, FN = 0;
                for (let i = 0; i < y.length; i++) {
                    if (y[i] === 1 && predictions[i] === 1) TP++;
                    else if (y[i] === 0 && predictions[i] === 0) TN++;
                    else if (y[i] === 0 && predictions[i] === 1) FP++;
                    else if (y[i] === 1 && predictions[i] === 0) FN++;
                }

                // Calculate metrics
                const accuracy = (TP + TN) / (TP + TN + FP + FN);
                const precision = TP + FP > 0 ? TP / (TP + FP) : 0;
                const recall = TP + FN > 0 ? TP / (TP + FN) : 0;
                const f1Score = precision + recall > 0 ? 2 * (precision * recall) / (precision + recall) : 0;

                // Add metrics display
                html += `
          <div class="mt-6 border-t pt-6">
            <h4 class="text-lg font-semibold mb-4 flex items-center gap-2">
              <svg class="w-5 h-5 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
              </svg>
              模型分類指標 (Classification Metrics)
            </h4>
            
            <!-- Metrics Cards Grid -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
              <div class="bg-gradient-to-br from-green-50 to-emerald-50 p-4 rounded-lg border border-green-200 shadow-sm">
                <div class="text-xs font-medium text-green-700 mb-1">Accuracy 準確率</div>
                <div class="text-2xl font-bold text-green-600">${(accuracy * 100).toFixed(2)}%</div>
              </div>
              <div class="bg-gradient-to-br from-blue-50 to-indigo-50 p-4 rounded-lg border border-blue-200 shadow-sm">
                <div class="text-xs font-medium text-blue-700 mb-1">Precision 精確率</div>
                <div class="text-2xl font-bold text-blue-600">${(precision * 100).toFixed(2)}%</div>
              </div>
              <div class="bg-gradient-to-br from-purple-50 to-violet-50 p-4 rounded-lg border border-purple-200 shadow-sm">
                <div class="text-xs font-medium text-purple-700 mb-1">Recall 召回率</div>
                <div class="text-2xl font-bold text-purple-600">${(recall * 100).toFixed(2)}%</div>
              </div>
              <div class="bg-gradient-to-br from-orange-50 to-amber-50 p-4 rounded-lg border border-orange-200 shadow-sm">
                <div class="text-xs font-medium text-orange-700 mb-1">F1-Score</div>
                <div class="text-2xl font-bold text-orange-600">${(f1Score * 100).toFixed(2)}%</div>
              </div>
            </div>

            <!-- Confusion Matrix -->
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 mb-4">
              <h5 class="font-semibold text-gray-700 mb-3">混淆矩陣 (Confusion Matrix)</h5>
              <div class="flex justify-center items-center gap-3">
                <div class="font-semibold text-gray-700 text-sm" style="writing-mode: vertical-lr; transform: rotate(180deg); letter-spacing: 0.1em;">Actual</div>
                <table class="text-sm" style="border-collapse: separate; border-spacing: 0;">
                  <thead>
                    <tr>
                      <th class="px-3 py-2"></th>
                      <th colspan="2" class="px-4 py-2 text-center font-semibold text-gray-700 border-b-2 border-gray-400">Predicted</th>
                    </tr>
                    <tr>
                      <th class="px-3 py-2"></th>
                      <th class="px-6 py-2 text-center font-medium bg-blue-50 border border-gray-300">${uniqueY[1]}</th>
                      <th class="px-6 py-2 text-center font-medium bg-blue-50 border border-gray-300">${uniqueY[0]}</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <th class="px-4 py-3 text-center font-medium bg-blue-50 border border-gray-300">${uniqueY[1]}</th>
                      <td class="px-6 py-3 text-center font-bold text-green-700 bg-green-100 border border-gray-300" style="min-width: 60px;">${TP}</td>
                      <td class="px-6 py-3 text-center font-bold text-red-700 bg-red-100 border border-gray-300" style="min-width: 60px;">${FN}</td>
                    </tr>
                    <tr>
                      <th class="px-4 py-3 text-center font-medium bg-blue-50 border border-gray-300">${uniqueY[0]}</th>
                      <td class="px-6 py-3 text-center font-bold text-red-700 bg-red-100 border border-gray-300">${FP}</td>
                      <td class="px-6 py-3 text-center font-bold text-green-700 bg-green-100 border border-gray-300">${TN}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <div class="mt-3 text-xs text-gray-600">
                <div class="grid grid-cols-2 gap-2">
                  <div><strong>TP (True Positive)</strong>: ${TP} - 正確預測為陽性</div>
                  <div><strong>TN (True Negative)</strong>: ${TN} - 正確預測為陰性</div>
                  <div><strong>FP (False Positive)</strong>: ${FP} - 誤判為陽性</div>
                  <div><strong>FN (False Negative)</strong>: ${FN} - 誤判為陰性</div>
                </div>
              </div>
            </div>

            <!-- Metrics Explanation -->
            <div class="bg-indigo-50 p-4 rounded-lg border border-indigo-200">
              <h5 class="font-semibold text-indigo-900 mb-2">📊 指標說明</h5>
              <div class="text-xs text-indigo-800 space-y-2">
                <div><strong>Accuracy (準確率)</strong>: 所有預測中正確的比例 = (TP + TN) / 總數。適合平衡資料集。</div>
                <div><strong>Precision (精確率)</strong>: 預測為陽性中真正為陽性的比例 = TP / (TP + FP)。關注「預測的準確性」。</div>
                <div><strong>Recall (召回率)</strong>: 實際為陽性中被正確預測的比例 = TP / (TP + FN)。關注「找出所有陽性樣本」。</div>
                <div><strong>F1-Score</strong>: Precision 和 Recall 的調和平均數，平衡兩者。適合不平衡資料集。</div>
              </div>
            </div>
          </div>`;

                resultsDiv.innerHTML = html;

                // Add prediction interface - v2.2 增強版：使用DOM元素創建以確保正確性
                const predictionContainer = document.createElement('div');
                predictionContainer.id = 'logisticPredictionInterface';
                predictionContainer.className = 'mt-8 pt-6 border-t';

                const title = document.createElement('h3');
                title.className = 'text-lg font-semibold mb-4';
                title.textContent = '進行預測';
                predictionContainer.appendChild(title);

                const inputGrid = document.createElement('div');
                inputGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';

                xVars.forEach((varName, idx) => {
                    // v2.5.1 修復: 使用索引ID避免中文變數名衝突
                    const inputId = `pred_in_${idx}`;

                    const inputDiv = document.createElement('div');

                    const label = document.createElement('label');
                    label.htmlFor = inputId;
                    label.className = 'block text-sm font-medium text-gray-700';
                    label.textContent = varName;  // 直接設定textContent確保正確
                    label.setAttribute('data-var-name', varName);  // 額外保存
                    label.setAttribute('data-var-index', idx);

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.id = inputId;
                    input.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm';
                    input.placeholder = `請輸入${varName}`;
                    input.setAttribute('data-var-name', varName);
                    input.setAttribute('data-var-index', idx);
                    input.step = 'any';

                    inputDiv.appendChild(label);
                    inputDiv.appendChild(input);
                    inputGrid.appendChild(inputDiv);

                    console.log(`✅ 創建輸入欄位 [${idx}]: "${varName}" -> ID: ${inputId}`);
                });

                predictionContainer.appendChild(inputGrid);

                // Use HTML string for button to ensure onclick works reliably
                const btnContainer = document.createElement('div');
                btnContainer.innerHTML = `
                    <button id="runPredictionBtn" onclick="predictLogistic()" class="mt-4 bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors shadow-md flex items-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>
                        計算機率
                    </button>
                `;
                predictionContainer.appendChild(btnContainer);

                const resultDiv = document.createElement('div');
                resultDiv.id = 'predictionResult';
                resultDiv.className = 'mt-4 text-lg font-semibold hidden'; // Default hidden
                predictionContainer.appendChild(resultDiv);

                resultsDiv.appendChild(predictionContainer);
                console.log('✅ 預測介面已創建 (使用 onclick)');

            } catch (err) {
                resultsDiv.innerHTML = `<p class="text-red-600">建立模型時發生錯誤：${err.message}</p>`;
            }
        }

        // ===== v2.5 革命性修復: 使用 Modal 彈窗顯示預測結果 =====
        // Explicitly attach to window to ensure global scope access
        window.predictLogistic = function () {
            try {
                console.log('🔵 predictLogistic 被調用了！');
                if (!logisticModel) {
                    alert('❌ 錯誤：模型不存在，請先執行邏輯斯迴歸。');
                    return;
                }

                const { beta, xVars, uniqueY, means, sds } = logisticModel;

                // 讀取輸入值
                let inputValues = [];
                for (let idx = 0; idx < xVars.length; idx++) {
                    const inputId = `pred_in_${idx}`;
                    const elem = document.getElementById(inputId);
                    if (!elem) throw new Error(`找不到輸入欄位: ${xVars[idx]}`);
                    const val = parseFloat(elem.value);
                    if (isNaN(val)) {
                        alert(`請輸入有效的數值：${xVars[idx]}`);
                        return;
                    }
                    inputValues.push(val);
                }

                // Standardize input
                const standardizedInputs = inputValues.map((val, i) => (val - means[i]) / sds[i]);

                // Add intercept and calculate eta
                const x_pred = [1, ...standardizedInputs];
                let eta = 0;
                for (let i = 0; i < x_pred.length; i++) {
                    eta += x_pred[i] * beta[i];
                }
                const probability = 1 / (1 + Math.exp(-eta));
                const prob_y1 = probability;
                const prob_y0 = 1 - probability;

                // Display results inline (consistent with other predictions)
                const resultDiv = document.getElementById('predictionResult');
                if (!resultDiv) {
                    alert('❌ 錯誤：找不到結果顯示區域');
                    return;
                }

                // Create inline result HTML
                const resultHtml = `
                    <div class="p-4 bg-white border border-indigo-200 rounded-lg shadow-sm">
                        <div class="mb-4 pb-3 border-b border-gray-200">
                            <p class="text-sm text-gray-600 mb-2">輸入資料：</p>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                ${xVars.map((v, idx) => `
                                    <div class="text-gray-700">
                                        <span class="font-medium">${v}:</span> 
                                        <span class="text-gray-900">${inputValues[idx]}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="space-y-3">
                            <div>
                                <div class="flex items-center justify-between mb-1">
                                    <span class="text-sm text-gray-600">結果為 <strong class="text-indigo-600">${uniqueY[1]}</strong> 的機率：</span>
                                    <span class="text-2xl font-bold text-indigo-600">${(prob_y1 * 100).toFixed(2)}%</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-3">
                                    <div class="bg-indigo-600 h-3 rounded-full transition-all duration-500" style="width: ${(prob_y1 * 100).toFixed(2)}%"></div>
                                </div>
                            </div>
                            <div>
                                <div class="flex items-center justify-between mb-1">
                                    <span class="text-sm text-gray-600">結果為 <strong class="text-gray-600">${uniqueY[0]}</strong> 的機率：</span>
                                    <span class="text-xl font-bold text-gray-500">${(prob_y0 * 100).toFixed(2)}%</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-3">
                                    <div class="bg-gray-400 h-3 rounded-full transition-all duration-500" style="width: ${(prob_y0 * 100).toFixed(2)}%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                resultDiv.innerHTML = resultHtml;
                resultDiv.classList.remove('hidden');
                console.log('✅ 預測結果已顯示（內聯方式）');

            } catch (e) {
                console.error(e);
                alert(`預測時發生錯誤: ${e.message}`);
            }
        };

        // 確保 closeModal 全域可見
        // 確保 closeModal 全域可見
        window.closeModal = function () {
            const modal = document.getElementById('predictionModal');
            if (modal) {
                modal.classList.remove('show');
                console.log('🚪 Modal 已關閉');
            } else {
                console.error('❌ 找不到 predictionModal 元素');
            }
        };


        /**
         * Robust feature importance from ml.js Decision Tree JSON.
         * Directly accumulates the library-provided 'gain' at each split node.
         * Supports multiple JSON shapes and field names across ml.js versions.
         * @param {object} treeJson - regressor.toJSON() (or its .root)
         * @param {number} numFeatures - number of X variables used in training
         * @returns {number[]} normalized importance for each feature index (length = numFeatures)
         */
        function calculateDtImportance(treeJson, numFeatures) {
            const importances = new Array(numFeatures).fill(0);
            const root = (treeJson && typeof treeJson === 'object' && treeJson.root) ? treeJson.root : treeJson;

            function childKeys(node) {
                const keys = [];
                if (!node || typeof node !== 'object') return keys;
                if (node.left) keys.push('left');
                if (node.right) keys.push('right');
                if (node.trueBranch) keys.push('trueBranch');
                if (node.falseBranch) keys.push('falseBranch');
                if (Array.isArray(node.children)) return ['children'];
                return keys;
            }
            function featureIndex(node) {
                const cand = ['splitColumn', 'column', 'attribute', 'feature', 'index'];
                for (const k of cand) {
                    if (node[k] !== undefined && node[k] !== null && Number.isFinite(+node[k])) return +node[k];
                }
                return null;
            }
            function nodeGain(node) {
                const cand = ['gain', 'gainRatio', 'impurityReduction', 'varianceReduction'];
                for (const k of cand) {
                    if (node[k] !== undefined && node[k] !== null && Number.isFinite(+node[k])) return +node[k];
                }
                return 0;
            }
            function traverse(node) {
                if (!node || typeof node !== 'object') return;
                const fi = featureIndex(node);
                const g = nodeGain(node);
                if (fi !== null && g > 0 && fi >= 0 && fi < importances.length) importances[fi] += g;
                const cks = childKeys(node);
                if (cks.includes('children')) {
                    for (const child of node.children) traverse(child);
                } else {
                    if (node.left) traverse(node.left);
                    if (node.right) traverse(node.right);
                    if (node.trueBranch) traverse(node.trueBranch);
                    if (node.falseBranch) traverse(node.falseBranch);
                }
            }
            traverse(root);
            const total = importances.reduce((a, b) => a + b, 0);
            if (total > 0) for (let i = 0; i < importances.length; i++) importances[i] /= total;
            return importances;
        }

        function runDecisionTree() {
            const yVar = document.getElementById('dtY').value;
            const xVars = Array.from(document.getElementById('dtX').selectedOptions).map(opt => opt.value);
            const maxDepth = parseInt(document.getElementById('dtMaxDepth').value);
            const minSamplesLeaf = parseInt(document.getElementById('dtMinSamplesLeaf').value);
            const resultsDiv = document.getElementById('dtResults');
            resultsDiv.innerHTML = '';

            if (!yVar || xVars.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇應變數 (Y) 和至少一個自變數 (X)。</p>`;
                return;
            }

            const encoders = {};
            xVars.forEach(header => {
                if (categoricalHeaders.includes(header)) {
                    const uniqueValues = [...new Set(jsonData.map(row => row[header]).filter(v => v != null))];
                    encoders[header] = {};
                    uniqueValues.forEach((val, i) => { encoders[header][val] = i; });
                }
            });

            const X = [], y = [];
            for (const row of jsonData) {
                let isValidRow = true;
                const featureRow = [];
                for (const xVar of xVars) {
                    const val = row[xVar];
                    if (val == null) { isValidRow = false; break; }
                    featureRow.push(categoricalHeaders.includes(xVar) ? encoders[xVar][val] : val);
                }
                const yVal = row[yVar];
                if (yVal == null || typeof yVal !== 'number') isValidRow = false;

                if (isValidRow) {
                    X.push(featureRow);
                    y.push(yVal);
                }
            }

            if (X.length < 5) {
                resultsDiv.innerHTML = `<p class="text-red-600">有效的資料列不足 (${X.length} 筆)，無法建立決策樹模型。</p>`;
                return;
            }

            try {
                const options = { maxDepth: maxDepth, minNumSamples: minSamplesLeaf };
                const regressor = new ML.DecisionTreeRegression(options);
                regressor.train(X, y);

                const modelJSON = regressor.toJSON();
                const importancesArray = calculateDtImportance(modelJSON, xVars.length);
                const importances = importancesArray.map((imp, index) => ({
                    featureIndex: index,
                    importance: imp
                })).sort((a, b) => b.importance - a.importance);

                let html = `<h3 class="text-lg font-semibold mb-2">迴歸決策樹模型結果</h3>
                        <p class="text-sm text-gray-600 mb-4">模型已成功建立。以下為各個自變數對預測結果的貢獻度排序。</p>`;
                html += `<div id="dtImportancePlot"></div>`;
                html += `<h4 class="text-md font-semibold mt-6 mb-2">特徵貢獻度 (Variance Reduction)</h4>
                     <div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200">
                     <thead class="bg-gray-50"><tr>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">變數</th>
                        <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">貢獻度</th>
                     </tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
                importances.forEach(imp => {
                    html += `<tr>
                            <td class="px-4 py-2 text-sm font-medium text-gray-900">${xVars[imp.featureIndex]}</td>
                            <td class="px-4 py-2 text-sm text-right text-gray-500">${imp.importance.toFixed(4)}</td>
                         </tr>`;
                });
                html += `</tbody></table></div>
                     <div class="mt-3 p-3 bg-amber-50 border rounded text-xs">
                        解讀：貢獻度越高，表示該變數在預測數值結果時，提供了越多的資訊，是越重要的因子。
                     </div>`;
                resultsDiv.innerHTML = html;

                const plotLabels = importances.map(imp => xVars[imp.featureIndex]);
                const plotValues = importances.map(imp => imp.importance);
                const plotTrace = {
                    x: plotValues.reverse(),
                    y: plotLabels.reverse(),
                    type: 'bar',
                    orientation: 'h',
                    marker: { color: 'rgb(217, 119, 6)' }
                };
                const plotLayout = {
                    title: '特徵貢獻度排序',
                    xaxis: { title: '貢獻度 (基於變異數減少量)' },
                    margin: { l: 150 }
                };
                Plotly.newPlot('dtImportancePlot', [plotTrace], plotLayout, { responsive: true });

            } catch (err) {
                resultsDiv.innerHTML = `<p class="text-red-600">建立模型時發生錯誤：${err.message}</p>`;
            }
        }

        function runCorrelationMatrix() {
            const resultsDiv = document.getElementById('correlationMatrixResults');
            resultsDiv.innerHTML = '';

            if (numericHeaders.length < 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">需要至少兩個數值欄位才能計算相關係數矩陣。</p>`;
                return;
            }

            const correlationMatrix = [];
            const numVars = numericHeaders.length;

            for (let i = 0; i < numVars; i++) {
                correlationMatrix[i] = [];
                for (let j = 0; j < numVars; j++) {
                    if (i === j) {
                        correlationMatrix[i][j] = 1;
                        continue;
                    }
                    if (j < i) { // Matrix is symmetric, copy value
                        correlationMatrix[i][j] = correlationMatrix[j][i];
                        continue;
                    }

                    // Pairwise deletion for correlation calculation
                    const pairs = [];
                    for (let k = 0; k < jsonData.length; k++) {
                        const val1 = jsonData[k][numericHeaders[i]];
                        const val2 = jsonData[k][numericHeaders[j]];
                        if (typeof val1 === 'number' && !isNaN(val1) && typeof val2 === 'number' && !isNaN(val2)) {
                            pairs.push([val1, val2]);
                        }
                    }

                    if (pairs.length < 2) {
                        correlationMatrix[i][j] = NaN; // Not enough data
                        continue;
                    }

                    const seriesX = pairs.map(p => p[0]);
                    const seriesY = pairs.map(p => p[1]);

                    const corr = ss.sampleCorrelation(seriesX, seriesY);
                    correlationMatrix[i][j] = isNaN(corr) ? 0 : corr; // Handle potential NaN from ss
                }
            }

            const plotDiv = document.createElement('div');
            plotDiv.id = 'correlationHeatmap';
            resultsDiv.appendChild(plotDiv);

            const data = [{
                z: correlationMatrix,
                x: numericHeaders,
                y: numericHeaders,
                type: 'heatmap',
                colorscale: 'RdBu',
                zmin: -1,
                zmax: 1,
                hoverongaps: false
            }];

            const layout = {
                title: '數值變數相關係數矩陣',
                xaxis: { ticks: '', side: 'top', automargin: true },
                yaxis: { ticks: '', automargin: true },
                annotations: correlationMatrix.map((row, i) =>
                    row.map((val, j) => ({
                        x: numericHeaders[j],
                        y: numericHeaders[i],
                        text: isNaN(val) ? 'N/A' : val.toFixed(2),
                        showarrow: false,
                        font: {
                            color: Math.abs(val) > 0.5 ? 'white' : 'black',
                            size: 10
                        }
                    }))
                ).flat()
            };

            Plotly.newPlot(plotDiv, data, layout, { responsive: true });
        }

        // --- Matrix Helper Functions ---
        function solveLinearSystem(A, b) {
            // 使用高斯消去法求解 Ax = b
            const n = A.length;
            const augmented = A.map((row, i) => [...row, b[i]]);

            // 前向消去
            for (let i = 0; i < n; i++) {
                // 找到主元素
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }

                // 交換行
                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

                // 檢查是否為零
                if (Math.abs(augmented[i][i]) < 1e-10) {
                    throw new Error('矩陣奇異或接近奇異');
                }

                // 消去
                for (let k = i + 1; k < n; k++) {
                    const factor = augmented[k][i] / augmented[i][i];
                    for (let j = i; j <= n; j++) {
                        augmented[k][j] -= factor * augmented[i][j];
                    }
                }
            }

            // 回代
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = augmented[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= augmented[i][j] * x[j];
                }
                x[i] /= augmented[i][i];
            }

            return x;
        }

        function invertMatrix(A) {
            // 使用高斯-約當消去法求矩陣逆
            const n = A.length;
            const augmented = A.map((row, i) => {
                const identityRow = new Array(n).fill(0);
                identityRow[i] = 1;
                return [...row, ...identityRow];
            });

            // 前向消去
            for (let i = 0; i < n; i++) {
                // 找到主元素
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }

                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

                if (Math.abs(augmented[i][i]) < 1e-10) {
                    throw new Error('矩陣不可逆');
                }

                // 正規化當前行
                const pivot = augmented[i][i];
                for (let j = 0; j < 2 * n; j++) {
                    augmented[i][j] /= pivot;
                }

                // 消去其他行
                for (let k = 0; k < n; k++) {
                    if (k !== i) {
                        const factor = augmented[k][i];
                        for (let j = 0; j < 2 * n; j++) {
                            augmented[k][j] -= factor * augmented[i][j];
                        }
                    }
                }
            }

            // 提取逆矩陣
            const inverse = augmented.map(row => row.slice(n));
            return inverse;
        }

        // --- Eigenvalue Decomposition Functions ---
        function eigenDecomposition(A, maxIterations = 100) {
            // 使用 Power Iteration + Deflation 求特徵值和特徵向量
            const n = A.length;
            const eigenvalues = [];
            const eigenvectors = [];

            let A_deflated = A.map(row => [...row]);

            for (let k = 0; k < n; k++) {
                // Power Iteration
                let v = new Array(n).fill(1).map(() => Math.random());
                let lambda = 0;

                for (let iter = 0; iter < maxIterations; iter++) {
                    // v_new = A * v
                    const v_new = new Array(n);
                    for (let i = 0; i < n; i++) {
                        v_new[i] = 0;
                        for (let j = 0; j < n; j++) {
                            v_new[i] += A_deflated[i][j] * v[j];
                        }
                    }

                    // 正規化
                    let norm = Math.sqrt(v_new.reduce((sum, val) => sum + val * val, 0));
                    if (norm < 1e-10) break;

                    for (let i = 0; i < n; i++) {
                        v_new[i] /= norm;
                    }

                    // 計算特徵值
                    lambda = 0;
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            lambda += v_new[i] * A_deflated[i][j] * v_new[j];
                        }
                    }

                    // 檢查收斂
                    let diff = 0;
                    for (let i = 0; i < n; i++) {
                        diff += Math.abs(v_new[i] - v[i]);
                    }

                    v = v_new;

                    if (diff < 1e-6) break;
                }

                eigenvalues.push(lambda);
                eigenvectors.push(v);

                // Deflation: A = A - λ * v * v'
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        A_deflated[i][j] -= lambda * v[i] * v[j];
                    }
                }
            }

            return { eigenvalues, eigenvectors };
        }

        function correlationMatrix(data) {
            // 計算相關矩陣
            const n = data.length;
            const p = data[0].length;

            // 標準化數據
            const means = [];
            const stds = [];
            for (let j = 0; j < p; j++) {
                const col = data.map(row => row[j]);
                means[j] = ss.mean(col);
                stds[j] = ss.standardDeviation(col);
            }

            const standardized = data.map(row =>
                row.map((val, j) => (val - means[j]) / (stds[j] || 1))
            );

            // 計算相關矩陣
            const corr = [];
            for (let i = 0; i < p; i++) {
                corr[i] = [];
                for (let j = 0; j < p; j++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += standardized[k][i] * standardized[k][j];
                    }
                    corr[i][j] = sum / (n - 1);
                }
            }

            return corr;
        }

        function varimax(loadings, maxIterations = 100) {
            // Varimax 旋轉
            const p = loadings.length;
            const k = loadings[0].length;

            if (k === 1) return loadings; // 單一因子不需旋轉

            let rotated = loadings.map(row => [...row]);

            for (let iter = 0; iter < maxIterations; iter++) {
                let changed = false;

                // 對每對因子進行旋轉
                for (let i = 0; i < k - 1; i++) {
                    for (let j = i + 1; j < k; j++) {
                        // 計算旋轉角度
                        let a = 0, b = 0, c = 0, d = 0;

                        for (let m = 0; m < p; m++) {
                            const x = rotated[m][i];
                            const y = rotated[m][j];
                            const u = x * x - y * y;
                            const v = 2 * x * y;
                            a += u;
                            b += v;
                            c += x * x + y * y;
                            d += u * u - v * v;
                        }

                        const num = 2 * p * b - 2 * a * c / p;
                        const den = p * d - (a * a - b * b);

                        if (Math.abs(den) < 1e-10) continue;

                        const tanAngle = num / den;
                        const angle = Math.atan(tanAngle) / 4;

                        if (Math.abs(angle) < 1e-6) continue;

                        changed = true;

                        // 應用旋轉
                        const cos = Math.cos(angle);
                        const sin = Math.sin(angle);

                        for (let m = 0; m < p; m++) {
                            const xi = rotated[m][i];
                            const xj = rotated[m][j];
                            rotated[m][i] = xi * cos - xj * sin;
                            rotated[m][j] = xi * sin + xj * cos;
                        }
                    }
                }

                if (!changed) break;
            }

            return rotated;
        }

        // --- Statistical Helper Functions ---
        function calculateSkewness(values) {
            // 計算偏態係數 (Skewness)
            const n = values.length;
            const mean = ss.mean(values);
            const std = ss.standardDeviation(values);
            if (std === 0) return 0;
            const sum = values.reduce((acc, val) => acc + Math.pow((val - mean) / std, 3), 0);
            return (n / ((n - 1) * (n - 2))) * sum;
        }

        function calculateKurtosis(values) {
            // 計算峨態係數 (Kurtosis) - Excess Kurtosis
            const n = values.length;
            const mean = ss.mean(values);
            const std = ss.standardDeviation(values);
            if (std === 0) return 0;
            const sum4 = values.reduce((acc, val) => acc + Math.pow((val - mean) / std, 4), 0);
            const kurtosis = (n * (n + 1) * sum4) / ((n - 1) * (n - 2) * (n - 3)) - (3 * Math.pow(n - 1, 2)) / ((n - 2) * (n - 3));
            return kurtosis;
        }

        // --- Regression Type Switching ---
        function switchRegressionType(type) {
            const simplePanel = document.getElementById('simpleRegressionPanel');
            const multiplePanel = document.getElementById('multipleRegressionPanel');
            const simpleTab = document.getElementById('simpleRegTab');
            const multipleTab = document.getElementById('multipleRegTab');

            if (type === 'simple') {
                simplePanel.style.display = 'block';
                multiplePanel.style.display = 'none';
                simpleTab.className = 'px-4 py-2 font-semibold border-b-2 border-purple-500 text-purple-600';
                multipleTab.className = 'px-4 py-2 font-semibold text-gray-500 hover:text-purple-600';
            } else {
                simplePanel.style.display = 'none';
                multiplePanel.style.display = 'block';
                simpleTab.className = 'px-4 py-2 font-semibold text-gray-500 hover:text-purple-600';
                multipleTab.className = 'px-4 py-2 font-semibold border-b-2 border-purple-500 text-purple-600';
            }
        }

        // --- Multiple Regression ---
        function runMultipleRegression() {
            const xSelects = document.getElementById('multipleRegressionX');
            const yVar = document.getElementById('multipleRegressionY').value;
            const resultsDiv = document.getElementById('regressionResults');
            resultsDiv.innerHTML = '';

            const xVars = Array.from(xSelects.selectedOptions).map(opt => opt.value);

            if (xVars.length === 0 || !yVar) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇至少一個自變數 (X) 與一個應變數 (Y)。</p>`;
                return;
            }

            if (xVars.includes(yVar)) {
                resultsDiv.innerHTML = `<p class="text-red-600">自變數與應變數不能重複。</p>`;
                return;
            }

            // 準備數據
            const rows = jsonData.filter(row => {
                return xVars.every(xVar => typeof row[xVar] === 'number') && typeof row[yVar] === 'number';
            });

            if (rows.length < xVars.length + 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">沒有足夠的完整數據進行多元迴歸分析。需要至少 ${xVars.length + 2} 筆。</p>`;
                return;
            }

            const n = rows.length;
            const k = xVars.length;

            // X 矩陣 (加上截距項)
            const X = rows.map(row => [1, ...xVars.map(xVar => row[xVar])]);
            const Y = rows.map(row => row[yVar]);

            // 手動矩陣運算
            // 計算 X'X
            const p = k + 1; // 包含截距
            const XtX = [];
            for (let i = 0; i < p; i++) {
                XtX[i] = [];
                for (let j = 0; j < p; j++) {
                    let sum = 0;
                    for (let r = 0; r < n; r++) {
                        sum += X[r][i] * X[r][j];
                    }
                    XtX[i][j] = sum;
                }
            }

            // 計算 X'Y
            const XtY = [];
            for (let i = 0; i < p; i++) {
                let sum = 0;
                for (let r = 0; r < n; r++) {
                    sum += X[r][i] * Y[r];
                }
                XtY[i] = sum;
            }

            // 使用高斯消去法求解 (X'X)β = X'Y
            let coefficients;
            try {
                coefficients = solveLinearSystem(XtX, XtY);
            } catch (e) {
                resultsDiv.innerHTML = `<p class="text-red-600">無法計算迴歸係數，可能是自變數之間存在完全共線性。錯誤：${e.message}</p>`;
                return;
            }

            // 預測值和殘差
            const predictions = X.map(row => row.reduce((sum, val, i) => sum + val * coefficients[i], 0));
            const residuals = Y.map((y, i) => y - predictions[i]);

            // SST, SSE, SSR
            const yMean = ss.mean(Y);
            const SST = Y.reduce((sum, y) => sum + Math.pow(y - yMean, 2), 0);
            const SSE = residuals.reduce((sum, r) => sum + r * r, 0);
            const SSR = SST - SSE;

            // R² 和調整後 R²
            const rSquared = SSR / SST;
            const adjRSquared = 1 - (SSE / (n - k - 1)) / (SST / (n - 1));

            // F 統計量
            const MSR = SSR / k;
            const MSE = SSE / (n - k - 1);
            const fStat = MSR / MSE;
            const pValueF = 1 - jStat.centralF.cdf(fStat, k, n - k - 1);

            // 係數的標準誤和 t 統計量
            const syx = Math.sqrt(MSE);

            // 計算 (X'X)^(-1)
            let XtX_inv;
            try {
                XtX_inv = invertMatrix(XtX);
            } catch (e) {
                resultsDiv.innerHTML = `<p class="text-red-600">無法計算標準誤，矩陣不可逆。</p>`;
                return;
            }

            // 計算標準誤
            const seCoeffs = [];
            for (let i = 0; i < p; i++) {
                seCoeffs[i] = Math.sqrt(XtX_inv[i][i] * MSE);
            }

            const tStats = coefficients.map((coef, i) => coef / seCoeffs[i]);
            const pValues = tStats.map(t => 2 * (1 - jStat.studentt.cdf(Math.abs(t), n - k - 1)));

            // 95% 信賴區間
            const tCritical = jStat.studentt.inv(0.975, n - k - 1);
            const CIs = coefficients.map((coef, i) => [coef - tCritical * seCoeffs[i], coef + tCritical * seCoeffs[i]]);

            // 輸出結果
            let resultHtml = `<h3 class="text-lg font-semibold mb-2">📊 多元線性迴歸結果</h3>`;

            // 模型摘要
            resultHtml += `<div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><tbody class="divide-y divide-gray-200"><tr><td class="px-6 py-3 font-medium text-gray-900">應變數 (Y)</td><td class="px-6 py-3 text-gray-700">${yVar}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">自變數 (X)</td><td class="px-6 py-3 text-gray-700">${xVars.join(', ')}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">樣本數</td><td class="px-6 py-3 text-gray-700">${n}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">R²</td><td class="px-6 py-3 text-gray-700 font-mono text-lg">${rSquared.toFixed(4)}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">調整後 R²</td><td class="px-6 py-3 text-gray-700 font-mono text-lg">${adjRSquared.toFixed(4)}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">標準誤 (S)</td><td class="px-6 py-3 text-gray-700 font-mono">${syx.toFixed(4)}</td></tr></tbody></table></div>`;

            // ANOVA 表
            resultHtml += `<h4 class="text-md font-semibold mb-2">ANOVA 表:</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">來源</th><th class="px-4 py-2 border">SS</th><th class="px-4 py-2 border">df</th><th class="px-4 py-2 border">MS</th><th class="px-4 py-2 border">F</th><th class="px-4 py-2 border">p-value</th></tr></thead><tbody><tr><td class="px-4 py-2 border font-medium">迴歸 Regression</td><td class="px-4 py-2 border">${SSR.toFixed(3)}</td><td class="px-4 py-2 border">${k}</td><td class="px-4 py-2 border">${MSR.toFixed(3)}</td><td class="px-4 py-2 border font-mono text-lg">${fStat.toFixed(4)}</td><td class="px-4 py-2 border font-mono text-lg">${pValueF.toFixed(4)}</td></tr><tr><td class="px-4 py-2 border font-medium">殘差 Residual</td><td class="px-4 py-2 border">${SSE.toFixed(3)}</td><td class="px-4 py-2 border">${n - k - 1}</td><td class="px-4 py-2 border">${MSE.toFixed(3)}</td><td class="px-4 py-2 border">-</td><td class="px-4 py-2 border">-</td></tr><tr><td class="px-4 py-2 border font-medium">總變異 Total</td><td class="px-4 py-2 border">${SST.toFixed(3)}</td><td class="px-4 py-2 border">${n - 1}</td><td class="px-4 py-2 border">-</td><td class="px-4 py-2 border">-</td><td class="px-4 py-2 border">-</td></tr></tbody></table></div>`;

            // 係數表
            resultHtml += `<h4 class="text-md font-semibold mb-2">係數表:</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">變數</th><th class="px-4 py-2 border">係數</th><th class="px-4 py-2 border">標準誤</th><th class="px-4 py-2 border">t 統計量</th><th class="px-4 py-2 border">p-value</th><th class="px-4 py-2 border">95% CI 下限</th><th class="px-4 py-2 border">95% CI 上限</th></tr></thead><tbody>`;
            resultHtml += `<tr><td class="px-4 py-2 border font-medium">截距 (Intercept)</td><td class="px-4 py-2 border font-mono">${coefficients[0].toFixed(4)}</td><td class="px-4 py-2 border">${seCoeffs[0].toFixed(4)}</td><td class="px-4 py-2 border">${tStats[0].toFixed(3)}</td><td class="px-4 py-2 border font-mono">${pValues[0].toFixed(4)}</td><td class="px-4 py-2 border">${CIs[0][0].toFixed(4)}</td><td class="px-4 py-2 border">${CIs[0][1].toFixed(4)}</td></tr>`;
            xVars.forEach((xVar, i) => {
                const idx = i + 1;
                resultHtml += `<tr><td class="px-4 py-2 border font-medium">${xVar}</td><td class="px-4 py-2 border font-mono">${coefficients[idx].toFixed(4)}</td><td class="px-4 py-2 border">${seCoeffs[idx].toFixed(4)}</td><td class="px-4 py-2 border">${tStats[idx].toFixed(3)}</td><td class="px-4 py-2 border font-mono">${pValues[idx].toFixed(4)}</td><td class="px-4 py-2 border">${CIs[idx][0].toFixed(4)}</td><td class="px-4 py-2 border">${CIs[idx][1].toFixed(4)}</td></tr>`;
            });
            resultHtml += `</tbody></table></div>`;

            // 結果判讀
            resultHtml += `<div class="mt-4 p-4 bg-purple-50 border-l-4 border-purple-500 rounded-r-lg"><h4 class="font-bold">結果判讀:</h4><ul class="text-gray-700 mt-1 space-y-1 list-disc list-inside"><li>調整後 R² = ${adjRSquared.toFixed(4)}，<strong>${(adjRSquared * 100).toFixed(1)}%</strong> 的 Y 變異可由 X 變數解釋。</li><li>模型整體顯著性：F(${k}, ${n - k - 1}) = ${fStat.toFixed(2)}, p = ${pValueF.toFixed(4)} ${pValueF < 0.05 ? '< 0.05 (<strong>顯著</strong>)' : '≥ 0.05 (不顯著)'}。</li></ul></div>`;

            resultsDiv.innerHTML = resultHtml;

            // 顯示預測區塊 (移至結果下方)
            const predictHtml = `
                <div id="multipleRegressionPredictSection" class="mt-8 border-t pt-6">
                    <h4 class="text-lg font-bold mb-4 flex items-center gap-2">
                        <svg class="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        多元迴歸預測
                    </h4>
                    <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                        <div id="predictionInputs" class="grid md:grid-cols-3 gap-4 mb-4">
                            ${xVars.map(xVar => `
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">${xVar}</label>
                                    <input type="number" id="pred_${xVar}" step="any" class="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500" placeholder="輸入數值">
                                </div>
                            `).join('')}
                        </div>
                        <button onclick="predictMultipleRegression()" class="bg-purple-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-purple-700 shadow-md transition-colors flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>
                            計算預測值
                        </button>
                        <div id="predictionResult" class="mt-4 hidden"></div>
                    </div>
                </div>
            `;
            resultsDiv.insertAdjacentHTML('beforeend', predictHtml);

            // 儲存係數供預測使用
            window.multipleRegressionCoeffs = coefficients;
            window.multipleRegressionXVars = xVars;
            window.multipleRegressionYVar = yVar;
        }

        function predictMultipleRegression() {
            const xVars = window.multipleRegressionXVars;
            const coeffs = window.multipleRegressionCoeffs;
            const yVar = window.multipleRegressionYVar;

            if (!xVars || !coeffs) {
                alert('請先執行多元迴歸分析');
                return;
            }

            // 讀取輸入值
            const inputValues = [1]; // 截距項
            let hasError = false;
            xVars.forEach(xVar => {
                const val = parseFloat(document.getElementById(`pred_${xVar}`).value);
                if (isNaN(val)) {
                    hasError = true;
                } else {
                    inputValues.push(val);
                }
            });

            if (hasError) {
                document.getElementById('predictionResult').innerHTML = '<p class="text-red-600">請輸入所有自變數的有效數值。</p>';
                return;
            }

            // 計算預測值
            const prediction = inputValues.reduce((sum, val, i) => sum + val * coeffs[i], 0);

            const resultDiv = document.getElementById('predictionResult');
            resultDiv.innerHTML = `
                <div class="p-4 bg-white border border-purple-200 rounded-lg shadow-sm">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-gray-600 text-sm">根據輸入的自變數</p>
                            <p class="text-lg font-bold text-gray-800 mt-1">預測 ${yVar}</p>
                        </div>
                        <div class="text-2xl font-bold text-purple-600">
                            ${prediction.toFixed(4)}
                        </div>
                    </div>
                </div>
            `;
            resultDiv.classList.remove('hidden');
        }

        // --- PCA (Principal Component Analysis) ---
        function runPCA() {
            const selectEl = document.getElementById('pcaVariables');
            const resultsDiv = document.getElementById('pcaResults');
            resultsDiv.innerHTML = '';

            const selectedVars = Array.from(selectEl.selectedOptions).map(opt => opt.value);

            if (selectedVars.length < 2) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇至少2個變數。</p>';
                return;
            }

            // 準備數據
            const data = jsonData.filter(row =>
                selectedVars.every(v => typeof row[v] === 'number')
            ).map(row => selectedVars.map(v => row[v]));

            if (data.length < selectedVars.length + 1) {
                resultsDiv.innerHTML = '<p class="text-red-600">數據不足，需要至少 ' + (selectedVars.length + 1) + ' 筆完整數據。</p>';
                return;
            }

            const n = data.length;
            const p = selectedVars.length;
            const standardize = document.getElementById('pcaStandardize').checked;

            // 計算相關矩陣或共變異數矩陣
            let corrMatrix;
            if (standardize) {
                corrMatrix = correlationMatrix(data);
            } else {
                // 共變異數矩陣
                const means = [];
                for (let j = 0; j < p; j++) {
                    means[j] = ss.mean(data.map(row => row[j]));
                }

                corrMatrix = [];
                for (let i = 0; i < p; i++) {
                    corrMatrix[i] = [];
                    for (let j = 0; j < p; j++) {
                        let sum = 0;
                        for (let k = 0; k < n; k++) {
                            sum += (data[k][i] - means[i]) * (data[k][j] - means[j]);
                        }
                        corrMatrix[i][j] = sum / (n - 1);
                    }
                }
            }

            // 特徵值分解
            const eigen = eigenDecomposition(corrMatrix);

            // 排序（降序）
            const indices = eigen.eigenvalues.map((val, idx) => idx)
                .sort((a, b) => eigen.eigenvalues[b] - eigen.eigenvalues[a]);

            const sortedEigenvalues = indices.map(i => eigen.eigenvalues[i]);
            const sortedEigenvectors = indices.map(i => eigen.eigenvectors[i]);

            // 決定主成分數量
            const numComponentsInput = document.getElementById('pcaNumComponents').value;
            let numComponents = numComponentsInput ? parseInt(numComponentsInput) : 0;

            if (numComponents === 0) {
                // Kaiser 準則：特徵值 > 1
                numComponents = sortedEigenvalues.filter(v => v > 1).length;
                if (numComponents === 0) numComponents = 1;
            }

            numComponents = Math.min(numComponents, p);

            // 計算解釋變異比例
            const totalVariance = sortedEigenvalues.reduce((sum, v) => sum + v, 0);
            const explainedVariance = sortedEigenvalues.slice(0, numComponents)
                .map(v => (v / totalVariance) * 100);
            const cumulativeVariance = [];
            let cumSum = 0;
            for (let i = 0; i < numComponents; i++) {
                cumSum += explainedVariance[i];
                cumulativeVariance.push(cumSum);
            }

            // 載荷矩陣
            const loadings = [];
            for (let i = 0; i < p; i++) {
                loadings[i] = [];
                for (let j = 0; j < numComponents; j++) {
                    loadings[i][j] = sortedEigenvectors[j][i] * Math.sqrt(sortedEigenvalues[j]);
                }
            }

            // 輸出結果
            let html = '<h3 class="text-lg font-semibold mb-2">📊 主成分分析結果</h3>';

            // 摘要
            html += '<div class="bg-indigo-50 p-4 rounded mb-4"><h4 class="font-semibold mb-2">分析摘要</h4><ul class="text-sm space-y-1"><li>變數數量：' + p + '</li><li>樣本數：' + n + '</li><li>提取主成分數：' + numComponents + '</li><li>累積解釋變異：<strong>' + cumulativeVariance[numComponents - 1].toFixed(2) + '%</strong></li></ul></div>';

            // 特徵值表
            html += '<h4 class="text-md font-semibold mb-2">主成分特徵值與解釋變異:</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">主成分</th><th class="px-4 py-2 border">特徵值</th><th class="px-4 py-2 border">解釋變異 %</th><th class="px-4 py-2 border">累積 %</th></tr></thead><tbody>';
            for (let i = 0; i < numComponents; i++) {
                html += '<tr><td class="px-4 py-2 border font-medium">PC' + (i + 1) + '</td><td class="px-4 py-2 border">' + sortedEigenvalues[i].toFixed(3) + '</td><td class="px-4 py-2 border">' + explainedVariance[i].toFixed(2) + '%</td><td class="px-4 py-2 border font-semibold">' + cumulativeVariance[i].toFixed(2) + '%</td></tr>';
            }
            html += '</tbody></table></div>';

            // 載荷矩陣
            html += '<h4 class="text-md font-semibold mb-2">主成分載荷矩陣:</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">變數</th>';
            for (let i = 0; i < numComponents; i++) {
                html += '<th class="px-4 py-2 border">PC' + (i + 1) + '</th>';
            }
            html += '</tr></thead><tbody>';
            for (let i = 0; i < p; i++) {
                html += '<tr><td class="px-4 py-2 border font-medium">' + selectedVars[i] + '</td>';
                for (let j = 0; j < numComponents; j++) {
                    const val = loadings[i][j];
                    const color = Math.abs(val) > 0.5 ? 'font-bold text-indigo-700' : '';
                    html += '<td class="px-4 py-2 border ' + color + '">' + val.toFixed(3) + '</td>';
                }
                html += '</tr>';
            }
            html += '</tbody></table></div>';

            // 判讀說明
            html += '<div class="bg-blue-50 p-4 rounded border-l-4 border-blue-500"><h4 class="font-bold">結果判讀:</h4><ul class="text-sm mt-2 space-y-1 list-disc list-inside"><li>提取的 ' + numComponents + ' 個主成分解釋了 <strong>' + cumulativeVariance[numComponents - 1].toFixed(1) + '%</strong> 的總變異。</li><li>載荷值絕對值 > 0.5 表示該變數在該主成分上有重要貢獻。</li><li>使用主成分可減少變數數量，同時保留大部分資訊。</li></ul></div>';

            resultsDiv.innerHTML = html;

            // 磎石圖
            const screePlotDiv = document.createElement('div');
            screePlotDiv.id = 'screePlot';
            screePlotDiv.className = 'mt-6';
            resultsDiv.appendChild(screePlotDiv);

            const pcLabels = sortedEigenvalues.map((_, i) => 'PC' + (i + 1));
            const trace = {
                x: pcLabels,
                y: sortedEigenvalues,
                type: 'scatter',
                mode: 'lines+markers',
                name: '特徵值',
                line: { color: 'rgb(99, 102, 241)', width: 2 },
                marker: { size: 8, color: 'rgb(99, 102, 241)' }
            };

            const kaiser = {
                x: [pcLabels[0], pcLabels[pcLabels.length - 1]],
                y: [1, 1],
                type: 'scatter',
                mode: 'lines',
                name: 'Kaiser 準則 (λ=1)',
                line: { color: 'red', dash: 'dash' }
            };

            Plotly.newPlot('screePlot', [trace, kaiser], {
                title: '磎石圖 (Scree Plot)',
                xaxis: { title: '主成分' },
                yaxis: { title: '特徵值' },
                showlegend: true
            }, { responsive: true });
        }

        // --- Factor Analysis ---
        function runFactorAnalysis() {
            const selectEl = document.getElementById('faVariables');
            const resultsDiv = document.getElementById('faResults');
            resultsDiv.innerHTML = '';

            const selectedVars = Array.from(selectEl.selectedOptions).map(opt => opt.value);

            if (selectedVars.length < 3) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇至少3個變數。</p>';
                return;
            }

            // 準備數據
            const data = jsonData.filter(row =>
                selectedVars.every(v => typeof row[v] === 'number')
            ).map(row => selectedVars.map(v => row[v]));

            if (data.length < selectedVars.length + 1) {
                resultsDiv.innerHTML = '<p class="text-red-600">數據不足。</p>';
                return;
            }

            const n = data.length;
            const p = selectedVars.length;

            // 計算相關矩陣
            const corrMatrix = correlationMatrix(data);

            // 特徵值分解
            const eigen = eigenDecomposition(corrMatrix);

            // 排序
            const indices = eigen.eigenvalues.map((val, idx) => idx)
                .sort((a, b) => eigen.eigenvalues[b] - eigen.eigenvalues[a]);

            const sortedEigenvalues = indices.map(i => eigen.eigenvalues[i]);
            const sortedEigenvectors = indices.map(i => eigen.eigenvectors[i]);

            // 決定因子數量
            const numFactorsInput = document.getElementById('faNumFactors').value;
            let numFactors = numFactorsInput ? parseInt(numFactorsInput) : 0;

            if (numFactors === 0) {
                numFactors = sortedEigenvalues.filter(v => v > 1).length;
                if (numFactors === 0) numFactors = 1;
            }

            numFactors = Math.min(numFactors, p - 1);

            // 初始載荷矩陣
            let loadings = [];
            for (let i = 0; i < p; i++) {
                loadings[i] = [];
                for (let j = 0; j < numFactors; j++) {
                    loadings[i][j] = sortedEigenvectors[j][i] * Math.sqrt(Math.max(0, sortedEigenvalues[j]));
                }
            }

            // Varimax 旋轉
            const doRotation = document.getElementById('faRotation').checked;
            if (doRotation && numFactors > 1) {
                loadings = varimax(loadings);
            }

            // 計算共同性
            const communalities = [];
            for (let i = 0; i < p; i++) {
                let h2 = 0;
                for (let j = 0; j < numFactors; j++) {
                    h2 += loadings[i][j] * loadings[i][j];
                }
                communalities.push(h2);
            }

            // 計算因子解釋變異
            const factorVariances = [];
            for (let j = 0; j < numFactors; j++) {
                let sum = 0;
                for (let i = 0; i < p; i++) {
                    sum += loadings[i][j] * loadings[i][j];
                }
                factorVariances.push(sum);
            }

            const totalVariance = factorVariances.reduce((a, b) => a + b, 0);
            const explainedVariance = factorVariances.map(v => (v / p) * 100);

            // 輸出結果
            let html = '<h3 class="text-lg font-semibold mb-2">📊 因素分析結果</h3>';

            // 摘要
            html += '<div class="bg-pink-50 p-4 rounded mb-4"><h4 class="font-semibold mb-2">分析摘要</h4><ul class="text-sm space-y-1"><li>變數數量：' + p + '</li><li>樣本數：' + n + '</li><li>提取因子數：' + numFactors + '</li><li>旋轉方法：' + (doRotation ? 'Varimax' : '無') + '</li><li>總解釋變異：<strong>' + explainedVariance.reduce((a, b) => a + b, 0).toFixed(2) + '%</strong></li></ul></div>';

            // 因子載荷矩陣
            html += '<h4 class="text-md font-semibold mb-2">因子載荷矩陣' + (doRotation ? ' (Varimax 旋轉後)' : '') + ':</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">變數</th>';
            for (let i = 0; i < numFactors; i++) {
                html += '<th class="px-4 py-2 border">因子' + (i + 1) + '</th>';
            }
            html += '<th class="px-4 py-2 border">共同性 h²</th></tr></thead><tbody>';
            for (let i = 0; i < p; i++) {
                html += '<tr><td class="px-4 py-2 border font-medium">' + selectedVars[i] + '</td>';
                for (let j = 0; j < numFactors; j++) {
                    const val = loadings[i][j];
                    const color = Math.abs(val) > 0.5 ? 'font-bold text-pink-700' : '';
                    html += '<td class="px-4 py-2 border ' + color + '">' + val.toFixed(3) + '</td>';
                }
                html += '<td class="px-4 py-2 border font-semibold">' + communalities[i].toFixed(3) + '</td></tr>';
            }
            html += '</tbody></table></div>';

            // 因子解釋變異
            html += '<h4 class="text-md font-semibold mb-2">因子解釋變異:</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">因子</th><th class="px-4 py-2 border">平方和載荷 (SS)</th><th class="px-4 py-2 border">解釋變異 %</th></tr></thead><tbody>';
            for (let i = 0; i < numFactors; i++) {
                html += '<tr><td class="px-4 py-2 border font-medium">因子' + (i + 1) + '</td><td class="px-4 py-2 border">' + factorVariances[i].toFixed(3) + '</td><td class="px-4 py-2 border">' + explainedVariance[i].toFixed(2) + '%</td></tr>';
            }
            html += '</tbody></table></div>';

            // 判讀說明
            html += '<div class="bg-purple-50 p-4 rounded border-l-4 border-purple-500"><h4 class="font-bold">結果判讀:</h4><ul class="text-sm mt-2 space-y-1 list-disc list-inside"><li>共同性 (h²) 表示變數被因子解釋的比例，h² > 0.5 較佳。</li><li>載荷值絕對值 > 0.5 表示該變數在該因子上有重要貢獻。</li><li>Varimax 旋轉使因子更容易解釋（每個變數傾向在單一因子上有高載荷）。</li></ul></div>';

            resultsDiv.innerHTML = html;
        }


        // ==============================================
        // 卡方檢定 (Chi-Square Test) Function
        // ==============================================
        function runChiSquareTest() {
            const var1 = document.getElementById('chiSquareVar1').value;
            const var2 = document.getElementById('chiSquareVar2').value;
            const resultsDiv = document.getElementById('chiSquareResults');

            if (!var1 || !var2) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇兩個類別變數。</p>';
                return;
            }

            if (var1 === var2) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇兩個不同的變數。</p>';
                return;
            }

            resultsDiv.innerHTML = '<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在計算卡方檢定...</p>';

            try {
                // 建立列聯表 (Contingency Table)
                const contingencyTable = {};
                const var1Values = [...new Set(jsonData.map(row => row[var1]).filter(v => v != null))];
                const var2Values = [...new Set(jsonData.map(row => row[var2]).filter(v => v != null))];

                // 初始化列聯表
                var1Values.forEach(v1 => {
                    contingencyTable[v1] = {};
                    var2Values.forEach(v2 => {
                        contingencyTable[v1][v2] = 0;
                    });
                });

                // 填充觀察值
                jsonData.forEach(row => {
                    const v1 = row[var1];
                    const v2 = row[var2];
                    if (v1 != null && v2 != null && contingencyTable[v1] && contingencyTable[v1][v2] !== undefined) {
                        contingencyTable[v1][v2]++;
                    }
                });

                // 計算卡方統計量
                const n = jsonData.length;
                const rowTotals = {};
                const colTotals = {};

                var1Values.forEach(v1 => {
                    rowTotals[v1] = var2Values.reduce((sum, v2) => sum + contingencyTable[v1][v2], 0);
                });

                var2Values.forEach(v2 => {
                    colTotals[v2] = var1Values.reduce((sum, v1) => sum + contingencyTable[v1][v2], 0);
                });

                let chiSquare = 0;
                const expectedTable = {};

                var1Values.forEach(v1 => {
                    expectedTable[v1] = {};
                    var2Values.forEach(v2 => {
                        const expected = (rowTotals[v1] * colTotals[v2]) / n;
                        expectedTable[v1][v2] = expected;
                        const observed = contingencyTable[v1][v2];
                        chiSquare += Math.pow(observed - expected, 2) / expected;
                    });
                });

                // 計算自由度
                const df = (var1Values.length - 1) * (var2Values.length - 1);

                // 計算 p-value (使用 jStat)
                const pValue = 1 - jStat.chisquare.cdf(chiSquare, df);

                // 計算 Cramér's V (效果量)
                const minDim = Math.min(var1Values.length, var2Values.length);
                const cramersV = Math.sqrt(chiSquare / (n * (minDim - 1)));

                // 顯示結果
                let html = '<div class="bg-white rounded-lg shadow-md p-6">';
                html += '<h3 class="text-xl font-bold mb-4 text-orange-700">📊 卡方檢定結果</h3>';

                // 統計摘要
                html += '<div class="bg-orange-50 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-semibold mb-2">統計量摘要</h4>';
                html += '<div class="grid md:grid-cols-2 gap-4">';
                html += `<div><span class="font-medium">卡方值 (χ²):</span> <span class="text-lg font-bold text-orange-600">${chiSquare.toFixed(4)}</span></div>`;
                html += `<div><span class="font-medium">自由度 (df):</span> ${df}</div>`;
                html += `<div><span class="font-medium">p-value:</span> <span class="text-lg font-bold ${pValue < 0.05 ? 'text-red-600' : 'text-green-600'}">${pValue.toFixed(6)}</span></div>`;
                html += `<div><span class="font-medium">Cramér's V:</span> ${cramersV.toFixed(4)}</div>`;
                html += '</div></div>';

                // 解釋
                html += '<div class="bg-blue-50 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-semibold mb-2">🎯 結果解釋</h4>';
                if (pValue < 0.05) {
                    html += `<p class="text-green-700 font-semibold">✅ 拒絕虛無假設 (p < 0.05)</p>`;
                    html += `<p class="text-gray-700 mt-2"><strong>${var1}</strong> 與 <strong>${var2}</strong> 之間<span class="text-red-600 font-semibold">存在顯著關聯</span>。</p>`;
                } else {
                    html += `<p class="text-red-700 font-semibold">❌ 無法拒絕虛無假設 (p ≥ 0.05)</p>`;
                    html += `<p class="text-gray-700 mt-2"><strong>${var1}</strong> 與 <strong>${var2}</strong> 之間<span class="text-gray-600 font-semibold">無顯著關聯</span>。</p>`;
                }

                // Cramér's V 效果量解釋
                let effectSize = '';
                if (cramersV < 0.1) effectSize = '極小';
                else if (cramersV < 0.3) effectSize = '小';
                else if (cramersV < 0.5) effectSize = '中等';
                else effectSize = '大';
                html += `<p class="text-gray-700 mt-2">效果量 (Cramér's V = ${cramersV.toFixed(3)}) 為 <strong>${effectSize}</strong>。</p>`;
                html += '</div>';

                // 列聯表 - 觀察值
                html += '<h4 class="font-semibold mt-4 mb-2">列聯表 - 觀察值 (Observed)</h4>';
                html += '<div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200 border"><thead class="bg-gray-100"><tr>';
                html += `<th class="px-4 py-2 border">${var1} \\ ${var2}</th>`;
                var2Values.forEach(v2 => html += `<th class="px-4 py-2 border">${v2}</th>`);
                html += '<th class="px-4 py-2 border bg-gray-200">總計</th></tr></thead><tbody>';

                var1Values.forEach(v1 => {
                    html += '<tr>';
                    html += `<td class="px-4 py-2 border font-medium bg-gray-50">${v1}</td>`;
                    var2Values.forEach(v2 => {
                        html += `<td class="px-4 py-2 border text-center">${contingencyTable[v1][v2]}</td>`;
                    });
                    html += `<td class="px-4 py-2 border text-center font-semibold bg-gray-100">${rowTotals[v1]}</td>`;
                    html += '</tr>';
                });

                // 總計列
                html += '<tr class="bg-gray-200"><td class="px-4 py-2 border font-semibold">總計</td>';
                var2Values.forEach(v2 => {
                    html += `<td class="px-4 py-2 border text-center font-semibold">${colTotals[v2]}</td>`;
                });
                html += `<td class="px-4 py-2 border text-center font-bold">${n}</td></tr>`;
                html += '</tbody></table></div>';

                // 列聯表 - 期望值
                html += '<h4 class="font-semibold mt-6 mb-2">列聯表 - 期望值 (Expected)</h4>';
                html += '<div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200 border"><thead class="bg-gray-100"><tr>';
                html += `<th class="px-4 py-2 border">${var1} \\ ${var2}</th>`;
                var2Values.forEach(v2 => html += `<th class="px-4 py-2 border">${v2}</th>`);
                html += '</tr></thead><tbody>';

                var1Values.forEach(v1 => {
                    html += '<tr>';
                    html += `<td class="px-4 py-2 border font-medium bg-gray-50">${v1}</td>`;
                    var2Values.forEach(v2 => {
                        html += `<td class="px-4 py-2 border text-center text-gray-600">${expectedTable[v1][v2].toFixed(2)}</td>`;
                    });
                    html += '</tr>';
                });
                html += '</tbody></table></div>';

                // 視覺化 - 堆疊長條圖
                html += '<div id="chiSquarePlot" class="mt-6"></div>';
                html += '</div>';

                resultsDiv.innerHTML = html;

                // 繪製圖表
                setTimeout(() => {
                    const traces = var2Values.map(v2 => ({
                        x: var1Values,
                        y: var1Values.map(v1 => contingencyTable[v1][v2]),
                        name: v2,
                        type: 'bar'
                    }));

                    Plotly.newPlot('chiSquarePlot', traces, {
                        title: `${var1} vs ${var2} 分布圖`,
                        barmode: 'group',
                        xaxis: { title: var1 },
                        yaxis: { title: '計數' },
                        margin: { t: 40, b: 60, l: 60, r: 40 }
                    }, { responsive: true });
                }, 100);

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">計算錯誤: ${error.message}</p>`;
                console.error(error);
            }
        }

        // ==============================================
        // K-Means 集群分析 Functions
        // ==============================================

        // Elbow Method - 找最佳K值
        function runKmeansElbow() {
            const selectedVars = Array.from(document.getElementById('kmeansVariables').selectedOptions).map(opt => opt.value);
            const resultsDiv = document.getElementById('kmeansResults');

            if (selectedVars.length < 2) {
                resultsDiv.innerHTML = '<p class="text-red-600">請至少選擇2個數值變數。</p>';
                return;
            }

            resultsDiv.innerHTML = '<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在執行 Elbow 分析...</p>';

            try {
                // 準備數據
                const data = jsonData.map(row => selectedVars.map(v => row[v])).filter(row => row.every(val => typeof val === 'number' && !isNaN(val)));

                if (data.length < 10) {
                    resultsDiv.innerHTML = '<p class="text-red-600">數據量不足（至少需要10筆完整資料）。</p>';
                    return;
                }

                // 標準化數據
                const standardize = document.getElementById('kmeansStandardize').checked;
                let processedData = data;
                if (standardize) {
                    processedData = standardizeData(data);
                }

                // 計算不同K值的WCSS (Within-Cluster Sum of Squares)
                const maxK = Math.min(10, Math.floor(data.length / 2));
                const wcssValues = [];

                for (let k = 1; k <= maxK; k++) {
                    const result = performKmeans(processedData, k, 100);
                    wcssValues.push({ k: k, wcss: result.wcss });
                }

                // 顯示結果
                let html = '<div class="bg-white rounded-lg shadow-md p-6">';
                html += '<h3 class="text-xl font-bold mb-4 text-blue-700">🔍 Elbow Method - 最佳 K 值分析</h3>';
                html += '<p class="text-gray-600 mb-4">Elbow 法透過觀察 WCSS (Within-Cluster Sum of Squares) 的變化趨勢，找出「手肘點」作為最佳集群數。</p>';
                html += '<div id="elbowPlot"></div>';
                html += '<div class="bg-blue-50 p-4 rounded-lg mt-4">';
                html += '<h4 class="font-semibold mb-2">💡 如何判讀</h4>';
                html += '<ul class="text-sm text-gray-700 space-y-1">';
                html += '<li>• 找出曲線「彎曲」最明顯的點（手肘點）</li>';
                html += '<li>• 該點對應的 K 值通常是最佳集群數</li>';
                html += '<li>• WCSS 下降趨緩後，增加 K 值效益不大</li>';
                html += '</ul></div></div>';

                resultsDiv.innerHTML = html;

                // 繪製 Elbow 圖
                setTimeout(() => {
                    const trace = {
                        x: wcssValues.map(v => v.k),
                        y: wcssValues.map(v => v.wcss),
                        mode: 'lines+markers',
                        marker: { color: '#3b82f6', size: 10 },
                        line: { color: '#3b82f6', width: 3 }
                    };

                    Plotly.newPlot('elbowPlot', [trace], {
                        title: 'Elbow Method - WCSS vs K',
                        xaxis: { title: '集群數 K', dtick: 1 },
                        yaxis: { title: 'WCSS (Within-Cluster Sum of Squares)' },
                        margin: { t: 60, b: 60, l: 80, r: 40 }
                    }, { responsive: true });
                }, 100);

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">計算錯誤: ${error.message}</p>`;
                console.error(error);
            }
        }

        // K-Means 集群分析主函數
        function runKmeansClustering() {
            const selectedVars = Array.from(document.getElementById('kmeansVariables').selectedOptions).map(opt => opt.value);
            const k = parseInt(document.getElementById('kmeansK').value);
            const maxIter = parseInt(document.getElementById('kmeansMaxIter').value);
            const resultsDiv = document.getElementById('kmeansResults');

            if (selectedVars.length < 2) {
                resultsDiv.innerHTML = '<p class="text-red-600">請至少選擇2個數值變數。</p>';
                return;
            }

            if (k < 2 || k > 10) {
                resultsDiv.innerHTML = '<p class="text-red-600">K 值需介於 2 到 10 之間。</p>';
                return;
            }

            resultsDiv.innerHTML = '<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在執行 K-Means 集群分析...</p>';

            try {
                // 準備數據（保留原始數據索引）
                const dataWithIndex = jsonData.map((row, idx) => ({
                    index: idx,
                    values: selectedVars.map(v => row[v])
                })).filter(item => item.values.every(val => typeof val === 'number' && !isNaN(val)));

                if (dataWithIndex.length < k) {
                    resultsDiv.innerHTML = '<p class="text-red-600">有效數據量不足（需大於 K 值）。</p>';
                    return;
                }

                const data = dataWithIndex.map(item => item.values);

                // 標準化數據
                const standardize = document.getElementById('kmeansStandardize').checked;
                let processedData = data;
                let means = null, stds = null;

                if (standardize) {
                    const result = standardizeDataWithStats(data);
                    processedData = result.data;
                    means = result.means;
                    stds = result.stds;
                }

                // 執行 K-Means
                const result = performKmeans(processedData, k, maxIter);

                // 計算集群統計
                const clusterStats = calculateClusterStats(data, result.labels, selectedVars, k);

                // 顯示結果
                let html = '<div class="bg-white rounded-lg shadow-md p-6">';
                html += '<h3 class="text-xl font-bold mb-4 text-green-700">🎯 K-Means 集群分析結果</h3>';

                // 摘要統計
                html += '<div class="bg-green-50 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-semibold mb-2">集群摘要</h4>';
                html += '<div class="grid md:grid-cols-4 gap-4">';
                html += `<div><span class="font-medium">集群數 (K):</span> <span class="text-lg font-bold">${k}</span></div>`;
                html += `<div><span class="font-medium">總數據點:</span> ${data.length}</div>`;
                html += `<div><span class="font-medium">迭代次數:</span> ${result.iterations}</div>`;
                html += `<div><span class="font-medium">WCSS:</span> ${result.wcss.toFixed(2)}</div>`;
                html += '</div></div>';

                // 各集群大小
                html += '<h4 class="font-semibold mt-4 mb-2">各集群大小</h4>';
                html += '<div class="grid md:grid-cols-5 gap-2 mb-4">';
                for (let i = 0; i < k; i++) {
                    const count = result.labels.filter(l => l === i).length;
                    const percentage = ((count / data.length) * 100).toFixed(1);
                    html += `<div class="bg-gray-100 p-3 rounded text-center">`;
                    html += `<div class="font-semibold text-gray-700">集群 ${i + 1}</div>`;
                    html += `<div class="text-2xl font-bold text-green-600">${count}</div>`;
                    html += `<div class="text-xs text-gray-500">${percentage}%</div>`;
                    html += `</div>`;
                }
                html += '</div>';

                // 集群中心點
                html += '<h4 class="font-semibold mt-4 mb-2">集群中心點 (Centroids)</h4>';
                html += '<div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200 border"><thead class="bg-gray-100"><tr>';
                html += '<th class="px-4 py-2 border">集群</th>';
                selectedVars.forEach(v => html += `<th class="px-4 py-2 border">${v}</th>`);
                html += '</tr></thead><tbody>';

                result.centroids.forEach((centroid, idx) => {
                    html += '<tr>';
                    html += `<td class="px-4 py-2 border font-semibold bg-gray-50">集群 ${idx + 1}</td>`;
                    centroid.forEach((val, vIdx) => {
                        // 如果有標準化,反標準化顯示原始尺度
                        let displayVal = val;
                        if (standardize && means && stds) {
                            displayVal = val * stds[vIdx] + means[vIdx];
                        }
                        html += `<td class="px-4 py-2 border text-center">${displayVal.toFixed(3)}</td>`;
                    });
                    html += '</tr>';
                });
                html += '</tbody></table></div>';

                // 集群特徵分析
                html += '<h4 class="font-semibold mt-6 mb-2">集群特徵分析</h4>';
                html += '<div class="space-y-3">';
                for (let i = 0; i < k; i++) {
                    html += `<div class="bg-gray-50 p-4 rounded-lg">`;
                    html += `<h5 class="font-semibold text-lg mb-2">集群 ${i + 1} 特徵</h5>`;
                    html += '<div class="grid md:grid-cols-3 gap-2 text-sm">';
                    selectedVars.forEach((v, vIdx) => {
                        html += `<div><span class="text-gray-600">${v}:</span> <span class="font-semibold">${clusterStats[i][vIdx].mean.toFixed(3)}</span> ± ${clusterStats[i][vIdx].std.toFixed(3)}</div>`;
                    });
                    html += '</div></div>';
                }
                html += '</div>';

                // 視覺化（如果變數>=2，顯示散點圖）
                if (selectedVars.length >= 2) {
                    html += '<div id="kmeansScatterPlot" class="mt-6"></div>';
                }

                // 輪廓係數（Silhouette Score）
                const silhouetteScore = calculateSilhouetteScore(processedData, result.labels, k);
                html += '<div class="bg-yellow-50 p-4 rounded-lg mt-4">';
                html += '<h4 class="font-semibold mb-2">📏 集群品質指標</h4>';
                html += `<div><span class="font-medium">Silhouette Score:</span> <span class="text-lg font-bold text-yellow-700">${silhouetteScore.toFixed(4)}</span></div>`;
                html += '<p class="text-sm text-gray-600 mt-2">範圍 [-1, 1]，越接近 1 表示集群品質越好。</p>';
                let quality = '';
                if (silhouetteScore > 0.7) quality = '優秀';
                else if (silhouetteScore > 0.5) quality = '良好';
                else if (silhouetteScore > 0.3) quality = '尚可';
                else quality = '不佳';
                html += `<p class="text-sm font-semibold text-gray-700">集群品質: <span class="${silhouetteScore > 0.5 ? 'text-green-600' : 'text-orange-600'}">${quality}</span></p>`;
                html += '</div>';

                html += '</div>';

                resultsDiv.innerHTML = html;

                // 繪製散點圖（使用前兩個變數）
                if (selectedVars.length >= 2) {
                    setTimeout(() => {
                        const traces = [];
                        const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316'];

                        for (let i = 0; i < k; i++) {
                            const clusterData = data.filter((_, idx) => result.labels[idx] === i);
                            traces.push({
                                x: clusterData.map(d => d[0]),
                                y: clusterData.map(d => d[1]),
                                mode: 'markers',
                                type: 'scatter',
                                name: `集群 ${i + 1}`,
                                marker: { color: colors[i % colors.length], size: 8, opacity: 0.7 }
                            });
                        }

                        // 加入中心點
                        let centroids = result.centroids;
                        if (standardize && means && stds) {
                            centroids = result.centroids.map(c => c.map((val, idx) => val * stds[idx] + means[idx]));
                        }

                        traces.push({
                            x: centroids.map(c => c[0]),
                            y: centroids.map(c => c[1]),
                            mode: 'markers',
                            type: 'scatter',
                            name: '中心點',
                            marker: { color: 'black', size: 15, symbol: 'x' }
                        });

                        Plotly.newPlot('kmeansScatterPlot', traces, {
                            title: `K-Means 集群視覺化 (前兩個變數)`,
                            xaxis: { title: selectedVars[0] },
                            yaxis: { title: selectedVars[1] },
                            margin: { t: 60, b: 60, l: 80, r: 40 }
                        }, { responsive: true });
                    }, 100);
                }

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">計算錯誤: ${error.message}</p>`;
                console.error(error);
            }
        }

        // ===== K-Means 輔助函數 =====

        function standardizeData(data) {
            const n = data.length;
            const m = data[0].length;
            const means = [];
            const stds = [];

            // 計算每個變數的平均值和標準差
            for (let j = 0; j < m; j++) {
                const values = data.map(row => row[j]);
                const mean = ss.mean(values);
                const std = ss.standardDeviation(values);
                means.push(mean);
                stds.push(std);
            }

            // 標準化
            return data.map(row => row.map((val, j) => (val - means[j]) / (stds[j] === 0 ? 1 : stds[j])));
        }

        function standardizeDataWithStats(data) {
            const n = data.length;
            const m = data[0].length;
            const means = [];
            const stds = [];

            for (let j = 0; j < m; j++) {
                const values = data.map(row => row[j]);
                const mean = ss.mean(values);
                const std = ss.standardDeviation(values);
                means.push(mean);
                stds.push(std);
            }

            const standardizedData = data.map(row => row.map((val, j) => (val - means[j]) / (stds[j] === 0 ? 1 : stds[j])));

            return { data: standardizedData, means, stds };
        }

        function performKmeans(data, k, maxIter) {
            const n = data.length;
            const m = data[0].length;

            // 隨機初始化中心點（K-Means++）
            let centroids = initializeCentroidsKMeansPlusPlus(data, k);
            let labels = new Array(n).fill(0);
            let prevLabels = new Array(n).fill(-1);
            let iterations = 0;

            while (iterations < maxIter && !arraysEqual(labels, prevLabels)) {
                prevLabels = [...labels];

                // 分配每個點到最近的中心
                for (let i = 0; i < n; i++) {
                    let minDist = Infinity;
                    let closestCentroid = 0;

                    for (let j = 0; j < k; j++) {
                        const dist = euclideanDistance(data[i], centroids[j]);
                        if (dist < minDist) {
                            minDist = dist;
                            closestCentroid = j;
                        }
                    }

                    labels[i] = closestCentroid;
                }

                // 更新中心點
                for (let j = 0; j < k; j++) {
                    const clusterPoints = data.filter((_, idx) => labels[idx] === j);
                    if (clusterPoints.length > 0) {
                        centroids[j] = clusterPoints[0].map((_, dim) =>
                            ss.mean(clusterPoints.map(p => p[dim]))
                        );
                    }
                }

                iterations++;
            }

            // 計算 WCSS
            let wcss = 0;
            for (let i = 0; i < n; i++) {
                wcss += Math.pow(euclideanDistance(data[i], centroids[labels[i]]), 2);
            }

            return { centroids, labels, iterations, wcss };
        }

        function initializeCentroidsKMeansPlusPlus(data, k) {
            const centroids = [];
            const n = data.length;

            // 隨機選擇第一個中心點
            centroids.push(data[Math.floor(Math.random() * n)]);

            // 選擇剩餘的中心點
            for (let i = 1; i < k; i++) {
                const distances = data.map(point => {
                    const minDist = Math.min(...centroids.map(c => euclideanDistance(point, c)));
                    return minDist * minDist;
                });

                const totalDist = distances.reduce((a, b) => a + b, 0);
                const probs = distances.map(d => d / totalDist);

                // 按概率選擇下一個中心點
                const r = Math.random();
                let cumProb = 0;
                for (let j = 0; j < n; j++) {
                    cumProb += probs[j];
                    if (r < cumProb) {
                        centroids.push(data[j]);
                        break;
                    }
                }
            }

            return centroids;
        }

        function euclideanDistance(p1, p2) {
            return Math.sqrt(p1.reduce((sum, val, idx) => sum + Math.pow(val - p2[idx], 2), 0));
        }

        function arraysEqual(a, b) {
            return a.length === b.length && a.every((val, idx) => val === b[idx]);
        }

        function calculateClusterStats(data, labels, varNames, k) {
            const stats = [];

            for (let i = 0; i < k; i++) {
                const clusterData = data.filter((_, idx) => labels[idx] === i);
                const clusterStats = varNames.map((_, vIdx) => {
                    const values = clusterData.map(row => row[vIdx]);
                    return {
                        mean: ss.mean(values),
                        std: ss.standardDeviation(values),
                        min: ss.min(values),
                        max: ss.max(values)
                    };
                });
                stats.push(clusterStats);
            }

            return stats;
        }

        function calculateSilhouetteScore(data, labels, k) {
            const n = data.length;
            let totalScore = 0;

            for (let i = 0; i < n; i++) {
                const label = labels[i];

                // a(i): 平均群內距離
                const inCluster = data.filter((_, idx) => labels[idx] === label);
                const a = inCluster.length > 1 ?
                    ss.mean(inCluster.map(p => euclideanDistance(data[i], p))) : 0;

                // b(i): 最小平均群間距離
                let b = Infinity;
                for (let j = 0; j < k; j++) {
                    if (j !== label) {
                        const otherCluster = data.filter((_, idx) => labels[idx] === j);
                        if (otherCluster.length > 0) {
                            const avgDist = ss.mean(otherCluster.map(p => euclideanDistance(data[i], p)));
                            b = Math.min(b, avgDist);
                        }
                    }
                }

                // s(i) = (b - a) / max(a, b)
                const s = (b - a) / Math.max(a, b);
                totalScore += s;
            }

            return totalScore / n;
        }


        // ==============================================
        // 關聯規則挖掘 (Apriori Algorithm)
        // ==============================================

        function runAprioriAnalysis() {
            const transactionIdField = document.getElementById('aprioriTransactionId').value;
            const itemNameField = document.getElementById('aprioriItemName').value;
            const minSupport = parseFloat(document.getElementById('aprioriMinSupport').value);
            const minConfidence = parseFloat(document.getElementById('aprioriMinConfidence').value);
            const minLift = parseFloat(document.getElementById('aprioriMinLift').value);
            const resultsDiv = document.getElementById('aprioriResults');

            if (!transactionIdField || !itemNameField) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇交易ID和商品名稱欄位。</p>';
                return;
            }

            if (transactionIdField === itemNameField) {
                resultsDiv.innerHTML = '<p class="text-red-600">交易ID和商品名稱不能是同一個欄位。</p>';
                return;
            }

            resultsDiv.innerHTML = '<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在執行 Apriori 演算法...</p>';

            try {
                // 1. 轉換數據為交易格式
                const transactions = {};
                jsonData.forEach(row => {
                    const tid = row[transactionIdField];
                    const item = row[itemNameField];
                    if (tid != null && item != null) {
                        if (!transactions[tid]) {
                            transactions[tid] = [];
                        }
                        if (!transactions[tid].includes(item)) {
                            transactions[tid].push(item);
                        }
                    }
                });

                const transactionList = Object.values(transactions);
                const numTransactions = transactionList.length;

                if (numTransactions < 10) {
                    resultsDiv.innerHTML = '<p class="text-red-600">交易數量不足（至少需要10筆交易）。</p>';
                    return;
                }

                // 2. 找出所有頻繁項目集 (Frequent Itemsets)
                const frequentItemsets = findFrequentItemsets(transactionList, minSupport);

                if (frequentItemsets.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-orange-600">沒有找到符合條件的頻繁項目集，請降低最小支持度。</p>';
                    return;
                }

                // 3. 生成關聯規則
                const rules = generateAssociationRules(frequentItemsets, transactionList, minConfidence, minLift);

                if (rules.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-orange-600">沒有找到符合條件的關聯規則，請降低最小信賴度或提升度。</p>';
                    return;
                }

                // 4. 按Lift排序
                rules.sort((a, b) => b.lift - a.lift);

                // 5. 顯示結果
                let html = '<div class="bg-white rounded-lg shadow-md p-6">';
                html += '<h3 class="text-xl font-bold mb-4 text-purple-700">🛒 關聯規則挖掘結果</h3>';

                // 基本統計
                html += '<div class="bg-purple-50 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-semibold mb-2">基本統計</h4>';
                html += '<div class="grid md:grid-cols-4 gap-4 text-sm">';
                html += `<div><span class="text-gray-600">交易總數:</span> <span class="font-bold">${numTransactions}</span></div>`;
                html += `<div><span class="text-gray-600">頻繁項目集:</span> <span class="font-bold">${frequentItemsets.length}</span></div>`;
                html += `<div><span class="text-gray-600">關聯規則:</span> <span class="font-bold">${rules.length}</span></div>`;

                // 計算所有商品
                const allItems = new Set();
                transactionList.forEach(t => t.forEach(item => allItems.add(item)));
                html += `<div><span class="text-gray-600">商品種類:</span> <span class="font-bold">${allItems.size}</span></div>`;
                html += '</div></div>';

                // Top 關聯規則表格
                html += '<h4 class="font-semibold mt-6 mb-3">🏆 關聯規則排行 (依提升度排序)</h4>';
                html += '<div class="overflow-x-auto">';
                html += '<table class="min-w-full divide-y divide-gray-200 border text-sm">';
                html += '<thead class="bg-gray-100">';
                html += '<tr>';
                html += '<th class="px-3 py-2 border text-left">#</th>';
                html += '<th class="px-3 py-2 border text-left">前項 (Antecedent)</th>';
                html += '<th class="px-3 py-2 border text-center">→</th>';
                html += '<th class="px-3 py-2 border text-left">後項 (Consequent)</th>';
                html += '<th class="px-3 py-2 border text-center">支持度<br>Support</th>';
                html += '<th class="px-3 py-2 border text-center">信賴度<br>Confidence</th>';
                html += '<th class="px-3 py-2 border text-center">提升度<br>Lift</th>';
                html += '<th class="px-3 py-2 border text-left">解釋</th>';
                html += '</tr></thead><tbody class="bg-white">';

                // 只顯示前20條規則
                rules.slice(0, 20).forEach((rule, idx) => {
                    const liftColor = rule.lift > 2 ? 'text-red-600 font-bold' :
                        rule.lift > 1.5 ? 'text-orange-600 font-semibold' :
                            'text-green-600';

                    html += '<tr class="hover:bg-gray-50">';
                    html += `<td class="px-3 py-2 border text-center font-semibold">${idx + 1}</td>`;
                    html += `<td class="px-3 py-2 border"><span class="bg-blue-100 px-2 py-1 rounded text-xs">${rule.antecedent.join(' + ')}</span></td>`;
                    html += `<td class="px-3 py-2 border text-center text-xl">→</td>`;
                    html += `<td class="px-3 py-2 border"><span class="bg-green-100 px-2 py-1 rounded text-xs">${rule.consequent.join(' + ')}</span></td>`;
                    html += `<td class="px-3 py-2 border text-center">${(rule.support * 100).toFixed(2)}%</td>`;
                    html += `<td class="px-3 py-2 border text-center font-semibold">${(rule.confidence * 100).toFixed(1)}%</td>`;
                    html += `<td class="px-3 py-2 border text-center ${liftColor}">${rule.lift.toFixed(2)}×</td>`;
                    html += `<td class="px-3 py-2 border text-xs text-gray-600">${interpretRule(rule)}</td>`;
                    html += '</tr>';
                });

                html += '</tbody></table></div>';

                if (rules.length > 20) {
                    html += `<p class="text-xs text-gray-500 mt-2">顯示前20條規則 (共${rules.length}條)</p>`;
                }

                // 指標說明
                html += '<div class="bg-blue-50 p-4 rounded-lg mt-6">';
                html += '<h4 class="font-semibold mb-2">📊 指標說明</h4>';
                html += '<div class="text-sm text-gray-700 space-y-2">';
                html += '<p><strong>Support (支持度)</strong>: {A, B} 在所有交易中出現的比例</p>';
                html += '<p><strong>Confidence (信賴度)</strong>: 買了 A 之後買 B 的條件機率 = P(B|A)</p>';
                html += '<p><strong>Lift (提升度)</strong>: 關聯強度指標 = Confidence / P(B)</p>';
                html += '<ul class="list-disc ml-6 mt-2">';
                html += '<li>Lift > 1: 正相關 (買A增加買B的機率)</li>';
                html += '<li>Lift = 1: 獨立 (無關聯)</li>';
                html += '<li>Lift < 1: 負相關 (買A降低買B的機率)</li>';
                html += '</ul></div></div>';

                // 商業應用建議
                html += '<div class="bg-green-50 p-4 rounded-lg mt-4">';
                html += '<h4 class="font-semibold mb-2">💡 商業應用建議</h4>';
                html += '<div class="text-sm text-gray-700 space-y-2">';

                if (rules.length > 0) {
                    const topRule = rules[0];
                    html += `<p><strong>最強關聯規則:</strong></p>`;
                    html += `<p class="ml-4">購買 <span class="font-semibold text-blue-600">${topRule.antecedent.join(', ')}</span> 的客戶，有 <span class="font-bold text-red-600">${(topRule.confidence * 100).toFixed(1)}%</span> 機率也會購買 <span class="font-semibold text-green-600">${topRule.consequent.join(', ')}</span></p>`;
                    html += '<p class="mt-3"><strong>建議策略:</strong></p>';
                    html += '<ul class="list-disc ml-8">';
                    html += `<li>商品組合促銷: 購買 ${topRule.antecedent.join('+')} 加購 ${topRule.consequent.join('+')} 享優惠</li>`;
                    html += `<li>貨架擺放: 將 ${topRule.antecedent.join(', ')} 和 ${topRule.consequent.join(', ')} 擺放在鄰近位置</li>`;
                    html += `<li>交叉銷售: 推薦系統「買了這個的人也買了...」</li>`;
                    html += '</ul>';
                }

                html += '</div></div>';

                // 視覺化提示
                html += '<div class="mt-4 p-3 bg-yellow-50 rounded border border-yellow-200">';
                html += '<p class="text-sm text-yellow-800">💡 <strong>提示:</strong> 關聯規則網絡圖需要額外的視覺化函式庫(如D3.js)，目前版本以表格呈現。</p>';
                html += '</div>';

                html += '</div>';

                resultsDiv.innerHTML = html;

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">計算錯誤: ${error.message}</p>`;
                console.error(error);
            }
        }

        // Apriori 輔助函數
        function findFrequentItemsets(transactions, minSupport) {
            const numTransactions = transactions.length;
            const minSupportCount = Math.ceil(minSupport * numTransactions);

            // 1. 找出所有單一項目的支持度
            const itemCounts = {};
            transactions.forEach(transaction => {
                transaction.forEach(item => {
                    itemCounts[item] = (itemCounts[item] || 0) + 1;
                });
            });

            // 2. 過濾出頻繁單項
            let frequentItemsets = [];
            Object.keys(itemCounts).forEach(item => {
                if (itemCounts[item] >= minSupportCount) {
                    frequentItemsets.push({
                        items: [item],
                        support: itemCounts[item] / numTransactions
                    });
                }
            });

            // 3. 生成更大的項目集 (2-itemsets, 3-itemsets, ...)
            let k = 2;
            let currentItemsets = frequentItemsets.map(f => f.items);

            while (currentItemsets.length > 0 && k <= 3) { // 限制最大為3-itemsets
                const candidates = generateCandidates(currentItemsets, k);
                const candidateCounts = {};

                // 計算候選項目集的支持度
                transactions.forEach(transaction => {
                    candidates.forEach(candidate => {
                        const candidateKey = candidate.join(',');
                        if (candidate.every(item => transaction.includes(item))) {
                            candidateCounts[candidateKey] = (candidateCounts[candidateKey] || 0) + 1;
                        }
                    });
                });

                // 過濾頻繁項目集
                currentItemsets = [];
                Object.keys(candidateCounts).forEach(key => {
                    if (candidateCounts[key] >= minSupportCount) {
                        const items = key.split(',');
                        frequentItemsets.push({
                            items: items,
                            support: candidateCounts[key] / numTransactions
                        });
                        currentItemsets.push(items);
                    }
                });

                k++;
            }

            return frequentItemsets;
        }

        function generateCandidates(frequentItemsets, k) {
            const candidates = [];

            for (let i = 0; i < frequentItemsets.length; i++) {
                for (let j = i + 1; j < frequentItemsets.length; j++) {
                    const set1 = frequentItemsets[i];
                    const set2 = frequentItemsets[j];

                    // 合併兩個k-1項目集
                    const union = [...new Set([...set1, ...set2])];

                    if (union.length === k) {
                        const sortedUnion = union.sort();
                        const candidateKey = sortedUnion.join(',');

                        // 避免重複
                        if (!candidates.some(c => c.join(',') === candidateKey)) {
                            candidates.push(sortedUnion);
                        }
                    }
                }
            }

            return candidates;
        }

        function generateAssociationRules(frequentItemsets, transactions, minConfidence, minLift) {
            const rules = [];
            const numTransactions = transactions.length;

            // 計算每個項目的支持度 (用於計算Lift)
            const itemSupport = {};
            frequentItemsets.forEach(itemset => {
                if (itemset.items.length === 1) {
                    itemSupport[itemset.items[0]] = itemset.support;
                }
            });

            // 從2-itemsets及以上生成規則
            frequentItemsets.filter(itemset => itemset.items.length >= 2).forEach(itemset => {
                const items = itemset.items;
                const itemsetSupport = itemset.support;

                // 生成所有可能的前項/後項組合
                for (let i = 1; i < Math.pow(2, items.length) - 1; i++) {
                    const antecedent = [];
                    const consequent = [];

                    for (let j = 0; j < items.length; j++) {
                        if (i & (1 << j)) {
                            antecedent.push(items[j]);
                        } else {
                            consequent.push(items[j]);
                        }
                    }

                    if (antecedent.length > 0 && consequent.length > 0) {
                        // 計算前項的支持度
                        const antecedentSupport = calculateSupport(antecedent, transactions) / numTransactions;

                        if (antecedentSupport > 0) {
                            const confidence = itemsetSupport / antecedentSupport;

                            // 計算後項的支持度
                            const consequentSupport = calculateSupport(consequent, transactions) / numTransactions;
                            const lift = consequentSupport > 0 ? confidence / consequentSupport : 0;

                            if (confidence >= minConfidence && lift >= minLift) {
                                rules.push({
                                    antecedent: antecedent,
                                    consequent: consequent,
                                    support: itemsetSupport,
                                    confidence: confidence,
                                    lift: lift
                                });
                            }
                        }
                    }
                }
            });

            return rules;
        }

        function calculateSupport(items, transactions) {
            let count = 0;
            transactions.forEach(transaction => {
                if (items.every(item => transaction.includes(item))) {
                    count++;
                }
            });
            return count;
        }

        function interpretRule(rule) {
            if (rule.lift > 3) {
                return '極強關聯';
            } else if (rule.lift > 2) {
                return '強關聯';
            } else if (rule.lift > 1.5) {
                return '中等關聯';
            } else if (rule.lift > 1) {
                return '弱關聯';
            } else {
                return '無關聯';
            }
        }

        // ==============================================
        // 異常偵測 (Outlier Detection)
        // ==============================================

        function runOutlierDetection() {
            const variable = document.getElementById('outlierVariable').value;
            const useIQR = document.getElementById('outlierIQR').checked;
            const useZScore = document.getElementById('outlierZScore').checked;
            const useModifiedZ = document.getElementById('outlierModifiedZ').checked;
            const zThreshold = parseFloat(document.getElementById('outlierZThreshold').value);
            const iqrMultiplier = parseFloat(document.getElementById('outlierIQRMultiplier').value);
            const resultsDiv = document.getElementById('outlierResults');

            if (!variable) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇要檢測的數值變數。</p>';
                return;
            }

            if (!useIQR && !useZScore && !useModifiedZ) {
                resultsDiv.innerHTML = '<p class="text-red-600">請至少選擇一種偵測方法。</p>';
                return;
            }

            resultsDiv.innerHTML = '<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在執行異常偵測...</p>';

            try {
                // 提取數值資料
                const values = jsonData.map((row, idx) => ({
                    index: idx,
                    value: row[variable]
                })).filter(item => typeof item.value === 'number' && !isNaN(item.value));

                if (values.length < 10) {
                    resultsDiv.innerHTML = '<p class="text-red-600">有效數據量不足（至少需要10筆）。</p>';
                    return;
                }

                const data = values.map(v => v.value);

                // 基本統計量
                const mean = ss.mean(data);
                const median = ss.median(data);
                const std = ss.standardDeviation(data);
                const q1 = ss.quantile(data, 0.25);
                const q3 = ss.quantile(data, 0.75);
                const iqr = q3 - q1;
                const min = ss.min(data);
                const max = ss.max(data);

                // 執行各種偵測方法
                const results = {
                    iqr: { outliers: [], method: 'IQR' },
                    zscore: { outliers: [], method: 'Z-Score' },
                    modifiedZ: { outliers: [], method: 'Modified Z-Score' }
                };

                // IQR 法
                if (useIQR) {
                    const lowerBound = q1 - iqrMultiplier * iqr;
                    const upperBound = q3 + iqrMultiplier * iqr;

                    values.forEach(item => {
                        if (item.value < lowerBound || item.value > upperBound) {
                            results.iqr.outliers.push(item);
                        }
                    });

                    results.iqr.lowerBound = lowerBound;
                    results.iqr.upperBound = upperBound;
                }

                // Z-Score 法
                if (useZScore) {
                    values.forEach(item => {
                        const z = (item.value - mean) / std;
                        if (Math.abs(z) > zThreshold) {
                            results.zscore.outliers.push({ ...item, zScore: z });
                        }
                    });
                }

                // Modified Z-Score 法
                if (useModifiedZ) {
                    const mad = calculateMAD(data, median);

                    values.forEach(item => {
                        const modifiedZ = 0.6745 * (item.value - median) / mad;
                        if (Math.abs(modifiedZ) > 3.5) {
                            results.modifiedZ.outliers.push({ ...item, modifiedZ: modifiedZ });
                        }
                    });
                }

                // 合併所有異常值 (去重)
                const allOutlierIndices = new Set();
                Object.values(results).forEach(result => {
                    result.outliers.forEach(outlier => allOutlierIndices.add(outlier.index));
                });

                // 顯示結果
                let html = '<div class="bg-white rounded-lg shadow-md p-6">';
                html += '<h3 class="text-xl font-bold mb-4 text-red-700">🎯 異常偵測結果</h3>';

                // 基本統計
                html += '<div class="bg-gray-50 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-semibold mb-2">基本統計量</h4>';
                html += '<div class="grid md:grid-cols-4 gap-3 text-sm">';
                html += `<div><span class="text-gray-600">樣本數:</span> <span class="font-bold">${values.length}</span></div>`;
                html += `<div><span class="text-gray-600">平均值:</span> <span class="font-bold">${mean.toFixed(3)}</span></div>`;
                html += `<div><span class="text-gray-600">中位數:</span> <span class="font-bold">${median.toFixed(3)}</span></div>`;
                html += `<div><span class="text-gray-600">標準差:</span> <span class="font-bold">${std.toFixed(3)}</span></div>`;
                html += `<div><span class="text-gray-600">最小值:</span> <span class="font-bold">${min.toFixed(3)}</span></div>`;
                html += `<div><span class="text-gray-600">Q1:</span> <span class="font-bold">${q1.toFixed(3)}</span></div>`;
                html += `<div><span class="text-gray-600">Q3:</span> <span class="font-bold">${q3.toFixed(3)}</span></div>`;
                html += `<div><span class="text-gray-600">最大值:</span> <span class="font-bold">${max.toFixed(3)}</span></div>`;
                html += '</div></div>';

                // 異常值摘要
                html += '<div class="bg-red-50 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-semibold mb-2">異常值摘要</h4>';
                html += '<div class="grid md:grid-cols-3 gap-4">';

                if (useIQR) {
                    html += '<div class="bg-white p-3 rounded border border-red-200">';
                    html += '<div class="text-sm text-gray-600">IQR 法</div>';
                    html += `<div class="text-2xl font-bold text-red-600">${results.iqr.outliers.length}</div>`;
                    html += `<div class="text-xs text-gray-500">${(results.iqr.outliers.length / values.length * 100).toFixed(1)}% of data</div>`;
                    html += '</div>';
                }

                if (useZScore) {
                    html += '<div class="bg-white p-3 rounded border border-blue-200">';
                    html += '<div class="text-sm text-gray-600">Z-Score 法</div>';
                    html += `<div class="text-2xl font-bold text-blue-600">${results.zscore.outliers.length}</div>`;
                    html += `<div class="text-xs text-gray-500">${(results.zscore.outliers.length / values.length * 100).toFixed(1)}% of data</div>`;
                    html += '</div>';
                }

                if (useModifiedZ) {
                    html += '<div class="bg-white p-3 rounded border border-green-200">';
                    html += '<div class="text-sm text-gray-600">Modified Z 法</div>';
                    html += `<div class="text-2xl font-bold text-green-600">${results.modifiedZ.outliers.length}</div>`;
                    html += `<div class="text-xs text-gray-500">${(results.modifiedZ.outliers.length / values.length * 100).toFixed(1)}% of data</div>`;
                    html += '</div>';
                }

                html += '</div>';
                html += `<div class="mt-3 text-sm"><span class="font-semibold">總異常值:</span> <span class="text-lg font-bold text-red-600">${allOutlierIndices.size}</span> 筆 (${(allOutlierIndices.size / values.length * 100).toFixed(1)}%)</div>`;
                html += '</div>';

                // 偵測方法詳情
                if (useIQR) {
                    html += '<h4 class="font-semibold mt-6 mb-2">🔴 IQR 法偵測結果</h4>';
                    html += '<div class="bg-red-50 p-3 rounded mb-4 text-sm">';
                    html += `<p><strong>偵測範圍:</strong> [${results.iqr.lowerBound.toFixed(3)}, ${results.iqr.upperBound.toFixed(3)}]</p>`;
                    html += `<p class="text-xs text-gray-600 mt-1">Q1 - ${iqrMultiplier}×IQR = ${results.iqr.lowerBound.toFixed(3)}, Q3 + ${iqrMultiplier}×IQR = ${results.iqr.upperBound.toFixed(3)}</p>`;
                    html += '</div>';

                    if (results.iqr.outliers.length > 0) {
                        html += displayOutlierTable(results.iqr.outliers, variable, 'IQR');
                    }
                }

                if (useZScore) {
                    html += '<h4 class="font-semibold mt-6 mb-2">🔵 Z-Score 法偵測結果</h4>';
                    html += '<div class="bg-blue-50 p-3 rounded mb-4 text-sm">';
                    html += `<p><strong>閾值:</strong> |Z-Score| > ${zThreshold}</p>`;
                    html += `<p class="text-xs text-gray-600 mt-1">超出平均值 ±${zThreshold} 個標準差</p>`;
                    html += '</div>';

                    if (results.zscore.outliers.length > 0) {
                        html += displayOutlierTable(results.zscore.outliers, variable, 'Z-Score');
                    }
                }

                if (useModifiedZ) {
                    html += '<h4 class="font-semibold mt-6 mb-2">🟢 Modified Z-Score 法偵測結果</h4>';
                    html += '<div class="bg-green-50 p-3 rounded mb-4 text-sm">';
                    html += `<p><strong>閾值:</strong> |Modified Z| > 3.5</p>`;
                    html += `<p class="text-xs text-gray-600 mt-1">使用中位數(MAD)，對極端值更穩健</p>`;
                    html += '</div>';

                    if (results.modifiedZ.outliers.length > 0) {
                        html += displayOutlierTable(results.modifiedZ.outliers, variable, 'Modified-Z');
                    }
                }

                // 視覺化
                html += '<div id="outlierBoxPlot" class="mt-6"></div>';
                html += '<div id="outlierScatterPlot" class="mt-6"></div>';

                // 處理建議
                html += '<div class="bg-yellow-50 p-4 rounded-lg mt-6">';
                html += '<h4 class="font-semibold mb-2">💡 處理建議</h4>';
                html += '<div class="text-sm text-gray-700 space-y-2">';

                if (allOutlierIndices.size > 0) {
                    const outlierRatio = allOutlierIndices.size / values.length;

                    if (outlierRatio > 0.1) {
                        html += '<p class="text-orange-600 font-semibold">⚠️ 異常值比例較高 (>10%)，建議檢查數據品質或調整閾值。</p>';
                    } else if (outlierRatio > 0.05) {
                        html += '<p class="text-yellow-600 font-semibold">注意: 異常值比例為 5-10%，屬於正常範圍。</p>';
                    } else {
                        html += '<p class="text-green-600 font-semibold">✅ 異常值比例正常 (<5%)。</p>';
                    }

                    html += '<p class="mt-2"><strong>處理選項:</strong></p>';
                    html += '<ul class="list-disc ml-6">';
                    html += '<li><strong>移除</strong>: 如確認為錯誤數據或極端離群值</li>';
                    html += '<li><strong>調整</strong>: 使用溫莎化(Winsorization)將極值限制在閾值範圍內</li>';
                    html += '<li><strong>分析</strong>: 單獨研究異常值，可能包含重要資訊</li>';
                    html += '<li><strong>保留</strong>: 如為真實數據且對分析有意義</li>';
                    html += '</ul>';
                } else {
                    html += '<p class="text-green-600 font-semibold">✅ 未偵測到異常值，數據品質良好。</p>';
                }

                html += '</div></div>';

                html += '</div>';

                resultsDiv.innerHTML = html;

                // 繪製圖表
                setTimeout(() => {
                    // 箱型圖
                    const boxTrace = {
                        y: data,
                        type: 'box',
                        name: variable,
                        marker: { color: '#ef4444' },
                        boxmean: 'sd'
                    };

                    Plotly.newPlot('outlierBoxPlot', [boxTrace], {
                        title: `${variable} 箱型圖 (標記異常值)`,
                        yaxis: { title: variable },
                        margin: { t: 40, b: 40, l: 60, r: 40 }
                    }, { responsive: true });

                    // 散點圖
                    const normalData = values.filter(v => !allOutlierIndices.has(v.index));
                    const outlierData = values.filter(v => allOutlierIndices.has(v.index));

                    const traces = [
                        {
                            x: normalData.map(v => v.index),
                            y: normalData.map(v => v.value),
                            mode: 'markers',
                            type: 'scatter',
                            name: '正常值',
                            marker: { color: '#10b981', size: 6 }
                        },
                        {
                            x: outlierData.map(v => v.index),
                            y: outlierData.map(v => v.value),
                            mode: 'markers',
                            type: 'scatter',
                            name: '異常值',
                            marker: { color: '#ef4444', size: 10, symbol: 'x' }
                        }
                    ];

                    Plotly.newPlot('outlierScatterPlot', traces, {
                        title: `${variable} 散點圖 (標記異常值)`,
                        xaxis: { title: '資料索引' },
                        yaxis: { title: variable },
                        margin: { t: 40, b: 60, l: 60, r: 40 }
                    }, { responsive: true });
                }, 100);

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">計算錯誤: ${error.message}</p>`;
                console.error(error);
            }
        }

        // 異常偵測輔助函數
        function calculateMAD(data, median) {
            const deviations = data.map(val => Math.abs(val - median));
            return ss.median(deviations);
        }

        function displayOutlierTable(outliers, variable, method) {
            let html = '<div class="overflow-x-auto mb-4">';
            html += '<table class="min-w-full divide-y divide-gray-200 border text-sm">';
            html += '<thead class="bg-gray-100">';
            html += '<tr>';
            html += '<th class="px-3 py-2 border">索引</th>';
            html += `<th class="px-3 py-2 border">${variable} 值</th>`;
            if (method === 'Z-Score') {
                html += '<th class="px-3 py-2 border">Z-Score</th>';
            } else if (method === 'Modified-Z') {
                html += '<th class="px-3 py-2 border">Modified Z</th>';
            }
            html += '<th class="px-3 py-2 border">偏離程度</th>';
            html += '</tr></thead><tbody>';

            // 只顯示前20筆
            outliers.slice(0, 20).forEach(outlier => {
                html += '<tr class="hover:bg-gray-50">';
                html += `<td class="px-3 py-2 border text-center">${outlier.index}</td>`;
                html += `<td class="px-3 py-2 border text-center font-semibold">${outlier.value.toFixed(3)}</td>`;

                if (method === 'Z-Score' && outlier.zScore !== undefined) {
                    const zColor = Math.abs(outlier.zScore) > 4 ? 'text-red-600' :
                        Math.abs(outlier.zScore) > 3.5 ? 'text-orange-600' : 'text-yellow-600';
                    html += `<td class="px-3 py-2 border text-center ${zColor} font-semibold">${outlier.zScore.toFixed(2)}</td>`;
                } else if (method === 'Modified-Z' && outlier.modifiedZ !== undefined) {
                    const zColor = Math.abs(outlier.modifiedZ) > 5 ? 'text-red-600' :
                        Math.abs(outlier.modifiedZ) > 4 ? 'text-orange-600' : 'text-yellow-600';
                    html += `<td class="px-3 py-2 border text-center ${zColor} font-semibold">${outlier.modifiedZ.toFixed(2)}</td>`;
                }

                const degree = Math.abs(outlier.zScore || outlier.modifiedZ || 0) > 4 ? '極端' :
                    Math.abs(outlier.zScore || outlier.modifiedZ || 0) > 3.5 ? '嚴重' : '中等';
                html += `<td class="px-3 py-2 border text-center text-xs">${degree}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';

            if (outliers.length > 20) {
                html += `<p class="text-xs text-gray-500 mt-2">顯示前20筆異常值 (共${outliers.length}筆)</p>`;
            }

            html += '</div>';
            return html;
        }

        // --- Initial Setup ---

        // ═══════════════════════════════════════════════════════════════
        // 隨機森林任務切換函數
        // ═══════════════════════════════════════════════════════════════
        function switchRFTask(task) {
            const regPanel = document.getElementById('rfRegressionPanel');
            const clsPanel = document.getElementById('rfClassificationPanel');
            const regTab = document.getElementById('rfRegressionTab');
            const clsTab = document.getElementById('rfClassificationTab');

            if (task === 'regression') {
                if (regPanel) regPanel.style.display = 'block';
                if (clsPanel) clsPanel.style.display = 'none';
                if (regTab) {
                    regTab.classList.add('border-green-500', 'text-green-600');
                    regTab.classList.remove('text-gray-500');
                }
                if (clsTab) {
                    clsTab.classList.remove('border-green-500', 'text-green-600');
                    clsTab.classList.add('text-gray-500');
                }
            } else {
                if (regPanel) regPanel.style.display = 'none';
                if (clsPanel) clsPanel.style.display = 'block';
                if (clsTab) {
                    clsTab.classList.add('border-green-500', 'text-green-600');
                    clsTab.classList.remove('text-gray-500');
                }
                if (regTab) {
                    regTab.classList.remove('border-green-500', 'text-green-600');
                    regTab.classList.add('text-gray-500');
                }
            }
        }

        document.addEventListener('DOMContentLoaded', setupEventListeners);
        /******************** 階層式集群 – 主流程 ********************/

        function runHierarchical() {
            const varSelect = document.getElementById('hierVariables');
            const selectedVars = Array.from(varSelect.selectedOptions).map(o => o.value);
            const msgEl = document.getElementById('hierMessage');
            const dendroDiv = document.getElementById('hierDendrogram');
            const heatmapDiv = document.getElementById('hierHeatmap');
            const silDiv = document.getElementById('hierSilhouette');
            const clusterSection = document.getElementById('hierClusterSection');

            msgEl.textContent = '';
            dendroDiv.innerHTML = '';
            heatmapDiv.innerHTML = '';
            silDiv.innerHTML = '';
            clusterSection.classList.add('hidden');
            hierarchicalState = null;

            if (!jsonData || jsonData.length === 0) {
                msgEl.textContent = '請先上傳並載入資料。';
                msgEl.classList.remove('text-gray-500');
                msgEl.classList.add('text-red-600');
                return;
            }
            if (selectedVars.length === 0) {
                msgEl.textContent = '請至少選擇一個用於分群的變數。';
                msgEl.classList.remove('text-gray-500');
                msgEl.classList.add('text-red-600');
                return;
            }

            // 樣本篩選與上限控制（<1000 筆）
            let dataRows = jsonData.map((row, idx) => ({ row, idx }));
            const maxSamples = 1000;
            if (dataRows.length > maxSamples) {
                dataRows = dataRows.slice(0, maxSamples);
                msgEl.textContent = `樣本數 ${jsonData.length} 筆，為避免瀏覽器凍結，僅取前 ${maxSamples} 筆進行階層式集群分析。`;
                msgEl.classList.remove('text-red-600');
                msgEl.classList.add('text-gray-500');
            }

            const n = dataRows.length;
            if (n < 2) {
                msgEl.textContent = '有效樣本數不足，無法進行集群分析。';
                msgEl.classList.remove('text-gray-500');
                msgEl.classList.add('text-red-600');
                return;
            }

            // 判斷每個變數的型態（沿用 numericHeaders / categoricalHeaders）
            const variableTypes = {};
            selectedVars.forEach(v => {
                variableTypes[v] = numericHeaders.includes(v) ? 'numeric' : 'categorical';
            });
            const typeSet = new Set(Object.values(variableTypes));
            let dataType = 'mixed';
            if (typeSet.size === 1 && typeSet.has('numeric')) dataType = 'numeric';
            else if (typeSet.size === 1 && typeSet.has('categorical')) dataType = 'categorical';

            // 距離方法選擇
            const chosenMetric = document.getElementById('hierDistanceMetric').value;
            const p = parseFloat(document.getElementById('hierMinkowskiP').value) || 3;
            let metric = chosenMetric;
            let metricNote = '';

            if (chosenMetric === 'auto') {
                if (dataType === 'numeric') metric = 'euclidean';
                else if (dataType === 'categorical') metric = 'hamming';
                else metric = 'gower';
            } else {
                if (dataType === 'mixed' && chosenMetric !== 'gower') {
                    metricNote = '資料為混合型，距離已自動改用 Gower。';
                    metric = 'gower';
                }
                if (dataType === 'categorical' && !['hamming', 'jaccard', 'gower'].includes(chosenMetric)) {
                    metricNote = '資料為類別型，距離已自動改用 Hamming。';
                    metric = 'hamming';
                }
            }

            // 計算距離矩陣
            const distMatrix = computeHierarchicalDistanceMatrix(dataRows, selectedVars, variableTypes, {
                metric,
                minkowskiP: p
            });

            // Linkage 方法
            let linkage = document.getElementById('hierLinkage').value;
            const numericOnlyWithEuclidean = (dataType === 'numeric' && metric === 'euclidean');

            if ((linkage === 'ward' || linkage === 'centroid') && !numericOnlyWithEuclidean) {
                alert('Ward 與重心法 (Centroid) 目前僅支援「全部為數值變數且距離為 Euclidean」的情境，系統已自動改用 Average Linkage。');
                linkage = 'average';
            }

            // 特徵矩陣（僅在 numeric + Euclidean + Ward/Centroid 時會用到）
            let featureMatrix = null;
            if (numericOnlyWithEuclidean) {
                featureMatrix = dataRows.map(({ row }) => selectedVars.map(v => row[v]));
            }

            // 執行凝聚式階層集群
            const clusterResult = agglomerativeClusteringFromDistance(distMatrix, linkage, {
                featureMatrix: (linkage === 'ward' || linkage === 'centroid') ? featureMatrix : null
            });

            hierarchicalState = {
                dataRows,
                selectedVars,
                variableTypes,
                dataType,
                metric,
                linkage,
                distMatrix,
                ...clusterResult
            };

            // 設定預設群集數（啟動 Slider）
            const defaultK = Math.min(5, Math.max(2, Math.floor(Math.sqrt(n))));
            const slider = document.getElementById('hierClusterCount');
            slider.max = Math.min(10, n);
            slider.min = 2;
            slider.value = defaultK;
            document.getElementById('hierClusterCountLabel').textContent = defaultK.toString();
            clusterSection.classList.remove('hidden');

            if (metricNote) {
                msgEl.textContent = metricNote;
                msgEl.classList.remove('text-red-600');
                msgEl.classList.add('text-gray-500');
            } else {
                msgEl.textContent = `距離: ${metric}, Linkage: ${linkage}, 樣本數: ${n}`;
                msgEl.classList.remove('text-red-600');
                msgEl.classList.add('text-gray-500');
            }

            updateHierarchicalClusterViews(defaultK);
        }

        /******************** 距離矩陣計算（含 Gower） ********************/

        function computeHierarchicalDistanceMatrix(dataRows, vars, varTypes, options) {
            const n = dataRows.length;
            const metric = options.metric || 'euclidean';
            const p = options.minkowskiP || 3;

            // Gower: 預先計算各數值變數的 range
            const numericRanges = {};
            if (metric === 'gower') {
                vars.forEach(v => {
                    if (varTypes[v] === 'numeric') {
                        const vals = dataRows
                            .map(({ row }) => row[v])
                            .filter(val => typeof val === 'number' && !isNaN(val));
                        if (vals.length > 0) {
                            const min = Math.min(...vals);
                            const max = Math.max(...vals);
                            numericRanges[v] = { min, max, range: (max - min) };
                        } else {
                            numericRanges[v] = { min: 0, max: 0, range: 0 };
                        }
                    }
                });
            }

            const distMatrix = Array.from({ length: n }, () => Array(n).fill(0));

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const rowI = dataRows[i].row;
                    const rowJ = dataRows[j].row;
                    let d = 0;

                    if (metric === 'euclidean' || metric === 'manhattan' || metric === 'minkowski') {
                        const diffs = [];
                        vars.forEach(v => {
                            const vi = rowI[v];
                            const vj = rowJ[v];
                            if (typeof vi === 'number' && typeof vj === 'number' && !isNaN(vi) && !isNaN(vj)) {
                                diffs.push({ vi, vj });
                            }
                        });
                        if (diffs.length === 0) {
                            d = 0;
                        } else {
                            if (metric === 'euclidean') {
                                let sumSq = 0;
                                diffs.forEach(({ vi, vj }) => {
                                    const diff = vi - vj;
                                    sumSq += diff * diff;
                                });
                                d = Math.sqrt(sumSq);
                            } else if (metric === 'manhattan') {
                                let sum = 0;
                                diffs.forEach(({ vi, vj }) => {
                                    sum += Math.abs(vi - vj);
                                });
                                d = sum;
                            } else { // minkowski
                                let sumP = 0;
                                diffs.forEach(({ vi, vj }) => {
                                    sumP += Math.pow(Math.abs(vi - vj), p);
                                });
                                d = Math.pow(sumP, 1 / p);
                            }
                        }
                    } else if (metric === 'hamming' || metric === 'jaccard') {
                        let matches = 0, total = 0;
                        vars.forEach(v => {
                            const vi = rowI[v];
                            const vj = rowJ[v];
                            if (vi == null || vj == null || vi === '' || vj === '') return;
                            total++;
                            if (vi === vj) matches++;
                        });
                        if (total === 0) d = 0;
                        else {
                            const dissim = (total - matches) / total;
                            d = dissim; // 此處 Hamming / Jaccard 對於單一類別欄位集合下等價
                        }
                    } else if (metric === 'gower') {
                        let sumSim = 0, count = 0;
                        vars.forEach(v => {
                            const vi = rowI[v];
                            const vj = rowJ[v];
                            if ((vi == null || vi === '') && (vj == null || vj === '')) return;

                            if (varTypes[v] === 'numeric') {
                                const rangeObj = numericRanges[v];
                                if (!rangeObj || rangeObj.range === 0 ||
                                    typeof vi !== 'number' || typeof vj !== 'number' ||
                                    isNaN(vi) || isNaN(vj)) return;
                                const diff = Math.abs(vi - vj);
                                const sij = 1 - diff / rangeObj.range;
                                sumSim += sij;
                                count++;
                            } else { // categorical
                                if (vi == null || vj == null || vi === '' || vj === '') return;
                                sumSim += (vi === vj ? 1 : 0);
                                count++;
                            }
                        });
                        if (count === 0) d = 0;
                        else {
                            const s = sumSim / count;
                            d = 1 - s;
                        }
                    } else {
                        d = 0;
                    }

                    distMatrix[i][j] = d;
                    distMatrix[j][i] = d;
                }
            }

            return distMatrix;
        }

        /******************** 凝聚式階層集群 (Agglomerative) ********************/

        function agglomerativeClusteringFromDistance(distMatrix, linkage, options) {
            const n = distMatrix.length;
            const clusters = [];
            const nodesById = {};
            const merges = [];

            for (let i = 0; i < n; i++) {
                clusters.push({ id: i, indices: [i], size: 1 });
                nodesById[i] = { id: i, left: null, right: null, height: 0 };
            }

            let currentClusterId = n;

            // 若使用 Ward / Centroid，預先計算 centroid & SSE
            const featureMatrix = options && options.featureMatrix ? options.featureMatrix : null;
            if ((linkage === 'ward' || linkage === 'centroid') && !featureMatrix) {
                // 理論上前面已經避免這種情況，這裡再防呆一下
                linkage = 'average';
            }

            if ((linkage === 'ward' || linkage === 'centroid') && featureMatrix) {
                clusters.forEach(c => {
                    c.centroid = computeClusterCentroid(c.indices, featureMatrix);
                    c.sse = computeClusterSSE(c.indices, c.centroid, featureMatrix);
                });
            }

            while (clusters.length > 1) {
                let bestI = 0, bestJ = 1, bestD = Infinity;

                for (let i = 0; i < clusters.length; i++) {
                    for (let j = i + 1; j < clusters.length; j++) {
                        const cA = clusters[i];
                        const cB = clusters[j];
                        let d;

                        if (linkage === 'single' || linkage === 'complete' || linkage === 'average') {
                            d = clusterDistanceByLinkage(cA.indices, cB.indices, distMatrix, linkage);
                        } else if (linkage === 'centroid') {
                            d = centroidDistance(cA, cB);
                        } else if (linkage === 'ward') {
                            d = wardDistance(cA, cB);
                        } else {
                            d = clusterDistanceByLinkage(cA.indices, cB.indices, distMatrix, 'average');
                        }

                        if (d < bestD) {
                            bestD = d;
                            bestI = i;
                            bestJ = j;
                        }
                    }
                }

                const clusterA = clusters[bestI];
                const clusterB = clusters[bestJ];
                const newIndices = clusterA.indices.concat(clusterB.indices);
                const newCluster = { id: currentClusterId, indices: newIndices, size: newIndices.length };

                if ((linkage === 'ward' || linkage === 'centroid') && featureMatrix) {
                    newCluster.centroid = computeClusterCentroid(newIndices, featureMatrix);
                    newCluster.sse = computeClusterSSE(newIndices, newCluster.centroid, featureMatrix);
                }

                merges.push({ id: currentClusterId, left: clusterA.id, right: clusterB.id, height: bestD });
                nodesById[currentClusterId] = { id: currentClusterId, left: clusterA.id, right: clusterB.id, height: bestD };

                // 移除舊 cluster, 加入新 cluster
                if (bestI > bestJ) { const tmp = bestI; bestI = bestJ; bestJ = tmp; }
                clusters.splice(bestJ, 1);
                clusters.splice(bestI, 1);
                clusters.push(newCluster);

                currentClusterId++;
            }

            const rootId = clusters[0].id;
            return { merges, nodesById, rootId, nSamples: n };
        }

        function clusterDistanceByLinkage(indicesA, indicesB, distMatrix, linkage) {
            let minD = Infinity, maxD = 0, sumD = 0, count = 0;
            indicesA.forEach(i => {
                indicesB.forEach(j => {
                    const d = distMatrix[i][j];
                    if (linkage === 'single') {
                        if (d < minD) minD = d;
                    } else if (linkage === 'complete') {
                        if (d > maxD) maxD = d;
                    } else {
                        sumD += d;
                        count++;
                    }
                });
            });
            if (linkage === 'single') return minD;
            if (linkage === 'complete') return maxD;
            return count > 0 ? (sumD / count) : 0;
        }

        // Centroid / Ward 相關工具（僅 numeric + Euclidean）

        function computeClusterCentroid(indices, featureMatrix) {
            const d = featureMatrix[0].length;
            const centroid = new Array(d).fill(0);
            indices.forEach(i => {
                const row = featureMatrix[i];
                for (let k = 0; k < d; k++) {
                    centroid[k] += row[k];
                }
            });
            for (let k = 0; k < d; k++) {
                centroid[k] /= indices.length;
            }
            return centroid;
        }

        function computeClusterSSE(indices, centroid, featureMatrix) {
            let sse = 0;
            indices.forEach(i => {
                const row = featureMatrix[i];
                let sumSq = 0;
                for (let k = 0; k < centroid.length; k++) {
                    const diff = row[k] - centroid[k];
                    sumSq += diff * diff;
                }
                sse += sumSq;
            });
            return sse;
        }

        function centroidDistance(clusterA, clusterB) {
            if (!clusterA.centroid || !clusterB.centroid) return 0;
            let sumSq = 0;
            for (let k = 0; k < clusterA.centroid.length; k++) {
                const diff = clusterA.centroid[k] - clusterB.centroid[k];
                sumSq += diff * diff;
            }
            return Math.sqrt(sumSq);
        }

        function wardDistance(clusterA, clusterB) {
            // Ward: 使用 centroid 差異估計 SSE 增量
            if (!clusterA.centroid || !clusterB.centroid) return 0;
            const nA = clusterA.size;
            const nB = clusterB.size;
            const total = nA + nB;
            let sumSq = 0;
            for (let k = 0; k < clusterA.centroid.length; k++) {
                const diff = clusterA.centroid[k] - clusterB.centroid[k];
                sumSq += diff * diff;
            }
            // 這個量與合併後 SSE 增量成正比
            return (nA * nB / total) * sumSq;
        }

        /******************** 根據 K 產生群集標籤 ********************/

        function getClusterLabelsForK(hState, k) {
            const { nSamples, nodesById, rootId } = hState;
            if (k <= 1) {
                return new Array(nSamples).fill(1);
            }

            const clusters = [rootId];

            function getHeight(nodeId) {
                const node = nodesById[nodeId];
                if (!node) return 0;
                return node.height || 0;
            }

            while (clusters.length < k) {
                let idxToSplit = -1;
                let maxHeight = -1;
                for (let i = 0; i < clusters.length; i++) {
                    const cid = clusters[i];
                    const node = nodesById[cid];
                    if (!node || node.left === null || node.right === null) continue;
                    if (node.height > maxHeight) {
                        maxHeight = node.height;
                        idxToSplit = i;
                    }
                }
                if (idxToSplit === -1) break;
                const nodeId = clusters[idxToSplit];
                const node = nodesById[nodeId];
                clusters.splice(idxToSplit, 1);
                clusters.push(node.left, node.right);
            }

            const labels = new Array(nSamples).fill(-1);

            function assignLeaves(nodeId, label) {
                const node = nodesById[nodeId];
                if (!node || node.left === null || node.right === null) {
                    const sampleIdx = nodeId;
                    if (sampleIdx < nSamples) labels[sampleIdx] = label;
                    return;
                }
                assignLeaves(node.left, label);
                assignLeaves(node.right, label);
            }

            clusters.forEach((cid, idx) => {
                assignLeaves(cid, idx + 1);
            });

            return labels;
        }

        /******************** Silhouette 係數計算 ********************/

        function computeSilhouette(distMatrix, labels) {
            const n = distMatrix.length;
            const clusters = {};
            for (let i = 0; i < n; i++) {
                const lab = labels[i];
                if (!clusters[lab]) clusters[lab] = [];
                clusters[lab].push(i);
            }

            const sValues = new Array(n).fill(0);

            for (let i = 0; i < n; i++) {
                const lab = labels[i];
                const sameCluster = clusters[lab];
                if (sameCluster.length <= 1) {
                    sValues[i] = 0;
                    continue;
                }

                // a(i): 同群內平均距離
                let aSum = 0, aCount = 0;
                sameCluster.forEach(j => {
                    if (j === i) return;
                    aSum += distMatrix[i][j];
                    aCount++;
                });
                const a = aCount > 0 ? (aSum / aCount) : 0;

                // b(i): 與其他群集中最小平均距離
                let b = Infinity;
                for (const otherLab in clusters) {
                    if (parseInt(otherLab, 10) === lab) continue;
                    const group = clusters[otherLab];
                    let sum = 0, count = 0;
                    group.forEach(j => {
                        sum += distMatrix[i][j];
                        count++;
                    });
                    if (count === 0) continue;
                    const avg = sum / count;
                    if (avg < b) b = avg;
                }
                if (!isFinite(b)) {
                    sValues[i] = 0;
                } else {
                    sValues[i] = (b - a) / Math.max(a, b);
                }
            }

            const clusterSilhouette = {};
            for (const lab in clusters) {
                const idxs = clusters[lab];
                const vals = idxs.map(i => sValues[i]);
                const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                clusterSilhouette[lab] = mean;
            }
            const overall = sValues.reduce((a, b) => a + b, 0) / n;

            return { sValues, clusterSilhouette, overall };
        }

        /******************** 視覺化：樹狀圖 + 熱圖 + Silhouette ********************/

        function updateHierarchicalClusterViews(k) {
            if (!hierarchicalState) return;
            const labels = getClusterLabelsForK(hierarchicalState, k);
            buildDendrogramPlot(hierarchicalState, labels, k);
            buildHierarchicalHeatmap(hierarchicalState, labels);
            buildHierarchicalSilhouette(hierarchicalState, labels);
        }

        function buildDendrogramPlot(hState, labels, k) {
            const { nodesById, rootId, nSamples, merges } = hState;
            const leafOrder = Array.from({ length: nSamples }, (_, i) => i);
            const xLeafPos = {};
            leafOrder.forEach((idx, pos) => { xLeafPos[idx] = pos; });

            const x = [];
            const y = [];

            function traverse(nodeId) {
                const node = nodesById[nodeId];
                if (!node) return { x: 0, y: 0 };
                if (node.left === null || node.right === null) {
                    const leafX = xLeafPos[nodeId];
                    return { x: leafX, y: 0 };
                }
                const leftPos = traverse(node.left);
                const rightPos = traverse(node.right);
                const nodeY = node.height;
                const nodeX = (leftPos.x + rightPos.x) / 2;

                // left vertical
                x.push(leftPos.x, leftPos.x, null);
                y.push(leftPos.y, nodeY, null);
                // right vertical
                x.push(rightPos.x, rightPos.x, null);
                y.push(rightPos.y, nodeY, null);
                // horizontal
                x.push(leftPos.x, rightPos.x, null);
                y.push(nodeY, nodeY, null);

                return { x: nodeX, y: nodeY };
            }

            traverse(rootId);

            const dendroTrace = {
                x,
                y,
                mode: 'lines',
                type: 'scatter',
                hoverinfo: 'none',
                line: { color: 'rgb(55, 96, 146)', width: 1.5 },
                name: 'dendrogram'
            };

            // 葉節點點點，用群集顏色表示
            const leafX = leafOrder.map(i => xLeafPos[i]);
            const leafY = new Array(nSamples).fill(0);
            const markerTrace = {
                x: leafX,
                y: leafY,
                mode: 'markers',
                type: 'scatter',
                marker: {
                    size: 7,
                    color: labels,
                    colorscale: 'Viridis',
                    colorbar: { title: 'Cluster' }
                },
                hovertemplate: '樣本 %{x}<extra></extra>',
                name: 'leaves'
            };

            // 計算切割線高度：第 (n-K) 次合併的高度
            const shapes = [];
            if (merges && merges.length > 0) {
                const mergeIndex = hState.nSamples - k - 1;
                if (mergeIndex >= 0 && mergeIndex < merges.length) {
                    const threshold = merges[mergeIndex].height;
                    shapes.push({
                        type: 'line',
                        x0: -1,
                        x1: nSamples + 1,
                        y0: threshold,
                        y1: threshold,
                        line: {
                            dash: 'dot',
                            width: 1.5,
                            color: 'rgba(220,38,38,0.8)'
                        }
                    });
                }
            }

            const layout = {
                title: `階層式集群樹狀圖 (K = ${k})`,
                xaxis: {
                    title: '樣本索引 (依原始順序)',
                    showticklabels: false
                },
                yaxis: { title: '距離 / 高度' },
                margin: { t: 40, l: 40, r: 10, b: 40 },
                shapes: shapes
            };

            Plotly.newPlot('hierDendrogram', [dendroTrace, markerTrace], layout, { responsive: true });
        }

        function buildHierarchicalHeatmap(hState, labels) {
            const { dataRows, selectedVars, variableTypes } = hState;
            const n = dataRows.length;
            const m = selectedVars.length;
            if (m === 0) {
                document.getElementById('hierHeatmap').innerHTML = '';
                return;
            }

            // ✅ 新增：建立依集群排序的索引映射
            const sortedIndices = [...Array(n).keys()].sort((a, b) => {
                // 先依集群標籤排序
                if (labels[a] !== labels[b]) {
                    return labels[a] - labels[b];
                }
                // 同集群內維持原順序
                return a - b;
            });

            // ✅ 修改：重新排列數據
            const z = [];
            const yLabels = [];
            const xLabels = sortedIndices.map(originalIdx =>
                `S${originalIdx + 1} (C${labels[originalIdx]})`  // 加上集群標籤
            );

            selectedVars.forEach(v => {
                yLabels.push(v);
                const rowVals = [];

                if (variableTypes[v] === 'numeric') {
                    const vals = dataRows
                        .map(({ row }) => row[v])
                        .filter(val => typeof val === 'number' && !isNaN(val));
                    const min = Math.min(...vals);
                    const max = Math.max(...vals);
                    const range = (max - min) || 1;

                    // ✅ 修改：按排序後的索引取值
                    for (let sortedIdx = 0; sortedIdx < n; sortedIdx++) {
                        const originalIdx = sortedIndices[sortedIdx];
                        const value = dataRows[originalIdx].row[v];
                        if (typeof value === 'number' && !isNaN(value)) {
                            rowVals.push((value - min) / range);
                        } else {
                            rowVals.push(null);
                        }
                    }
                } else {
                    // 類別變數處理
                    const distinct = Array.from(new Set(
                        dataRows.map(({ row }) => row[v]).filter(val => val != null && val !== '')
                    ));

                    // ✅ 修改：按排序後的索引取值
                    for (let sortedIdx = 0; sortedIdx < n; sortedIdx++) {
                        const originalIdx = sortedIndices[sortedIdx];
                        const value = dataRows[originalIdx].row[v];
                        if (value == null || value === '') {
                            rowVals.push(null);
                        } else {
                            rowVals.push(distinct.indexOf(value));
                        }
                    }
                }
                z.push(rowVals);
            });

            const heatData = [{
                z,
                x: xLabels,
                y: yLabels,
                type: 'heatmap',
                colorscale: 'Viridis',
                hovertemplate: '變數 %{y}<br>%{x}<br>標準化值: %{z}<extra></extra>'
            }];

            const layout = {
                title: '集群著色熱圖（依集群分組排列）',
                xaxis: {
                    title: '樣本 (已依集群排序)',
                    tickmode: 'linear',
                    tickangle: -45,
                    tickfont: { size: 10 }
                },
                yaxis: { title: '' },
                margin: { t: 40, l: 100, r: 10, b: 80 }
            };

            Plotly.newPlot('hierHeatmap', heatData, layout, { responsive: true });
        }


        function buildHierarchicalSilhouette(hState, labels) {
            const { distMatrix } = hState;
            const { clusterSilhouette, overall } = computeSilhouette(distMatrix, labels);

            const clusterIds = Object.keys(clusterSilhouette)
                .map(k => parseInt(k, 10))
                .sort((a, b) => a - b);
            const scores = clusterIds.map(id => clusterSilhouette[id]);

            const trace = {
                x: clusterIds,
                y: scores,
                type: 'bar',
                text: scores.map(v => v.toFixed(3)),
                textposition: 'auto',
                hovertemplate: '群集 %{x}<br>平均輪廓係數: %{y:.3f}<extra></extra>'
            };

            const layout = {
                title: `輪廓係數評估圖（整體平均 = ${overall.toFixed(3)}）`,
                xaxis: { title: '群集編號' },
                yaxis: { title: '平均輪廓係數', range: [-1, 1] },
                margin: { t: 40, l: 40, r: 10, b: 40 }
            };

            Plotly.newPlot('hierSilhouette', [trace], layout, { responsive: true });
        }

    </script>

    <!-- ===== v2.5 革命性修復: Modal 彈窗 HTML 結構 ===== -->
    <div id="predictionModal" class="prediction-modal">
        <div class="modal-content">
            <div class="modal-header">
                🎯 邏輯斯迴歸預測結果
            </div>
            <div id="modalResultContent" class="modal-result">
                <!-- 結果內容將由 JavaScript 動態插入 -->
            </div>
            <button class="modal-close-btn" onclick="closeModal()">✅ 關閉視窗</button>
        </div>
    </div>


    <!-- Neural Network (TensorFlow.js) + Permutation Importance -->
    <script>
        (function () {
            let nnModel = null;

            function buildTaskType(yVar) {
                const yValues = jsonData
                    .map(r => r[yVar])
                    .filter(v => v != null && v !== '');
                if (yValues.length === 0) return { type: null, uniqueY: [] };

                const uniqueY = Array.from(new Set(yValues));
                let taskType = 'regression';

                const allNumeric = uniqueY.every(v => typeof v === 'number' && !isNaN(v));
                if (!allNumeric) {
                    if (uniqueY.length === 2) {
                        taskType = 'binary-classification';
                    } else {
                        taskType = 'multi-class-classification';
                    }
                } else {
                    if (uniqueY.length === 2) {
                        taskType = 'binary-classification';
                    } else if (uniqueY.length > 2 && uniqueY.length <= 12) {
                        taskType = 'multi-class-classification';
                    } else {
                        taskType = 'regression';
                    }
                }
                return { type: taskType, uniqueY };
            }

            function prepareXY(yVar, xVars, taskInfo) {
                // 1. Identify variable types and build vocabularies
                const featureMetadata = xVars.map(x => {
                    // Check if numeric: all non-empty values must be numbers
                    const isNumeric = jsonData.every(r => {
                        const v = r[x];
                        return v == null || v === '' || (typeof v === 'number' && !isNaN(v));
                    });

                    if (isNumeric) {
                        return { name: x, type: 'numeric', indices: [] };
                    } else {
                        // Build vocabulary
                        const unique = new Set();
                        jsonData.forEach(r => {
                            const v = r[x];
                            if (v != null && v !== '') unique.add(String(v));
                        });
                        return { name: x, type: 'categorical', categories: Array.from(unique).sort(), indices: [] };
                    }
                });

                // 2. Filter rows and Transform
                const rows = [];
                jsonData.forEach(row => {
                    const y = row[yVar];
                    if (y == null || y === '') return;

                    const flatRow = [];
                    let valid = true;

                    for (let i = 0; i < xVars.length; i++) {
                        const x = xVars[i];
                        const meta = featureMetadata[i];
                        const v = row[x];

                        if (v == null || v === '') {
                            valid = false; break;
                        }

                        if (meta.type === 'numeric') {
                            if (typeof v !== 'number' || isNaN(v)) {
                                valid = false; break;
                            }
                            flatRow.push(v);
                        } else {
                            // One-Hot Encoding
                            const catIdx = meta.categories.indexOf(String(v));
                            if (catIdx === -1) {
                                valid = false; break;
                            }
                            // Push 0s and 1
                            for (let k = 0; k < meta.categories.length; k++) {
                                flatRow.push(k === catIdx ? 1 : 0);
                            }
                        }
                    }

                    if (valid) {
                        rows.push({ x: flatRow, y });
                    }
                });

                if (rows.length === 0) return null;

                const maxSamples = 1000;
                const sampled = rows.length > maxSamples
                    ? rows.sort(() => Math.random() - 0.5).slice(0, maxSamples)
                    : rows;

                const xsArr = sampled.map(r => r.x);
                let ysArr;

                if (taskInfo.type === 'regression') {
                    ysArr = sampled.map(r => r.y);
                } else if (taskInfo.type === 'binary-classification') {
                    const unique = taskInfo.uniqueY;
                    ysArr = sampled.map(r => (r.y === unique[0] ? 0 : 1));
                } else {
                    const unique = taskInfo.uniqueY;
                    ysArr = sampled.map(r => unique.indexOf(r.y));
                }

                // 3. Assign Indices and Normalize Numeric Columns
                let currentIndex = 0;
                featureMetadata.forEach(meta => {
                    if (meta.type === 'numeric') {
                        meta.indices = [currentIndex++];
                    } else {
                        const len = meta.categories.length;
                        meta.indices = Array.from({ length: len }, (_, i) => currentIndex + i);
                        currentIndex += len;
                    }
                });

                const numericIndices = featureMetadata.filter(m => m.type === 'numeric').flatMap(m => m.indices);

                const numericMeans = {};
                const numericStds = {};

                if (numericIndices.length > 0) {
                    numericIndices.forEach(idx => {
                        let sum = 0;
                        xsArr.forEach(row => sum += row[idx]);
                        numericMeans[idx] = sum / xsArr.length;
                    });

                    numericIndices.forEach(idx => {
                        let sumSq = 0;
                        const m = numericMeans[idx];
                        xsArr.forEach(row => sumSq += Math.pow(row[idx] - m, 2));
                        numericStds[idx] = Math.sqrt(sumSq / xsArr.length) || 1;
                    });

                    // Apply normalization
                    xsArr.forEach(row => {
                        numericIndices.forEach(idx => {
                            row[idx] = (row[idx] - numericMeans[idx]) / numericStds[idx];
                        });
                    });
                }

                return { xsArr, ysArr, featureMetadata, numericMeans, numericStds };
            }

            function buildModel(inputDim, taskInfo, hiddenUnits) {
                if (nnModel) {
                    nnModel.dispose();
                    nnModel = null;
                }
                const model = tf.sequential();
                model.add(tf.layers.dense({
                    units: hiddenUnits,
                    activation: 'relu',
                    inputShape: [inputDim]
                }));

                if (taskInfo.type === 'regression') {
                    model.add(tf.layers.dense({ units: 1, activation: 'linear' }));
                    model.compile({
                        optimizer: tf.train.adam(),
                        loss: 'meanSquaredError',
                        metrics: ['mse', 'mae']
                    });
                } else if (taskInfo.type === 'binary-classification') {
                    model.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));
                    model.compile({
                        optimizer: tf.train.adam(),
                        loss: 'binaryCrossentropy',
                        metrics: ['accuracy']
                    });
                } else {
                    model.add(tf.layers.dense({
                        units: taskInfo.uniqueY.length,
                        activation: 'softmax'
                    }));
                    model.compile({
                        optimizer: tf.train.adam(),
                        loss: 'sparseCategoricalCrossentropy',
                        metrics: ['accuracy']
                    });
                }
                nnModel = model;
                return model;
            }

            async function evaluateModel(model, xsArr, ysArr, taskType) {
                const xs = tf.tensor2d(xsArr);
                let ys;
                if (taskType === 'regression') {
                    ys = tf.tensor2d(ysArr, [ysArr.length, 1]);
                } else {
                    ys = tf.tensor1d(ysArr, 'int32');
                }

                try {
                    const evalRes = model.evaluate(xs, ys);
                    let loss = 0, metric = 0;

                    if (Array.isArray(evalRes)) {
                        const lossTensor = evalRes[0];
                        // For regression: [loss, mse, mae]. We take mse (index 1).
                        // For classification: [loss, acc]. We take acc (index 1).
                        const metricTensor = evalRes.length > 1 ? evalRes[1] : null;

                        const lossData = await lossTensor.data();
                        loss = lossData[0];

                        if (metricTensor) {
                            const metricData = await metricTensor.data();
                            metric = metricData[0];
                        }

                        // Dispose all tensors
                        evalRes.forEach(t => t.dispose());
                    } else {
                        const lossData = await evalRes.data();
                        loss = lossData[0];
                        evalRes.dispose();
                    }
                    return { loss, metric };
                } finally {
                    xs.dispose();
                    ys.dispose();
                }
            }

            async function computePermutationImportance(model, xsArr, ysArr, xVars, taskInfo, featureMetadata) {
                const baseline = await evaluateModel(model, xsArr, ysArr, taskInfo.type);
                const importance = [];
                const nRepeats = 5; // Repeat 5 times to stabilize results

                for (let j = 0; j < featureMetadata.length; j++) {
                    const meta = featureMetadata[j];
                    const indices = meta.indices;
                    let totalImp = 0;

                    for (let r = 0; r < nRepeats; r++) {
                        // Copy xsArr
                        const permXs = xsArr.map(row => row.slice());

                        // Extract the block of columns for this feature
                        const colBlock = permXs.map(r => indices.map(idx => r[idx]));

                        // Shuffle the block (Fisher-Yates)
                        for (let i = colBlock.length - 1; i > 0; i--) {
                            const k = Math.floor(Math.random() * (i + 1));
                            [colBlock[i], colBlock[k]] = [colBlock[k], colBlock[i]];
                        }

                        // Put back shuffled values
                        for (let i = 0; i < permXs.length; i++) {
                            indices.forEach((idx, localIdx) => {
                                permXs[i][idx] = colBlock[i][localIdx];
                            });
                        }

                        const perm = await evaluateModel(model, permXs, ysArr, taskInfo.type);
                        let imp;
                        if (taskInfo.type === 'regression') {
                            imp = perm.loss - baseline.loss;
                        } else {
                            imp = baseline.metric - perm.metric;
                        }
                        totalImp += imp;
                    }

                    importance.push({ name: meta.name, value: totalImp / nRepeats });
                }
                return { baseline, importance };
            }

            async function runNeuralNetworkTraining() {
                const resultsDiv = document.getElementById('nnResults');
                const summaryDiv = document.getElementById('nnImportanceSummary');
                const plotDivId = 'nnImportancePlot';
                const plotDivEl = document.getElementById(plotDivId);
                const lcDivId = 'nnLearningCurve';
                const cmDivId = 'nnConfusionMatrix';

                if (summaryDiv) summaryDiv.innerHTML = '';

                // Clear plots
                [plotDivId, lcDivId, cmDivId].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.innerHTML = '';
                        if (window.Plotly) Plotly.purge(id);
                    }
                });

                if (!resultsDiv) return;

                if (!jsonData || !Array.isArray(jsonData) || jsonData.length === 0 || !headers) {
                    resultsDiv.innerHTML = '<p class="text-red-600">請先在「上傳資料」區塊匯入資料，並確認已看到資料預覽。</p>';
                    return;
                }

                const ySelect = document.getElementById('nnY');
                const xSelect = document.getElementById('nnX');
                const hiddenInput = document.getElementById('nnHiddenUnits');
                const epochsInput = document.getElementById('nnEpochs');

                const yVar = ySelect ? ySelect.value : '';
                const xVars = xSelect ? Array.from(xSelect.selectedOptions).map(o => o.value) : [];

                // Check for overlap
                if (xVars.includes(yVar)) {
                    alert(`錯誤：目標變數 (Y) "${yVar}" 不能同時作為特徵變數 (X)。請從特徵變數中移除它。`);
                    resultsDiv.innerHTML = ''; // Clear loading state if any
                    return;
                }
                const hiddenUnits = parseInt(hiddenInput ? hiddenInput.value : '8', 10) || 8;
                const epochs = parseInt(epochsInput ? epochsInput.value : '200', 10) || 200;

                if (!yVar || xVars.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-red-600">請至少選擇 1 個應變數 (Y) 與 1 個以上自變數 (X)。</p>';
                    return;
                }

                const taskInfo = buildTaskType(yVar);
                if (!taskInfo.type) {
                    resultsDiv.innerHTML = '<p class="text-red-600">無法判斷任務類型，請確認應變數資料是否有效。</p>';
                    return;
                }

                const prep = prepareXY(yVar, xVars, taskInfo);
                if (!prep) {
                    resultsDiv.innerHTML = '<p class="text-red-600">選擇的欄位缺少足夠的有效數值資料，請重新選擇。</p>';
                    return;
                }

                const { xsArr, ysArr, featureMetadata, numericMeans, numericStds } = prep;
                const inputDim = xsArr[0].length;

                // --- Normalize Y for Regression to improve convergence ---
                let yMean = 0, yStd = 1;
                if (taskInfo.type === 'regression') {
                    const n = ysArr.length;
                    yMean = ysArr.reduce((a, b) => a + b, 0) / n;
                    const sumSq = ysArr.reduce((a, b) => a + Math.pow(b - yMean, 2), 0);
                    yStd = Math.sqrt(sumSq / n) || 1;
                    // Apply normalization to ysArr in place
                    for (let i = 0; i < n; i++) {
                        ysArr[i] = (ysArr[i] - yMean) / yStd;
                    }
                }

                // --- Shuffle & Split (80% Train, 20% Val) ---
                const indices = Array.from({ length: xsArr.length }, (_, i) => i);
                // Fisher-Yates Shuffle
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }

                const shuffledXs = indices.map(i => xsArr[i]);
                const shuffledYs = indices.map(i => ysArr[i]);

                const splitIdx = Math.floor(shuffledXs.length * 0.8);
                const xTrain = shuffledXs.slice(0, splitIdx);
                const yTrain = shuffledYs.slice(0, splitIdx);
                const xVal = shuffledXs.slice(splitIdx);
                const yVal = shuffledYs.slice(splitIdx);

                if (xTrain.length === 0 || xVal.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-red-600">資料筆數過少，無法進行訓練/驗證分割。</p>';
                    return;
                }

                // Create Tensors
                const xTrainTensor = tf.tensor2d(xTrain);
                const xValTensor = tf.tensor2d(xVal);

                let yTrainTensor, yValTensor;
                if (taskInfo.type === 'regression') {
                    yTrainTensor = tf.tensor2d(yTrain, [yTrain.length, 1]);
                    yValTensor = tf.tensor2d(yVal, [yVal.length, 1]);
                } else {
                    yTrainTensor = tf.tensor1d(yTrain, 'int32');
                    yValTensor = tf.tensor1d(yVal, 'int32');
                }

                const model = buildModel(inputDim, taskInfo, hiddenUnits);

                resultsDiv.innerHTML = `
                <h3 class="text-lg font-semibold mb-2">📌 神經網絡訓練中...</h3>
                <p class="mb-2">總樣本數：<strong>${xsArr.length}</strong> (訓練：${xTrain.length}, 驗證：${xVal.length})</p>
                <p class="mb-2">特徵數：<strong>${xVars.length}</strong> (擴展後輸入維度：${inputDim})，任務類型：<strong>${taskInfo.type}</strong></p>
                <p class="mb-2">Epochs：<strong>${epochs}</strong>，隱藏層神經元：<strong>${hiddenUnits}</strong></p>
                <div id="nnProgress" class="mt-2 text-sm text-gray-700"></div>
            `;

                const progressDiv = document.getElementById('nnProgress');
                const history = { epoch: [], loss: [], val_loss: [], metric: [], val_metric: [] };

                await model.fit(xTrainTensor, yTrainTensor, {
                    epochs,
                    batchSize: 32,
                    validationData: [xValTensor, yValTensor],
                    shuffle: true,
                    callbacks: {
                        onEpochEnd: async (epoch, logs) => {
                            history.epoch.push(epoch + 1);
                            history.loss.push(logs.loss);
                            history.val_loss.push(logs.val_loss);

                            const metricKey = taskInfo.type === 'regression' ? (logs.mae !== undefined ? 'mae' : 'mse') : 'acc';
                            const valMetricKey = 'val_' + metricKey;

                            history.metric.push(logs[metricKey] || 0);
                            history.val_metric.push(logs[valMetricKey] || 0);

                            if (progressDiv) {
                                progressDiv.innerHTML = `
                                <p>Epoch ${epoch + 1} / ${epochs}</p>
                                <p>Train Loss：${logs.loss.toFixed(4)} | Val Loss：${logs.val_loss.toFixed(4)}</p>
                                <p>Train ${metricKey}：${(logs[metricKey] || 0).toFixed(4)} | Val ${metricKey}：${(logs[valMetricKey] || 0).toFixed(4)}</p>
                            `;
                            }
                            await tf.nextFrame();
                        }
                    }
                });

                // --- Visualization: Learning Curve ---
                if (window.Plotly) {
                    const metricName = taskInfo.type === 'regression' ? 'MAE/MSE' : 'Accuracy';

                    const traceLossTrain = { x: history.epoch, y: history.loss, type: 'scatter', mode: 'lines', name: 'Train Loss' };
                    const traceLossVal = { x: history.epoch, y: history.val_loss, type: 'scatter', mode: 'lines', name: 'Val Loss' };

                    const traceMetricTrain = { x: history.epoch, y: history.metric, type: 'scatter', mode: 'lines', name: `Train ${metricName}` };
                    const traceMetricVal = { x: history.epoch, y: history.val_metric, type: 'scatter', mode: 'lines', name: `Val ${metricName}` };

                    const layoutLC = {
                        title: 'Learning Curve (Train vs Validation)',
                        grid: { rows: 1, columns: 2, pattern: 'independent' },
                        xaxis: { title: 'Epoch' },
                        yaxis: { title: 'Loss' },
                        xaxis2: { title: 'Epoch' },
                        yaxis2: { title: metricName },
                        showlegend: true,
                        legend: { orientation: 'h', y: -0.2 }
                    };

                    // Subplots using domain
                    traceLossTrain.xaxis = 'x'; traceLossTrain.yaxis = 'y';
                    traceLossVal.xaxis = 'x'; traceLossVal.yaxis = 'y';
                    traceMetricTrain.xaxis = 'x2'; traceMetricTrain.yaxis = 'y2';
                    traceMetricVal.xaxis = 'x2'; traceMetricVal.yaxis = 'y2';

                    layoutLC.xaxis.domain = [0, 0.45];
                    layoutLC.yaxis.domain = [0, 1];
                    layoutLC.xaxis2.domain = [0.55, 1];
                    layoutLC.yaxis2.domain = [0, 1];

                    Plotly.newPlot(lcDivId, [traceLossTrain, traceLossVal, traceMetricTrain, traceMetricVal], layoutLC, { responsive: true });
                }

                // --- Visualization: Confusion Matrix (Classification Only) ---
                if (taskInfo.type !== 'regression' && window.Plotly) {
                    const valPredsTensor = model.predict(xValTensor);
                    let valPreds;
                    if (taskInfo.type === 'binary-classification') {
                        valPreds = valPredsTensor.greater(0.5).cast('int32').dataSync();
                    } else {
                        valPreds = valPredsTensor.argMax(-1).dataSync();
                    }
                    const valTrue = yValTensor.dataSync();
                    valPredsTensor.dispose();

                    // Compute Confusion Matrix
                    const uniqueLabels = [...new Set([...valTrue, ...valPreds])].sort((a, b) => a - b);
                    const matrix = Array.from({ length: uniqueLabels.length }, () => Array(uniqueLabels.length).fill(0));
                    const labelMap = {};
                    uniqueLabels.forEach((l, i) => labelMap[l] = i);

                    for (let i = 0; i < valTrue.length; i++) {
                        const r = labelMap[valTrue[i]];
                        const c = labelMap[valPreds[i]];
                        if (r !== undefined && c !== undefined) {
                            matrix[r][c]++;
                        }
                    }

                    const traceCM = {
                        z: matrix,
                        x: uniqueLabels.map(l => `Pred ${l}`),
                        y: uniqueLabels.map(l => `True ${l}`),
                        type: 'heatmap',
                        colorscale: 'Blues',
                        showscale: true,
                        text: matrix.map(row => row.map(String)),
                        texttemplate: "%{text}",
                        hoverinfo: 'z'
                    };

                    const layoutCM = {
                        title: 'Confusion Matrix (Validation Set)',
                        xaxis: { title: 'Predicted Label' },
                        yaxis: { title: 'True Label' },
                        margin: { t: 40, l: 60, r: 10, b: 60 }
                    };

                    Plotly.newPlot(cmDivId, [traceCM], layoutCM, { responsive: true });

                    // --- Calculate Classification Metrics ---
                    let correct = 0;
                    let macroPrecision = 0;
                    let macroRecall = 0;
                    let macroF1 = 0;
                    const totalSamples = valTrue.length;

                    for (let i = 0; i < uniqueLabels.length; i++) {
                        const tp = matrix[i][i];
                        correct += tp;

                        // FP: Sum of column i (excluding diagonal)
                        let fp = 0;
                        for (let r = 0; r < uniqueLabels.length; r++) {
                            if (r !== i) fp += matrix[r][i];
                        }

                        // FN: Sum of row i (excluding diagonal)
                        let fn = 0;
                        for (let c = 0; c < uniqueLabels.length; c++) {
                            if (c !== i) fn += matrix[i][c];
                        }

                        const p = (tp + fp) > 0 ? tp / (tp + fp) : 0;
                        const r = (tp + fn) > 0 ? tp / (tp + fn) : 0;
                        const f1 = (p + r) > 0 ? 2 * (p * r) / (p + r) : 0;

                        macroPrecision += p;
                        macroRecall += r;
                        macroF1 += f1;
                    }

                    const accuracy = correct / totalSamples;
                    macroPrecision /= uniqueLabels.length;
                    macroRecall /= uniqueLabels.length;
                    macroF1 /= uniqueLabels.length;

                    const metricsHtml = `
                        <div class="mt-4 p-4 bg-green-50 rounded text-sm" id="nnClassificationMetrics">
                            <h4 class="font-semibold mb-2">📊 分類模型效能指標 (Validation Set)</h4>
                            <ul class="list-disc list-inside text-gray-700 space-y-1">
                                <li><strong>Accuracy (準確率)</strong>: ${(accuracy * 100).toFixed(2)}% - 整體預測正確的比例。</li>
                                <li><strong>Precision (精確率)</strong>: ${(macroPrecision * 100).toFixed(2)}% - 預測為某類別中，真正屬於該類別的比例 (Macro Avg)。</li>
                                <li><strong>Recall (召回率)</strong>: ${(macroRecall * 100).toFixed(2)}% - 實際為某類別中，被正確預測出來的比例 (Macro Avg)。</li>
                                <li><strong>F1-Score</strong>: ${(macroF1 * 100).toFixed(2)}% - Precision 與 Recall 的調和平均數，綜合評估指標。</li>
                            </ul>
                        </div>
                    `;

                    // Insert after cmDivId
                    const cmDiv = document.getElementById(cmDivId);
                    if (cmDiv) {
                        const oldMetrics = document.getElementById('nnClassificationMetrics');
                        if (oldMetrics) oldMetrics.remove();
                        cmDiv.insertAdjacentHTML('afterend', metricsHtml);
                    }
                }

                // --- Calculate Additional Metrics (R2, MAPE) for Regression ---
                let regressionMetricsHtml = '';
                if (taskInfo.type === 'regression') {
                    // Helper to calc R2 and MAPE
                    const calcMetrics = (xTensor, yTensor) => {
                        return tf.tidy(() => {
                            const predsScaled = model.predict(xTensor);
                            // Denormalize for correct metrics
                            const preds = predsScaled.mul(yStd).add(yMean);
                            const yTrue = yTensor.mul(yStd).add(yMean);

                            // R2
                            const meanY = yTrue.mean();
                            const ssTot = yTrue.sub(meanY).square().sum();
                            const ssRes = yTrue.sub(preds).square().sum();
                            const r2 = tf.sub(1, ssRes.div(ssTot)).dataSync()[0];

                            // MAPE
                            const epsilon = 1e-7;
                            const absDiff = yTrue.sub(preds).abs();
                            const absTrue = yTrue.abs().add(epsilon);
                            const mape = absDiff.div(absTrue).mean().mul(100).dataSync()[0];

                            return { r2, mape };
                        });
                    };

                    const trainMetrics = calcMetrics(xTrainTensor, yTrainTensor);
                    const valMetrics = calcMetrics(xValTensor, yValTensor);

                    regressionMetricsHtml = `
                        <div class="mt-4 mb-4 p-4 bg-blue-50 rounded text-sm">
                            <h4 class="font-semibold mb-2">📊 模型效能指標 (Regression Metrics)</h4>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <p class="font-medium text-gray-700">訓練集 (Train)</p>
                                    <ul class="list-disc list-inside text-gray-600">
                                        <li>R² (R-Squared): <strong>${(trainMetrics.r2 * 100).toFixed(2)}%</strong></li>
                                        <li>MAPE: <strong>${trainMetrics.mape.toFixed(2)}%</strong></li>
                                    </ul>
                                </div>
                                <div>
                                    <p class="font-medium text-gray-700">驗證集 (Validation)</p>
                                    <ul class="list-disc list-inside text-gray-600">
                                        <li>R² (R-Squared): <strong>${(valMetrics.r2 * 100).toFixed(2)}%</strong></li>
                                        <li>MAPE: <strong>${valMetrics.mape.toFixed(2)}%</strong></li>
                                    </ul>
                                </div>
                            </div>
                            <p class="mt-2 text-xs text-gray-500">註：R² 越接近 100% 越好；MAPE 越低越好。</p>
                        </div>
                    `;
                }

                xTrainTensor.dispose();
                yTrainTensor.dispose();
                xValTensor.dispose();
                yValTensor.dispose();

                const lastLoss = history.loss[history.loss.length - 1];
                // If regression, scale loss back to original units for display
                const displayLoss = taskInfo.type === 'regression' ? lastLoss * (yStd * yStd) : lastLoss;

                const lastMetric = history.metric[history.metric.length - 1] || 0;
                const displayMetric = taskInfo.type === 'regression' ? lastMetric * yStd : lastMetric; // MAE scales linearly

                let metricLabel = '';
                if (taskInfo.type === 'regression') {
                    metricLabel = 'MAE/MSE (視設定而定)';
                } else {
                    metricLabel = 'Accuracy';
                }

                resultsDiv.innerHTML = `
                <h3 class="text-lg font-semibold mb-2">✅ 神經網絡訓練完成</h3>
                <p class="mb-2">樣本數：<strong>${xsArr.length}</strong>，特徵數：<strong>${xVars.length}</strong> (擴展維度：${inputDim})，任務類型：<strong>${taskInfo.type}</strong></p>
                <p class="mb-2">最終 Train Loss (Original Scale)：<strong>${displayLoss.toFixed(4)}</strong></p>
                <p class="mb-2">最終 Train ${metricLabel} (Original Scale)：<strong>${displayMetric.toFixed(4)}</strong></p>
                ${regressionMetricsHtml}
            `;


                try {
                    const importanceInfo = await computePermutationImportance(model, xsArr, ysArr, xVars, taskInfo, featureMetadata);
                    const { baseline, importance } = importanceInfo;

                    // Scale importance back if regression
                    if (taskInfo.type === 'regression') {
                        baseline.loss = baseline.loss * (yStd * yStd);
                        importance.forEach(d => d.value = d.value * (yStd * yStd));
                    }

                    const sorted = importance.slice().sort((a, b) => b.value - a.value);
                    const featureNames = sorted.map(d => d.name);
                    const values = sorted.map(d => d.value);

                    if (summaryDiv && sorted.length > 0) {
                        const top = sorted.slice(0, 3);
                        const li = top.map(d => `<li>${d.name}：${d.value.toFixed(4)}</li>`).join('');
                        const baselineText = taskInfo.type === 'regression'
                            ? `Baseline Loss (MSE)：${baseline.loss.toFixed(4)}`
                            : `Baseline Accuracy：${baseline.metric.toFixed(4)}`;
                        summaryDiv.innerHTML = `
                        <h4 class="font-semibold mb-1">📊 Permutation Importance 摘要（Top 3）</h4>
                        <p class="text-xs text-gray-500 mb-1">數值越大代表「打亂此特徵」對模型表現破壞越大，重要性越高。</p>
                        <p class="mb-1 text-sm">${baselineText}</p>
                        <ul class="list-disc list-inside text-sm space-y-1">
                            ${li}
                        </ul>
                    `;
                    }

                    if (plotDivEl && window.Plotly && featureNames.length > 0) {
                        const yLabel = taskInfo.type === 'regression'
                            ? 'Loss 增加量 (ΔLoss)'
                            : 'Accuracy 下降量 (ΔAcc)';

                        const trace = {
                            type: 'bar',
                            x: featureNames,
                            y: values,
                        };
                        const layout = {
                            title: '神經網絡 Permutation Importance',
                            xaxis: { title: '特徵變數' },
                            yaxis: { title: yLabel },
                            margin: { t: 40, l: 60, r: 10, b: 80 }
                        };
                        Plotly.newPlot(plotDivId, [trace], layout, { responsive: true });
                    }
                } catch (e) {
                    console.error('Permutation importance error:', e);
                    if (summaryDiv) {
                        summaryDiv.innerHTML = `<p class="text-amber-600">Permutation Importance 計算時發生錯誤 (${e.message})，但模型訓練結果已完成，可先用於教學說明。</p>`;
                    }
                }

                // === Store model and metadata for prediction (global) ===
                window.nnPredictionData = {
                    model,
                    featureMetadata,
                    yMean,
                    yStd,
                    numericMeans,
                    numericStds,
                    taskInfo,
                    yVar
                };

                // === Append Prediction Section at the VERY BOTTOM ===
                // First, remove any existing prediction section to avoid duplicates
                const existingPredSection = document.getElementById('nnPredictionSection');
                if (existingPredSection) {
                    existingPredSection.remove();
                }

                const nnConfusionMatrixDiv = document.getElementById('nnConfusionMatrix');
                if (nnConfusionMatrixDiv) {
                    const predictionHtml = `
                    <div id="nnPredictionSection" class="mt-8 border-t pt-6">
                        <h4 class="text-lg font-bold mb-4 flex items-center gap-2">
                            <svg class="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                            神經網絡模型預測 (Prediction)
                        </h4>
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4" id="nnPredictionInputs">
                                ${featureMetadata.map((meta, i) => {
                        if (meta.type === 'numeric') {
                            return `
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">${meta.name}</label>
                                                <input type="number" id="pred_input_${i}" class="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500" placeholder="輸入數值">
                                            </div>
                                        `;
                        } else {
                            const options = meta.categories.map(c => `<option value="${c}">${c}</option>`).join('');
                            return `
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">${meta.name}</label>
                                                <select id="pred_input_${i}" class="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500">
                                                    ${options}
                                                </select>
                                            </div>
                                        `;
                        }
                    }).join('')}
                            </div>
                            <button id="btnPredictNN" class="bg-purple-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-purple-700 shadow-md transition-colors flex items-center gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>
                                進行預測
                            </button>
                            <div id="nnPredictionResult" class="mt-4 hidden"></div>
                        </div>
                    </div>
                `;
                    nnConfusionMatrixDiv.insertAdjacentHTML('afterend', predictionHtml);

                    // Bind Prediction Event
                    const btnPredict = document.getElementById('btnPredictNN');
                    if (btnPredict) {
                        btnPredict.addEventListener('click', async () => {
                            const data = window.nnPredictionData;
                            if (!data) {
                                alert('請先訓練模型');
                                return;
                            }

                            const { model, featureMetadata, yMean, yStd, numericMeans, numericStds, taskInfo, yVar } = data;
                            const resultDiv = document.getElementById('nnPredictionResult');
                            resultDiv.classList.remove('hidden');
                            resultDiv.innerHTML = '<span class="text-gray-500">預測中...</span>';

                            try {
                                const inputVector = [];

                                // 1. Collect and Encode Inputs
                                for (let i = 0; i < featureMetadata.length; i++) {
                                    const meta = featureMetadata[i];
                                    const el = document.getElementById(`pred_input_${i}`);
                                    const val = el.value;

                                    if (meta.type === 'numeric') {
                                        const numVal = parseFloat(val);
                                        if (isNaN(numVal)) throw new Error(`請輸入有效的數值：${meta.name}`);

                                        // Normalize
                                        const idx = meta.indices[0];
                                        const mean = numericMeans[idx] || 0;
                                        const std = numericStds[idx] || 1;
                                        inputVector.push((numVal - mean) / std);
                                    } else {
                                        // One-Hot Encode
                                        const catIdx = meta.categories.indexOf(val);
                                        if (catIdx === -1) throw new Error(`無效的類別值：${meta.name}`);

                                        for (let k = 0; k < meta.categories.length; k++) {
                                            inputVector.push(k === catIdx ? 1 : 0);
                                        }
                                    }
                                }

                                // 2. Predict
                                const inputTensor = tf.tensor2d([inputVector]);
                                const predTensor = model.predict(inputTensor);
                                const predData = await predTensor.data();

                                inputTensor.dispose();
                                predTensor.dispose();

                                // 3. Display Result
                                let resHtml = '';
                                if (taskInfo.type === 'regression') {
                                    const rawPred = predData[0] * yStd + yMean;
                                    resHtml = `
                                        <div class="p-4 bg-white border border-purple-200 rounded-lg shadow-sm">
                                            <div class="flex items-center justify-between">
                                                <div>
                                                    <p class="text-gray-600 text-sm">神經網絡模型預測</p>
                                                    <p class="text-lg font-bold text-gray-800 mt-1">預測 ${yVar}</p>
                                                </div>
                                                <div class="text-2xl font-bold text-purple-600">
                                                    ${rawPred.toFixed(4)}
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                } else {
                                    // Classification
                                    const uniqueY = taskInfo.uniqueY;
                                    let probs = [];
                                    if (taskInfo.type === 'binary-classification') {
                                        const p1 = predData[0];
                                        probs = [1 - p1, p1];
                                    } else {
                                        probs = Array.from(predData);
                                    }

                                    const probList = probs.map((p, i) => {
                                        const label = uniqueY[i];
                                        const pct = (p * 100).toFixed(2);
                                        const barColor = i === probs.indexOf(Math.max(...probs)) ? 'bg-indigo-600' : 'bg-gray-300';
                                        return `
                                            <div class="mb-2">
                                                <div class="flex justify-between text-sm mb-1">
                                                    <span>${label}</span>
                                                    <span>${pct}%</span>
                                                </div>
                                                <div class="w-full bg-gray-200 rounded-full h-2.5">
                                                    <div class="${barColor} h-2.5 rounded-full" style="width: ${pct}%"></div>
                                                </div>
                                            </div>
                                        `;
                                    }).join('');

                                    resHtml = `<div class="p-3 bg-white border rounded"><h5 class="text-sm font-semibold mb-2">預測機率分佈：</h5>${probList}</div>`;
                                }

                                resultDiv.innerHTML = resHtml;
                            } catch (err) {
                                resultDiv.innerHTML = `<p class="text-red-600">錯誤：${err.message}</p>`;
                            }
                        });
                    }
                }
            }

            document.addEventListener('DOMContentLoaded', function () {
                const btn = document.getElementById('runNNBtn');
                if (btn) {
                    btn.addEventListener('click', function () {
                        runNeuralNetworkTraining();
                    });
                }
            });
        })();
    </script>

</body>

</html>